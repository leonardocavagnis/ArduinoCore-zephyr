/*
Copyright (c) 2010 - 2025, Nordic Semiconductor ASA All rights reserved.

SPDX-License-Identifier: BSD-3-Clause

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. Neither the name of Nordic Semiconductor ASA nor the names of its
   contributors may be used to endorse or promote products derived from this
   software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
 *
 * @file     nrf9120.h
 * @brief    CMSIS HeaderFile
 * @version  1
 * @date     12. February 2025
 * @note     Generated by SVDConv V3.3.35 on Wednesday, 12.02.2025 14:52:39
 *           from File 'nrf9120.svd',
 *           last modified on Wednesday, 12.02.2025 13:51:26
 */



/** @addtogroup Nordic Semiconductor
  * @{
  */


/** @addtogroup nrf9120
  * @{
  */


#ifndef NRF9120_H
#define NRF9120_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M33 Specific Interrupt Numbers  ======================================= */
  Reset_IRQn                = -15,
  NonMaskableInt_IRQn       = -14,
  HardFault_IRQn            = -13,
  MemoryManagement_IRQn     = -12,              /*!< -12  Memory Management, MPU mismatch, including Access Violation
                                                     and No Match                                                              */
  BusFault_IRQn             = -11,              /*!< -11  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                     related Fault                                                             */
  UsageFault_IRQn           = -10,
  SecureFault_IRQn          =  -9,
  SVCall_IRQn               =  -5,
  DebugMonitor_IRQn         =  -4,
  PendSV_IRQn               =  -2,
  SysTick_IRQn              =  -1,
/* ==========================================  nrf9120 Specific Interrupt Numbers  =========================================== */
  SPU_IRQn                  =   3,
  CLOCK_POWER_IRQn          =   5,
  SPIM0_SPIS0_TWIM0_TWIS0_UARTE0_IRQn=   8,
  SPIM1_SPIS1_TWIM1_TWIS1_UARTE1_IRQn=   9,
  SPIM2_SPIS2_TWIM2_TWIS2_UARTE2_IRQn=  10,
  SPIM3_SPIS3_TWIM3_TWIS3_UARTE3_IRQn=  11,
  GPIOTE0_IRQn              =  13,
  SAADC_IRQn                =  14,
  TIMER0_IRQn               =  15,
  TIMER1_IRQn               =  16,
  TIMER2_IRQn               =  17,
  RTC0_IRQn                 =  20,
  RTC1_IRQn                 =  21,
  WDT_IRQn                  =  24,
  EGU0_IRQn                 =  27,
  EGU1_IRQn                 =  28,
  EGU2_IRQn                 =  29,
  EGU3_IRQn                 =  30,
  EGU4_IRQn                 =  31,
  EGU5_IRQn                 =  32,
  PWM0_IRQn                 =  33,
  PWM1_IRQn                 =  34,
  PWM2_IRQn                 =  35,
  PWM3_IRQn                 =  36,
  PDM_IRQn                  =  38,
  I2S_IRQn                  =  40,
  IPC_IRQn                  =  42,
  FPU_IRQn                  =  44,
  GPIOTE1_IRQn              =  49,
  KMU_IRQn                  =  57,
  CRYPTOCELL_IRQn           =  64
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ==========================  Configuration of the ARM Cortex-M33 Processor and Core Peripherals  =========================== */
#define __CM33_REV                 0x0004U
#define __INTERRUPTS_MAX                   240
#define __DSP_PRESENT                  1
#define __NVIC_PRIO_BITS               3
#define __Vendor_SysTickConfig         0
#define __VTOR_PRESENT                 1
#define __MPU_PRESENT                  1
#define __FPU_PRESENT                  1
#define __FPU_DP                       0
#define __SAUREGION_PRESENT            0


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm33.h"
#include "system_nrf9120.h"

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* ========================================  Start of section using anonymous unions  ======================================== */
#if defined (__CC_ARM)
  #pragma push
  #pragma anon_unions
#elif defined (__ICCARM__)
  #pragma language=extended
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic push
  #pragma clang diagnostic ignored "-Wc11-extensions"
  #pragma clang diagnostic ignored "-Wreserved-id-macro"
  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
  #pragma clang diagnostic ignored "-Wnested-anon-types"
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning 586
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#else
  #warning Not supported compiler type
#endif


/* =========================================================================================================================== */
/* ================                              Device Specific Cluster Section                              ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_clusters
  * @{
  */


/**
  * @brief FICR_INFO [INFO] (Device info)
  */
typedef struct {
  __IM  uint32_t  RESERVED;
  __IM  uint32_t  DEVICEID[2];
  __IM  uint32_t  PART;
  __IM  uint32_t  VARIANT;                      /*!< (@ 0x00000010) Part Variant, Hardware version and Production
                                                                    configuration                                              */
  __IM  uint32_t  PACKAGE;
  __IM  uint32_t  RAM;
  __IM  uint32_t  FLASH;
  __IM  uint32_t  CODEPAGESIZE;
  __IM  uint32_t  CODESIZE;
  __IM  uint32_t  DEVICETYPE;
} FICR_INFO_Type;


/**
  * @brief FICR_TRIMCNF [TRIMCNF] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  ADDR;
  __IM  uint32_t  DATA;
} FICR_TRIMCNF_Type;


/**
  * @brief FICR_TRNG90B [TRNG90B] (NIST800-90B RNG calibration data)
  */
typedef struct {
  __IM  uint32_t  BYTES;
  __IM  uint32_t  RCCUTOFF;
  __IM  uint32_t  APCUTOFF;
  __IM  uint32_t  STARTUP;
  __IM  uint32_t  ROSC1;                        /*!< (@ 0x00000010) Sample count for ring oscillator configuration
                                                                    1                                                          */
  __IM  uint32_t  ROSC2;                        /*!< (@ 0x00000014) Sample count for ring oscillator configuration
                                                                    2                                                          */
  __IM  uint32_t  ROSC3;                        /*!< (@ 0x00000018) Sample count for ring oscillator configuration
                                                                    3                                                          */
  __IM  uint32_t  ROSC4;                        /*!< (@ 0x0000001C) Sample count for ring oscillator configuration
                                                                    4                                                          */
} FICR_TRNG90B_Type;


/**
  * @brief UICR_KEYSLOT_CONFIG [CONFIG] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DEST;                         /*!< (@ 0x00000000) Description cluster: Destination address where
                                                                    content of the key value registers (KEYSLOT.KEYn.VALUE[0-3
                                                                    ) will be pushed by KMU. Note that this
                                                                    address must match that of a peripheral's
                                                                    APB mapped write-only key registers, otherwise
                                                                    the KMU can push this key value into an
                                                                    address range which the CPU can potentially
                                                                    read.                                                      */
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000004) Description cluster: Define permissions for the
                                                                    key slot. Bits 0-15 and 16-31 can only be
                                                                    written when equal to 0xFFFF.                              */
} UICR_KEYSLOT_CONFIG_Type;


/**
  * @brief UICR_KEYSLOT_KEY [KEY] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  VALUE[4];                     /*!< (@ 0x00000000) Description collection: Define bits [31+o*32:0+o*32]
                                                                    of value assigned to KMU key slot.                         */
} UICR_KEYSLOT_KEY_Type;


/**
  * @brief UICR_KEYSLOT [KEYSLOT] (Unspecified)
  */
typedef struct {
  __IOM UICR_KEYSLOT_CONFIG_Type CONFIG[128];
  __IOM UICR_KEYSLOT_KEY_Type KEY[128];
} UICR_KEYSLOT_Type;


/**
  * @brief TAD_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  TRACECLK;
  __IOM uint32_t  TRACEDATA0;
  __IOM uint32_t  TRACEDATA1;
  __IOM uint32_t  TRACEDATA2;
  __IOM uint32_t  TRACEDATA3;
} TAD_PSEL_Type;


/**
  * @brief SPU_EXTDOMAIN [EXTDOMAIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Access for bus access generated
                                                                    from the external domain n List capabilities
                                                                    of the external domain n                                   */
} SPU_EXTDOMAIN_Type;


/**
  * @brief SPU_DPPI [DPPI] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Select between secure and
                                                                    non-secure attribute for the DPPI channels.                */
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000004) Description cluster: Prevent further modification
                                                                    of the corresponding PERM register                         */
} SPU_DPPI_Type;


/**
  * @brief SPU_GPIOPORT [GPIOPORT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Select between secure and
                                                                    non-secure attribute for pins 0 to 31 of
                                                                    port n.                                                    */
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000004) Description cluster: Prevent further modification
                                                                    of the corresponding PERM register                         */
} SPU_GPIOPORT_Type;


/**
  * @brief SPU_FLASHNSC [FLASHNSC] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  REGION;                       /*!< (@ 0x00000000) Description cluster: Define which flash region
                                                                    can contain the non-secure callable (NSC)
                                                                    region n                                                   */
  __IOM uint32_t  SIZE;                         /*!< (@ 0x00000004) Description cluster: Define the size of the non-secure
                                                                    callable (NSC) region n                                    */
} SPU_FLASHNSC_Type;


/**
  * @brief SPU_RAMNSC [RAMNSC] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  REGION;                       /*!< (@ 0x00000000) Description cluster: Define which RAM region
                                                                    can contain the non-secure callable (NSC)
                                                                    region n                                                   */
  __IOM uint32_t  SIZE;                         /*!< (@ 0x00000004) Description cluster: Define the size of the non-secure
                                                                    callable (NSC) region n                                    */
} SPU_RAMNSC_Type;


/**
  * @brief SPU_FLASHREGION [FLASHREGION] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Access permissions for flash
                                                                    region n                                                   */
} SPU_FLASHREGION_Type;


/**
  * @brief SPU_RAMREGION [RAMREGION] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Access permissions for RAM
                                                                    region n                                                   */
} SPU_RAMREGION_Type;


/**
  * @brief SPU_PERIPHID [PERIPHID] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: List capabilities and access
                                                                    permissions for the peripheral with ID n                   */
} SPU_PERIPHID_Type;


/**
  * @brief POWER_LTEMODEM [LTEMODEM] (LTE Modem)
  */
typedef struct {
  __IOM uint32_t  STARTN;
  __IOM uint32_t  FORCEOFF;
} POWER_LTEMODEM_Type;


/**
  * @brief CTRLAPPERI_MAILBOX [MAILBOX] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  RXDATA;
  __IM  uint32_t  RXSTATUS;                     /*!< (@ 0x00000004) This register shows a status that indicates if
                                                                    data sent from the debugger to the CPU has
                                                                    been read.                                                 */
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  TXDATA;
  __IM  uint32_t  TXSTATUS;                     /*!< (@ 0x00000084) This register shows a status that indicates if
                                                                    the data sent from the CPU to the debugger
                                                                    has been read.                                             */
} CTRLAPPERI_MAILBOX_Type;


/**
  * @brief CTRLAPPERI_ERASEPROTECT [ERASEPROTECT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000000) This register locks the ERASEPROTECT.DISABLE
                                                                    register from being written until next reset.              */
  __IOM uint32_t  DISABLE;                      /*!< (@ 0x00000004) This register disables the ERASEPROTECT register
                                                                    and performs an ERASEALL operation.                        */
} CTRLAPPERI_ERASEPROTECT_Type;


/**
  * @brief SPIM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;
  __IOM uint32_t  MOSI;
  __IOM uint32_t  MISO;
} SPIM_PSEL_Type;


/**
  * @brief SPIM_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} SPIM_RXD_Type;


/**
  * @brief SPIM_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} SPIM_TXD_Type;


/**
  * @brief SPIS_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;
  __IOM uint32_t  MISO;
  __IOM uint32_t  MOSI;
  __IOM uint32_t  CSN;
} SPIS_PSEL_Type;


/**
  * @brief SPIS_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} SPIS_RXD_Type;


/**
  * @brief SPIS_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} SPIS_TXD_Type;


/**
  * @brief TWIM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;
  __IOM uint32_t  SDA;
} TWIM_PSEL_Type;


/**
  * @brief TWIM_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} TWIM_RXD_Type;


/**
  * @brief TWIM_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} TWIM_TXD_Type;


/**
  * @brief TWIS_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;
  __IOM uint32_t  SDA;
} TWIS_PSEL_Type;


/**
  * @brief TWIS_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} TWIS_RXD_Type;


/**
  * @brief TWIS_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} TWIS_TXD_Type;


/**
  * @brief UARTE_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RTS;
  __IOM uint32_t  TXD;
  __IOM uint32_t  CTS;
  __IOM uint32_t  RXD;
} UARTE_PSEL_Type;


/**
  * @brief UARTE_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
} UARTE_RXD_Type;


/**
  * @brief UARTE_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
} UARTE_TXD_Type;


/**
  * @brief SAADC_EVENTS_CH [EVENTS_CH] (Peripheral events.)
  */
typedef struct {
  __IOM uint32_t  LIMITH;                       /*!< (@ 0x00000000) Description cluster: Last results is equal or
                                                                    above CH[n].LIMIT.HIGH                                     */
  __IOM uint32_t  LIMITL;                       /*!< (@ 0x00000004) Description cluster: Last results is equal or
                                                                    below CH[n].LIMIT.LOW                                      */
} SAADC_EVENTS_CH_Type;


/**
  * @brief SAADC_PUBLISH_CH [PUBLISH_CH] (Publish configuration for events)
  */
typedef struct {
  __IOM uint32_t  LIMITH;                       /*!< (@ 0x00000000) Description cluster: Publish configuration for
                                                                    event CH[n].LIMITH                                         */
  __IOM uint32_t  LIMITL;                       /*!< (@ 0x00000004) Description cluster: Publish configuration for
                                                                    event CH[n].LIMITL                                         */
} SAADC_PUBLISH_CH_Type;


/**
  * @brief SAADC_CH [CH] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PSELP;                        /*!< (@ 0x00000000) Description cluster: Input positive pin selection
                                                                    for CH[n]                                                  */
  __IOM uint32_t  PSELN;                        /*!< (@ 0x00000004) Description cluster: Input negative pin selection
                                                                    for CH[n]                                                  */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000008) Description cluster: Input configuration for
                                                                    CH[n]                                                      */
  __IOM uint32_t  LIMIT;                        /*!< (@ 0x0000000C) Description cluster: High/low limits for event
                                                                    monitoring a channel                                       */
} SAADC_CH_Type;


/**
  * @brief SAADC_RESULT [RESULT] (RESULT EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of buffer words transferred since last
                                                                    START                                                      */
} SAADC_RESULT_Type;


/**
  * @brief DPPIC_TASKS_CHG [TASKS_CHG] (Channel group tasks)
  */
typedef struct {
  __OM  uint32_t  EN;
  __OM  uint32_t  DIS;
} DPPIC_TASKS_CHG_Type;


/**
  * @brief DPPIC_SUBSCRIBE_CHG [SUBSCRIBE_CHG] (Subscribe configuration for tasks)
  */
typedef struct {
  __IOM uint32_t  EN;                           /*!< (@ 0x00000000) Description cluster: Subscribe configuration
                                                                    for task CHG[n].EN                                         */
  __IOM uint32_t  DIS;                          /*!< (@ 0x00000004) Description cluster: Subscribe configuration
                                                                    for task CHG[n].DIS                                        */
} DPPIC_SUBSCRIBE_CHG_Type;


/**
  * @brief PWM_SEQ [SEQ] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Description cluster: Beginning address in RAM
                                                                    of this sequence                                           */
  __IOM uint32_t  CNT;                          /*!< (@ 0x00000004) Description cluster: Number of values (duty cycles)
                                                                    in this sequence                                           */
  __IOM uint32_t  REFRESH;                      /*!< (@ 0x00000008) Description cluster: Number of additional PWM
                                                                    periods between samples loaded into compare
                                                                    register                                                   */
  __IOM uint32_t  ENDDELAY;
  __IM  uint32_t  RESERVED[4];
} PWM_SEQ_Type;


/**
  * @brief PWM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  OUT[4];                       /*!< (@ 0x00000000) Description collection: Output pin select for
                                                                    PWM channel n                                              */
} PWM_PSEL_Type;


/**
  * @brief PDM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  CLK;
  __IOM uint32_t  DIN;
} PDM_PSEL_Type;


/**
  * @brief PDM_SAMPLE [SAMPLE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RAM address pointer to write samples to with
                                                                    EasyDMA                                                    */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Number of samples to allocate memory for in EasyDMA
                                                                    mode                                                       */
} PDM_SAMPLE_Type;


/**
  * @brief I2S_CONFIG [CONFIG] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MODE;
  __IOM uint32_t  RXEN;
  __IOM uint32_t  TXEN;
  __IOM uint32_t  MCKEN;
  __IOM uint32_t  MCKFREQ;
  __IOM uint32_t  RATIO;
  __IOM uint32_t  SWIDTH;
  __IOM uint32_t  ALIGN;
  __IOM uint32_t  FORMAT;
  __IOM uint32_t  CHANNELS;
} I2S_CONFIG_Type;


/**
  * @brief I2S_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
} I2S_RXD_Type;


/**
  * @brief I2S_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
} I2S_TXD_Type;


/**
  * @brief I2S_RXTXD [RXTXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MAXCNT;
} I2S_RXTXD_Type;


/**
  * @brief I2S_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MCK;
  __IOM uint32_t  SCK;
  __IOM uint32_t  LRCK;
  __IOM uint32_t  SDIN;
  __IOM uint32_t  SDOUT;
} I2S_PSEL_Type;


/**
  * @brief APPROTECT_SECUREAPPROTECT [SECUREAPPROTECT] (Unspecified)
  */
typedef struct {
  union {
    __IOM uint32_t DISABLE;
    __IOM uint32_t FORCEPROTECT;
  };
} APPROTECT_SECUREAPPROTECT_Type;


/**
  * @brief APPROTECT_APPROTECT [APPROTECT] (Unspecified)
  */
typedef struct {
  union {
    __IOM uint32_t DISABLE;
    __IOM uint32_t FORCEPROTECT;
  };
} APPROTECT_APPROTECT_Type;


/**
  * @brief VMC_RAM [RAM] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  POWER;
  __OM  uint32_t  POWERSET;
  __OM  uint32_t  POWERCLR;                     /*!< (@ 0x00000008) Description cluster: RAMn power control clear
                                                                    register                                                   */
  __IM  uint32_t  RESERVED;
} VMC_RAM_Type;


/** @} */ /* End of group Device_Peripheral_clusters */


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                          FICR_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Factory Information Configuration Registers (FICR_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[128];
  __IOM FICR_INFO_Type INFO;
  __IM  uint32_t  RESERVED1[53];
  __IOM FICR_TRIMCNF_Type TRIMCNF[256];
  __IM  uint32_t  RESERVED2[64];
  __IOM FICR_TRNG90B_Type TRNG90B;
} NRF_FICR_Type;



/* =========================================================================================================================== */
/* ================                                          UICR_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief User information configuration registers User information configuration registers (UICR_S)
  */

typedef struct {
  __IOM uint32_t  APPROTECT;
  __IM  uint32_t  RESERVED[4];
  __IOM uint32_t  XOSC32M;
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  HFXOSRC;
  __IOM uint32_t  HFXOCNT;
  __IOM uint32_t  APPNVMCPOFGUARD;              /*!< (@ 0x00000024) Enable blocking NVM WRITE and aborting NVM ERASE
                                                                    for Application NVM in POFWARN condition.                  */
  __IOM uint32_t  PMICCONF;
  __IOM uint32_t  SECUREAPPROTECT;
  __IOM uint32_t  ERASEPROTECT;
  __IM  uint32_t  RESERVED2[53];
  __IOM uint32_t  OTP[190];                     /*!< (@ 0x00000108) Description collection: One time programmable
                                                                    memory                                                     */
  __IOM UICR_KEYSLOT_Type KEYSLOT;
} NRF_UICR_Type;



/* =========================================================================================================================== */
/* ================                                          ETM_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Embedded Trace Macrocell (ETM_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  TRCPRGCTLR;
  __IOM uint32_t  TRCPROCSELR;                  /*!< (@ 0x00000008) Controls which PE to trace. Might ignore writes
                                                                    when the trace unit is enabled or not idle.
                                                                    Before writing to this register, ensure
                                                                    that TRCSTATR.IDLE == 1 so that the trace
                                                                    unit can synchronize with the chosen PE.
                                                                    Implemented if TRCIDR3.NUMPROC is greater
                                                                    than zero.                                                 */
  __IOM uint32_t  TRCSTATR;
  __IOM uint32_t  TRCCONFIGR;                   /*!< (@ 0x00000010) Controls the tracing options This register must
                                                                    always be programmed as part of trace unit
                                                                    initialization. Might ignore writes when
                                                                    the trace unit is enabled or not idle.                     */
  __IM  uint32_t  RESERVED1[3];
  __IOM uint32_t  TRCEVENTCTL0R;                /*!< (@ 0x00000020) Controls the tracing of arbitrary events. If
                                                                    the selected event occurs a trace element
                                                                    is generated in the trace stream according
                                                                    to the settings in TRCEVENTCTL1R.DATAEN
                                                                    and TRCEVENTCTL1R.INSTEN.                                  */
  __IOM uint32_t  TRCEVENTCTL1R;                /*!< (@ 0x00000024) Controls the behavior of the events that TRCEVENTCTL0R
                                                                    selects. This register must always be programmed
                                                                    as part of trace unit initialization. Might
                                                                    ignore writes when the trace unit is enabled
                                                                    or not idle.                                               */
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  TRCSTALLCTLR;                 /*!< (@ 0x0000002C) Enables trace unit functionality that prevents
                                                                    trace unit buffer overflows. Might ignore
                                                                    writes when the trace unit is enabled or
                                                                    not idle. Must be programmed if TRCIDR3.STALLCTL
                                                                    == 1.                                                      */
  __IOM uint32_t  TRCTSCTLR;                    /*!< (@ 0x00000030) Controls the insertion of global timestamps in
                                                                    the trace streams. When the selected event
                                                                    is triggered, the trace unit inserts a global
                                                                    timestamp into the trace streams. Might
                                                                    ignore writes when the trace unit is enabled
                                                                    or not idle. Must be programmed if TRCCONFIGR.TS
                                                                    == 1.                                                      */
  __IOM uint32_t  TRCSYNCPR;                    /*!< (@ 0x00000034) Controls how often trace synchronization requests
                                                                    occur. Might ignore writes when the trace
                                                                    unit is enabled or not idle. If writes are
                                                                    permitted then the register must be programmed.            */
  __IOM uint32_t  TRCCCCTLR;                    /*!< (@ 0x00000038) Sets the threshold value for cycle counting.
                                                                    Might ignore writes when the trace unit
                                                                    is enabled or not idle. Must be programmed
                                                                    if TRCCONFIGR.CCI==1.                                      */
  __IOM uint32_t  TRCBBCTLR;                    /*!< (@ 0x0000003C) Controls which regions in the memory map are
                                                                    enabled to use branch broadcasting. Might
                                                                    ignore writes when the trace unit is enabled
                                                                    or not idle. Must be programmed if TRCCONFIGR.BB
                                                                    == 1.                                                      */
  __IOM uint32_t  TRCTRACEIDR;                  /*!< (@ 0x00000040) Sets the trace ID for instruction trace. If data
                                                                    trace is enabled then it also sets the trace
                                                                    ID for data trace, to (trace ID for instruction
                                                                    trace) + 1. This register must always be
                                                                    programmed as part of trace unit initialization.
                                                                    Might ignore writes when the trace unit
                                                                    is enabled or not idle.                                    */
  __IOM uint32_t  TRCQCTLR;                     /*!< (@ 0x00000044) Controls when Q elements are enabled. Might ignore
                                                                    writes when the trace unit is enabled or
                                                                    not idle. This register must be programmed
                                                                    if it is implemented and TRCCONFIGR.QE is
                                                                    set to any value other than 0b00.                          */
  __IM  uint32_t  RESERVED3[14];
  __IOM uint32_t  TRCVICTLR;                    /*!< (@ 0x00000080) Controls instruction trace filtering. Might ignore
                                                                    writes when the trace unit is enabled or
                                                                    not idle. Only returns stable data when
                                                                    TRCSTATR.PMSTABLE == 1. Must be programmed,
                                                                    particularly to set the value of the SSSTATUS
                                                                    bit, which sets the state of the start/stop
                                                                    logic.                                                     */
  __IOM uint32_t  TRCVIIECTLR;                  /*!< (@ 0x00000084) ViewInst exclude control. Might ignore writes
                                                                    when the trace unit is enabled or not idle.
                                                                    This register must be programmed when one
                                                                    or more address comparators are implemented.               */
  __IOM uint32_t  TRCVISSCTLR;                  /*!< (@ 0x00000088) Use this to set, or read, the single address
                                                                    comparators that control the ViewInst start/stoplogic.
                                                                    The start/stop logic is active for an instruction
                                                                    which causes a start and remains activeup
                                                                    to and including an instruction which causes
                                                                    a stop, and then the start/stop logic becomesinactive.
                                                                    Might ignore writes when the trace unit
                                                                    is enabled or not idle. If implemented then
                                                                    this register must be programmed.                          */
  __IOM uint32_t  TRCVIPCSSCTLR;                /*!< (@ 0x0000008C) Use this to set, or read, which PE comparator
                                                                    inputs can control the ViewInst start/stop
                                                                    logic. Might ignore writes when the trace
                                                                    unit is enabled or not idle. If implemented
                                                                    then this register must be programmed.                     */
  __IM  uint32_t  RESERVED4[4];
  __IOM uint32_t  TRCVDCTLR;                    /*!< (@ 0x000000A0) Controls data trace filtering. Might ignore writes
                                                                    when the trace unit is enabled or not idle.
                                                                    This register must be programmed when data
                                                                    tracing is enabled, that is, when either
                                                                    TRCCONFIGR.DA == 1 or TRCCONFIGR.DV == 1.                  */
  __IOM uint32_t  TRCVDSACCTLR;                 /*!< (@ 0x000000A4) ViewData include / exclude control. Might ignore
                                                                    writes when the trace unit is enabled or
                                                                    not idle. This register must be programmed
                                                                    when one or more address comparators are
                                                                    implemented.                                               */
  __IOM uint32_t  TRCVDARCCTLR;                 /*!< (@ 0x000000A8) ViewData include / exclude control. Might ignore
                                                                    writes when the trace unit is enabled or
                                                                    not idle. This register must be programmed
                                                                    when one or more address comparators are
                                                                    implemented.                                               */
  __IM  uint32_t  RESERVED5[21];
  __IOM uint32_t  TRCSEQEVR[3];                 /*!< (@ 0x00000100) Description collection: Moves the sequencer state
                                                                    according to programmed events. Might ignore
                                                                    writes when the trace unit is enabled or
                                                                    not idle. When the sequencer is used, all
                                                                    sequencer state transitions must be programmed
                                                                    with a valid event.                                        */
  __IM  uint32_t  RESERVED6[3];
  __IOM uint32_t  TRCSEQRSTEVR;                 /*!< (@ 0x00000118) Moves the sequencer to state 0 when a programmed
                                                                    event occurs. Might ignore writes when the
                                                                    trace unit is enabled or not idle. When
                                                                    the sequencer is used, all sequencer state
                                                                    transitions must be programmed with a valid
                                                                    event.                                                     */
  __IOM uint32_t  TRCSEQSTR;                    /*!< (@ 0x0000011C) Use this to set, or read, the sequencer state.
                                                                    Might ignore writes when the trace unit
                                                                    is enabled or not idle. Only returns stable
                                                                    data when TRCSTATR.PMSTABLE == 1. When the
                                                                    sequencer is used, all sequencer state transitions
                                                                    must be programmed with a valid event.                     */
  __IOM uint32_t  TRCEXTINSELR;                 /*!< (@ 0x00000120) Use this to set, or read, which external inputs
                                                                    are resources to the trace unit. Might ignore
                                                                    writes when the trace unit is enabled or
                                                                    not idle. Only returns stable data when
                                                                    TRCSTATR.PMSTABLE == 1. When the sequencer
                                                                    is used, all sequencer state transitions
                                                                    must be programmed with a valid event.                     */
  __IM  uint32_t  RESERVED7[7];
  __IOM uint32_t  TRCCNTRLDVR[4];               /*!< (@ 0x00000140) Description collection: This sets or returns
                                                                    the reload count value for counter n. Might
                                                                    ignore writes when the trace unit is enabled
                                                                    or not idle.                                               */
  __IOM uint32_t  TRCCNTCTLR[4];                /*!< (@ 0x00000150) Description collection: Controls the operation
                                                                    of counter n. Might ignore writes when the
                                                                    trace unit is enabled or not idle.                         */
  __IOM uint32_t  TRCCNTVR[4];                  /*!< (@ 0x00000160) Description collection: This sets or returns
                                                                    the value of counter n. The count value
                                                                    is only stable when TRCSTATR.PMSTABLE ==
                                                                    1. If software uses counter n then it must
                                                                    write to this register to set the initial
                                                                    counter value. Might ignore writes when
                                                                    the trace unit is enabled or not idle.                     */
  __IM  uint32_t  RESERVED8[36];
  __IOM uint32_t  TRCRSCTLR[30];                /*!< (@ 0x00000200) Description collection: Controls the selection
                                                                    of the resources in the trace unit. Might
                                                                    ignore writes when the trace unit is enabled
                                                                    or not idle. If software selects a non-implemented
                                                                    resource then CONSTRAINED UNPREDICTABLEbehavior
                                                                    of the resource selector occurs, so the
                                                                    resource selector might fireunexpectedly
                                                                    or might not fire. Reads of the TRCRSCTLRn
                                                                    might return UNKNOWN.                                      */
  __IM  uint32_t  RESERVED9[2];
  __IOM uint32_t  TRCSSCCR0;
  __IM  uint32_t  RESERVED10[7];
  __IOM uint32_t  TRCSSCSR0;                    /*!< (@ 0x000002A0) Indicates the status of the single-shot comparators.
                                                                    TRCSSCSR0 is sensitive toinstruction addresses.            */
  __IM  uint32_t  RESERVED11[7];
  __IOM uint32_t  TRCSSPCICR0;                  /*!< (@ 0x000002C0) Selects the processor comparator inputs for Single-shot
                                                                    control.                                                   */
  __IM  uint32_t  RESERVED12[19];
  __IOM uint32_t  TRCPDCR;
  __IOM uint32_t  TRCPDSR;
  __IM  uint32_t  RESERVED13[755];
  __IOM uint32_t  TRCITATBIDR;
  __IM  uint32_t  RESERVED14[3];
  __IOM uint32_t  TRCITIATBINR;
  __IM  uint32_t  RESERVED15;
  __IOM uint32_t  TRCITIATBOUTR;
  __IOM uint32_t  TRCITCTRL;                    /*!< (@ 0x00000F00) Enables topology detection or integration testing,
                                                                    by putting ETM-M33 into integration mode.                  */
  __IM  uint32_t  RESERVED16[39];
  __IOM uint32_t  TRCCLAIMSET;                  /*!< (@ 0x00000FA0) Sets bits in the claim tag and determines the
                                                                    number of claim tag bits implemented.                      */
  __IOM uint32_t  TRCCLAIMCLR;                  /*!< (@ 0x00000FA4) Clears bits in the claim tag and determines the
                                                                    current value of the claim tag.                            */
  __IM  uint32_t  RESERVED17[4];
  __IOM uint32_t  TRCAUTHSTATUS;                /*!< (@ 0x00000FB8) Indicates the current level of tracing permitted
                                                                    by the system                                              */
  __IM  uint32_t  TRCDEVARCH;                   /*!< (@ 0x00000FBC) The TRCDEVARCH identifies ETM-M33 as an ETMv4.2
                                                                    component                                                  */
  __IM  uint32_t  RESERVED18[3];
  __IM  uint32_t  TRCDEVTYPE;
  __IOM uint32_t  TRCPIDR[8];                   /*!< (@ 0x00000FD0) Description collection: Coresight peripheral
                                                                    identification registers.                                  */
  __IOM uint32_t  TRCCIDR[4];                   /*!< (@ 0x00000FF0) Description collection: Coresight component identification
                                                                    registers.                                                 */
} NRF_ETM_Type;



/* =========================================================================================================================== */
/* ================                                          ETB_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Embedded Trace Buffer (ETB_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED;
  __IM  uint32_t  RDP;
  __IM  uint32_t  RESERVED1;
  __IM  uint32_t  STS;
  __IM  uint32_t  RRD;
  __IOM uint32_t  RRP;
  __IOM uint32_t  RWP;
  __IOM uint32_t  TRG;
  __IOM uint32_t  CTL;
  __IOM uint32_t  RWD;
  __IM  uint32_t  RESERVED2[182];
  __IM  uint32_t  FFSR;
  __IOM uint32_t  FFCR;
  __IM  uint32_t  RESERVED3[758];
  __OM  uint32_t  ITMISCOP0;                    /*!< (@ 0x00000EE0) Integration Test Miscellaneous Output Register
                                                                    0                                                          */
  __OM  uint32_t  ITTRFLINACK;                  /*!< (@ 0x00000EE4) Integration Test Trigger In and Flush In Acknowledge
                                                                    Register                                                   */
  __IM  uint32_t  ITTRFLIN;
  __IM  uint32_t  ITATBDATA0;
  __OM  uint32_t  ITATBCTR2;
  __IM  uint32_t  ITATBCTR1;
  __IM  uint32_t  ITATBCTR0;
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  ITCTRL;
  __IM  uint32_t  RESERVED5[39];
  __IOM uint32_t  CLAIMSET;
  __IOM uint32_t  CLAIMCLR;
  __IM  uint32_t  RESERVED6[2];
  __OM  uint32_t  LAR;
  __IM  uint32_t  LSR;
  __IM  uint32_t  AUTHSTATUS;
  __IM  uint32_t  RESERVED7[3];
  __IM  uint32_t  DEVID;
  __IM  uint32_t  DEVTYPE;
  __IM  uint32_t  PERIPHID4;
  __IM  uint32_t  RESERVED8[3];
  __IM  uint32_t  PERIPHID0;
  __IM  uint32_t  PERIPHID1;
  __IM  uint32_t  PERIPHID2;
  __IM  uint32_t  PERIPHID3;
  __IM  uint32_t  COMPID0;
  __IM  uint32_t  COMPID1;
  __IM  uint32_t  COMPID2;
  __IM  uint32_t  COMPID3;
} NRF_ETB_Type;



/* =========================================================================================================================== */
/* ================                                          TPIU_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Trace Port Interface Unit (TPIU_NS)
  */

typedef struct {
  __IOM uint32_t  SUPPORTEDPORTSIZES;           /*!< (@ 0x00000000) Each bit location is a single port size that
                                                                    is supported on the device.                                */
  __IOM uint32_t  CURRENTPORTSIZE;              /*!< (@ 0x00000004) Each bit location is a single port size. One
                                                                    bit can be set, and indicates the current
                                                                    port size.                                                 */
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  SUPPORTEDTRIGGERMODES;        /*!< (@ 0x00000100) The Supported_trigger_modes register indicates
                                                                    the implemented trigger counter multipliers
                                                                    and other supported features of the trigger
                                                                    system.                                                    */
  __IOM uint32_t  TRIGGERCOUNTERVALUE;          /*!< (@ 0x00000104) The Trigger_counter_value register enables delaying
                                                                    the indication of triggers to any external
                                                                    connected trace capture or storage devices.                */
  __IOM uint32_t  TRIGGERMULTIPLIER;            /*!< (@ 0x00000108) The Trigger_multiplier register contains the
                                                                    selectors for the trigger counter multiplier.              */
  __IM  uint32_t  RESERVED1[61];
  __IOM uint32_t  SUPPPORTEDTESTPATTERNMODES;   /*!< (@ 0x00000200) The Supported_test_pattern_modes register provides
                                                                    a set of known bit sequences or patterns
                                                                    that can be output over the trace port and
                                                                    can be detected by the TPA or other associated
                                                                    trace capture device.                                      */
  __IOM uint32_t  CURRENTTESTPATTERNMODES;      /*!< (@ 0x00000204) Current_test_pattern_mode indicates the current
                                                                    test pattern or mode selected.                             */
  __IOM uint32_t  TPRCR;                        /*!< (@ 0x00000208) The TPRCR register is an 8-bit counter start
                                                                    value that is decremented. A write sets
                                                                    the initial counter value and a read returns
                                                                    the programmed value.                                      */
  __IM  uint32_t  RESERVED2[61];
  __IOM uint32_t  FFSR;                         /*!< (@ 0x00000300) The FFSR register indicates the current status
                                                                    of the formatter and flush features available
                                                                    in the TPIU.                                               */
  __IOM uint32_t  FFCR;                         /*!< (@ 0x00000304) The FFCR register controls the generation of
                                                                    stop, trigger, and flush events.                           */
  __IOM uint32_t  FSCR;                         /*!< (@ 0x00000308) The FSCR register enables the frequency of synchronization
                                                                    information to be optimized to suit the
                                                                    Trace Port Analyzer (TPA) capture buffer
                                                                    size.                                                      */
  __IM  uint32_t  RESERVED3[61];
  __IOM uint32_t  EXTCTLINPORT;                 /*!< (@ 0x00000400) Two ports can be used as a control and feedback
                                                                    mechanism for any serializers, pin sharing
                                                                    multiplexers, or other solutions that might
                                                                    be added to the trace output pins either
                                                                    for pin control or a high-speed trace port
                                                                    solution.                                                  */
  __IOM uint32_t  EXTCTLOUTPORT;                /*!< (@ 0x00000404) Two ports can be used as a control and feedback
                                                                    mechanism for any serializers, pin sharing
                                                                    multiplexers, or other solutions that might
                                                                    be added to the trace output pins either
                                                                    for pin control or a high speed trace port
                                                                    solution. These ports are raw register banks
                                                                    that sample or export the corresponding
                                                                    external pins.                                             */
  __IM  uint32_t  RESERVED4[695];
  __IOM uint32_t  ITTRFLINACK;                  /*!< (@ 0x00000EE4) The ITTRFLINACK register enables control of the
                                                                    triginack and flushinack outputs from the
                                                                    TPIU.                                                      */
  __IOM uint32_t  ITTRFLIN;                     /*!< (@ 0x00000EE8) The ITTRFLIN register contains the values of
                                                                    the flushin and trigin inputs to the TPIU.                 */
  __IOM uint32_t  ITATBDATA0;                   /*!< (@ 0x00000EEC) The ITATBDATA0 register contains the value of
                                                                    the atdatas inputs to the TPIU. The values
                                                                    are valid only when atvalids is HIGH.                      */
  __IOM uint32_t  ITATBCTR2;                    /*!< (@ 0x00000EF0) Enables control of the atreadys and afvalids
                                                                    outputs of the TPIU.                                       */
  __IOM uint32_t  ITATBCTR1;                    /*!< (@ 0x00000EF4) The ITATBCTR1 register contains the value of
                                                                    the atids input to the TPIU. This is only
                                                                    valid when atvalids is HIGH.                               */
  __IOM uint32_t  ITATBCTR0;                    /*!< (@ 0x00000EF8) The ITATBCTR0 register captures the values of
                                                                    the atvalids, afreadys, and atbytess inputs
                                                                    to the TPIU.  To ensure the integration
                                                                    registers work correctly in a system, the
                                                                    value of atbytess is only valid when atvalids,
                                                                    bit[0], is HIGH.                                           */
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  ITCTRL;                       /*!< (@ 0x00000F00) Used to enable topology detection.  This register
                                                                    enables the component to switch from a functional
                                                                    mode, the default behavior,  to integration
                                                                    mode where the inputs and outputs of the
                                                                    component can be directly controlled for
                                                                    integration testing and topology solving.                  */
  __IM  uint32_t  RESERVED6[39];
  __IOM uint32_t  CLAIMSET;                     /*!< (@ 0x00000FA0) Software can use the claim tag to coordinate
                                                                    application and debugger access to trace
                                                                    unit functionality.  The claim tags have
                                                                    no effect on the operation of the component.
                                                                    The CLAIMSET register sets bits in the claim
                                                                    tag, and determines the number of claim
                                                                    bits implemented.                                          */
  __IOM uint32_t  CLAIMCLR;                     /*!< (@ 0x00000FA4) Software can use the claim tag to coordinate
                                                                    application and debugger access to trace
                                                                    unit functionality.  The claim tags have
                                                                    no effect on the operation of the component.
                                                                    The CLAIMCLR register sets the bits in the
                                                                    claim tag to 0 and determines the current
                                                                    value of the claim tag.                                    */
  __IM  uint32_t  RESERVED7[2];
  __IOM uint32_t  LAR;                          /*!< (@ 0x00000FB0) This is used to enable write access to device
                                                                    registers.                                                 */
  __IOM uint32_t  LSR;                          /*!< (@ 0x00000FB4) This indicates the status of the lock control
                                                                    mechanism. This lock prevents accidental
                                                                    writes by code under debug.  Accesses to
                                                                    the extended stimulus port registers are
                                                                    not affected by the lock mechanism.  This
                                                                    register must always be present although
                                                                    there might not be any lock access control
                                                                    mechanism.  The lock mechanism, where present
                                                                    and locked, must block write accesses to
                                                                    any control register, except the Lock Access
                                                                    Register.  For most components this cover                  */
  __IOM uint32_t  AUTHSTATUS;                   /*!< (@ 0x00000FB8) Indicates the current level of tracing permitted
                                                                    by the system                                              */
  __IM  uint32_t  RESERVED8[3];
  __IM  uint32_t  DEVID;
  __IM  uint32_t  DEVTYPE;                      /*!< (@ 0x00000FCC) The DEVTYPE register provides a debugger with
                                                                    information about the component when the
                                                                    Part Number field is not recognized. The
                                                                    debugger can then report this information.                 */
  __IOM uint32_t  PIDR4;
  __IM  uint32_t  RESERVED9[3];
  __IOM uint32_t  PIDR_0;
  __IOM uint32_t  PIDR_1;
  __IOM uint32_t  PIDR_2;
  __IOM uint32_t  PIDR_3;
  __IOM uint32_t  CIDR_0;
  __IOM uint32_t  CIDR_1;
  __IOM uint32_t  CIDR_2;
  __IOM uint32_t  CIDR_3;
} NRF_TPIU_Type;



/* =========================================================================================================================== */
/* ================                                     ATBREPLICATOR_NS                                      ================ */
/* =========================================================================================================================== */


/**
  * @brief ATB Replicator module (ATBREPLICATOR_NS)
  */

typedef struct {
  __IOM uint32_t  IDFILTER0;                    /*!< (@ 0x00000000) The IDFILTER0 register enables the programming
                                                                    of ID filtering for master port 0.                         */
  __IOM uint32_t  IDFILTER1;                    /*!< (@ 0x00000004) The IDFILTER1 register enables the programming
                                                                    of ID filtering for master port 1.                         */
  __IM  uint32_t  RESERVED[956];
  __IOM uint32_t  ITATBCTR1;                    /*!< (@ 0x00000EF8) The ITATBCTR1 register returns the value of the
                                                                    atreadym0, atreadym1, and atvalids inputs
                                                                    in integration mode.                                       */
  __IOM uint32_t  ITATBCTR0;                    /*!< (@ 0x00000EFC) The ITATBCTR0 register controls the value of
                                                                    the atvalidm0, atvalidm1, and atreadys outputs
                                                                    in integration mode.                                       */
  __IOM uint32_t  ITCTRL;                       /*!< (@ 0x00000F00) The ITCTRL register enables the component to
                                                                    switch from a functional mode, which is
                                                                    the default behavior,  to integration mode
                                                                    where the inputs and outputs of the component
                                                                    can be directly controlled for the purposes
                                                                    of integration testing and topology detection.             */
  __IM  uint32_t  RESERVED1[39];
  __IOM uint32_t  CLAIMSET;                     /*!< (@ 0x00000FA0) Software can use the claim tag to coordinate
                                                                    application and debugger access to trace
                                                                    unit functionality.  The claim tags have
                                                                    no effect on the operation of the component.
                                                                    The CLAIMSET register sets bits in the claim
                                                                    tag, and determines the number of claim
                                                                    bits implemented.                                          */
  __IOM uint32_t  CLAIMCLR;                     /*!< (@ 0x00000FA4) Software can use the claim tag to coordinate
                                                                    application and debugger access to trace
                                                                    unit functionality.  The claim tags have
                                                                    no effect on the operation of the component.
                                                                    The CLAIMCLR register sets the bits in the
                                                                    claim tag to 0 and determines the current
                                                                    value of the claim tag.                                    */
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  LAR;                          /*!< (@ 0x00000FB0) This is used to enable write access to device
                                                                    registers.                                                 */
  __IOM uint32_t  LSR;                          /*!< (@ 0x00000FB4) This indicates the status of the lock control
                                                                    mechanism. This lock prevents accidental
                                                                    writes by code under debug.  Accesses to
                                                                    the extended stimulus port registers are
                                                                    not affected by the lock mechanism.  This
                                                                    register must always be present although
                                                                    there might not be any lock access control
                                                                    mechanism.  The lock mechanism, where present
                                                                    and locked, must block write accesses to
                                                                    any control register, except the Lock Access
                                                                    Register.  For most components this cover                  */
  __IOM uint32_t  AUTHSTATUS;                   /*!< (@ 0x00000FB8) Indicates the current level of tracing permitted
                                                                    by the system                                              */
  __IM  uint32_t  RESERVED3[3];
  __IM  uint32_t  DEVID;
  __IM  uint32_t  DEVTYPE;                      /*!< (@ 0x00000FCC) The DEVTYPE register provides a debugger with
                                                                    information about the component when the
                                                                    Part Number field is not recognized. The
                                                                    debugger can then report this information.                 */
  __IOM uint32_t  PIDR4;
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  PIDR_0;
  __IOM uint32_t  PIDR_1;
  __IOM uint32_t  PIDR_2;
  __IOM uint32_t  PIDR_3;
  __IOM uint32_t  CIDR_0;
  __IOM uint32_t  CIDR_1;
  __IOM uint32_t  CIDR_2;
  __IOM uint32_t  CIDR_3;
} NRF_ATBREPLICATOR_Type;



/* =========================================================================================================================== */
/* ================                                       ATBFUNNEL1_NS                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief ATB funnel module 0 (ATBFUNNEL1_NS)
  */

typedef struct {
  __IOM uint32_t  CTRLREG;                      /*!< (@ 0x00000000) The IDFILTER0 register enables the programming
                                                                    of ID filtering for master port 0.                         */
  __IOM uint32_t  PRIORITYCTRLREG;              /*!< (@ 0x00000004) The Priority_Ctrl_Reg register defines the order
                                                                    in which inputs are selected. Each 3-bit
                                                                    field is a priority for each particular
                                                                    slave interface.                                           */
  __IM  uint32_t  RESERVED[953];
  __IOM uint32_t  ITATBDATA0;                   /*!< (@ 0x00000EEC) The ITATBDATA0 register performs different functions
                                                                    depending on whether the access is a read
                                                                    or a write.                                                */
  __IOM uint32_t  ITATBCTR2;                    /*!< (@ 0x00000EF0) The ITATBCTR2 register performs different functions
                                                                    depending on whether the access is a read
                                                                    or a write.                                                */
  __IOM uint32_t  ITATBCTR1;                    /*!< (@ 0x00000EF4) The ITATBCTR1 register performs different functions
                                                                    depending on whether the access is a read
                                                                    or a write.                                                */
  __IOM uint32_t  ITATBCTR0;                    /*!< (@ 0x00000EF8) The ITATBCTR0 register performs different functions
                                                                    depending on whether the access is a read
                                                                    or a write.                                                */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  ITCTRL;                       /*!< (@ 0x00000F00) The ITCTRL register enables the component to
                                                                    switch from a functional mode, which is
                                                                    the default behavior,  to integration mode
                                                                    where the inputs and outputs of the component
                                                                    can be directly controlled for the purposes
                                                                    of integration testing and topology detection.             */
  __IM  uint32_t  RESERVED2[39];
  __IOM uint32_t  CLAIMSET;                     /*!< (@ 0x00000FA0) Software can use the claim tag to coordinate
                                                                    application and debugger access to trace
                                                                    unit functionality.  The claim tags have
                                                                    no effect on the operation of the component.
                                                                    The CLAIMSET register sets bits in the claim
                                                                    tag, and determines the number of claim
                                                                    bits implemented.                                          */
  __IOM uint32_t  CLAIMCLR;                     /*!< (@ 0x00000FA4) Software can use the claim tag to coordinate
                                                                    application and debugger access to trace
                                                                    unit functionality.  The claim tags have
                                                                    no effect on the operation of the component.
                                                                    The CLAIMCLR register sets the bits in the
                                                                    claim tag to 0 and determines the current
                                                                    value of the claim tag.                                    */
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  LAR;                          /*!< (@ 0x00000FB0) This is used to enable write access to device
                                                                    registers.                                                 */
  __IOM uint32_t  LSR;                          /*!< (@ 0x00000FB4) This indicates the status of the lock control
                                                                    mechanism. This lock prevents accidental
                                                                    writes by code under debug.  Accesses to
                                                                    the extended stimulus port registers are
                                                                    not affected by the lock mechanism.  This
                                                                    register must always be present although
                                                                    there might not be any lock access control
                                                                    mechanism.  The lock mechanism, where present
                                                                    and locked, must block write accesses to
                                                                    any control register, except the Lock Access
                                                                    Register.  For most components this cover                  */
  __IOM uint32_t  AUTHSTATUS;                   /*!< (@ 0x00000FB8) Indicates the current level of tracing permitted
                                                                    by the system                                              */
  __IM  uint32_t  RESERVED4[3];
  __IM  uint32_t  DEVID;
  __IM  uint32_t  DEVTYPE;                      /*!< (@ 0x00000FCC) The DEVTYPE register provides a debugger with
                                                                    information about the component when the
                                                                    Part Number field is not recognized. The
                                                                    debugger can then report this information.                 */
  __IOM uint32_t  PIDR4;
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  PIDR_0;
  __IOM uint32_t  PIDR_1;
  __IOM uint32_t  PIDR_2;
  __IOM uint32_t  PIDR_3;
  __IOM uint32_t  CIDR_0;
  __IOM uint32_t  CIDR_1;
  __IOM uint32_t  CIDR_2;
  __IOM uint32_t  CIDR_3;
} NRF_ATBFUNNEL_Type;



/* =========================================================================================================================== */
/* ================                                           TAD_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Trace and debug control (TAD_S)
  */

typedef struct {
  __OM  uint32_t  TASKS_CLOCKSTART;
  __OM  uint32_t  TASKS_CLOCKSTOP;
  __IM  uint32_t  RESERVED[318];
  __IOM uint32_t  ENABLE;
  __IOM TAD_PSEL_Type PSEL;
  __IOM uint32_t  TRACEPORTSPEED;               /*!< (@ 0x00000518) Clocking options for the Trace Port debug interface
                                                                    Reset behavior is the same as debug components             */
} NRF_TAD_Type;



/* =========================================================================================================================== */
/* ================                                           SPU_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief System protection unit (SPU_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[64];
  __IOM uint32_t  EVENTS_RAMACCERR;             /*!< (@ 0x00000100) A security violation has been detected for the
                                                                    RAM memory space                                           */
  __IOM uint32_t  EVENTS_FLASHACCERR;           /*!< (@ 0x00000104) A security violation has been detected for the
                                                                    flash memory space                                         */
  __IOM uint32_t  EVENTS_PERIPHACCERR;          /*!< (@ 0x00000108) A security violation has been detected on one
                                                                    or several peripherals                                     */
  __IM  uint32_t  RESERVED1[29];
  __IOM uint32_t  PUBLISH_RAMACCERR;
  __IOM uint32_t  PUBLISH_FLASHACCERR;
  __IOM uint32_t  PUBLISH_PERIPHACCERR;
  __IM  uint32_t  RESERVED2[93];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  CAP;
  __IM  uint32_t  RESERVED4[15];
  __IOM SPU_EXTDOMAIN_Type EXTDOMAIN[1];
  __IM  uint32_t  RESERVED5[15];
  __IOM SPU_DPPI_Type DPPI[1];
  __IM  uint32_t  RESERVED6[14];
  __IOM SPU_GPIOPORT_Type GPIOPORT[1];
  __IM  uint32_t  RESERVED7[14];
  __IOM SPU_FLASHNSC_Type FLASHNSC[2];
  __IM  uint32_t  RESERVED8[12];
  __IOM SPU_RAMNSC_Type RAMNSC[2];
  __IM  uint32_t  RESERVED9[44];
  __IOM SPU_FLASHREGION_Type FLASHREGION[32];
  __IM  uint32_t  RESERVED10[32];
  __IOM SPU_RAMREGION_Type RAMREGION[32];
  __IM  uint32_t  RESERVED11[32];
  __IOM SPU_PERIPHID_Type PERIPHID[67];
} NRF_SPU_Type;



/* =========================================================================================================================== */
/* ================                                       REGULATORS_NS                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief Voltage regulators control 0 (REGULATORS_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[320];
  __OM  uint32_t  SYSTEMOFF;
  __IM  uint32_t  RESERVED1[4];
  __IOM uint32_t  EXTPOFCON;
  __IM  uint32_t  RESERVED2[24];
  __IOM uint32_t  DCDCEN;
} NRF_REGULATORS_Type;



/* =========================================================================================================================== */
/* ================                                         CLOCK_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Clock management 0 (CLOCK_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_HFCLKSTART;
  __OM  uint32_t  TASKS_HFCLKSTOP;
  __OM  uint32_t  TASKS_LFCLKSTART;
  __OM  uint32_t  TASKS_LFCLKSTOP;
  __IM  uint32_t  RESERVED[28];
  __IOM uint32_t  SUBSCRIBE_HFCLKSTART;
  __IOM uint32_t  SUBSCRIBE_HFCLKSTOP;
  __IOM uint32_t  SUBSCRIBE_LFCLKSTART;
  __IOM uint32_t  SUBSCRIBE_LFCLKSTOP;
  __IM  uint32_t  RESERVED1[28];
  __IOM uint32_t  EVENTS_HFCLKSTARTED;
  __IOM uint32_t  EVENTS_LFCLKSTARTED;
  __IM  uint32_t  RESERVED2[30];
  __IOM uint32_t  PUBLISH_HFCLKSTARTED;
  __IOM uint32_t  PUBLISH_LFCLKSTARTED;
  __IM  uint32_t  RESERVED3[94];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  INTPEND;
  __IM  uint32_t  RESERVED4[62];
  __IM  uint32_t  HFCLKRUN;                     /*!< (@ 0x00000408) Status indicating that HFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  HFCLKSTAT;                    /*!< (@ 0x0000040C) The register shows if HFXO has been requested
                                                                    by triggering HFCLKSTART task and if it
                                                                    has been started (STATE).                                  */
  __IM  uint32_t  RESERVED5;
  __IM  uint32_t  LFCLKRUN;                     /*!< (@ 0x00000414) Status indicating that LFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  LFCLKSTAT;                    /*!< (@ 0x00000418) The register shows which LFCLK source has been
                                                                    requested (SRC) when triggering LFCLKSTART
                                                                    task and if the source has been started
                                                                    (STATE).                                                   */
  __IM  uint32_t  LFCLKSRCCOPY;                 /*!< (@ 0x0000041C) Copy of LFCLKSRC register, set after LFCLKSTART
                                                                    task has been triggered                                    */
  __IM  uint32_t  RESERVED6[62];
  __IOM uint32_t  LFCLKSRC;                     /*!< (@ 0x00000518) Clock source for the LFCLK. LFCLKSTART task starts
                                                                    a clock source selected with this register.                */
} NRF_CLOCK_Type;



/* =========================================================================================================================== */
/* ================                                         POWER_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Power control 0 (POWER_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[28];
  __OM  uint32_t  TASKS_PWMREQSTART;            /*!< (@ 0x00000070) Request forcing PWM mode in PMIC DC/DC buck regulator.
                                                                    (Drives FPWM_DCDC pin high or low depending
                                                                    on a setting in UICR).                                     */
  __OM  uint32_t  TASKS_PWMREQSTOP;             /*!< (@ 0x00000074) Stop requesting forcing PWM mode in PMIC DC/DC
                                                                    buck regulator                                             */
  __OM  uint32_t  TASKS_CONSTLAT;
  __OM  uint32_t  TASKS_LOWPWR;
  __IM  uint32_t  RESERVED1[28];
  __IOM uint32_t  SUBSCRIBE_PWMREQSTART;
  __IOM uint32_t  SUBSCRIBE_PWMREQSTOP;
  __IOM uint32_t  SUBSCRIBE_CONSTLAT;
  __IOM uint32_t  SUBSCRIBE_LOWPWR;
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  EVENTS_POFWARN;
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_SLEEPENTER;
  __IOM uint32_t  EVENTS_SLEEPEXIT;
  __IM  uint32_t  RESERVED4[27];
  __IOM uint32_t  PUBLISH_POFWARN;
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  PUBLISH_SLEEPENTER;
  __IOM uint32_t  PUBLISH_SLEEPEXIT;
  __IM  uint32_t  RESERVED6[89];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED7[61];
  __IOM uint32_t  RESETREAS;
  __IM  uint32_t  RESERVED8[15];
  __IM  uint32_t  POWERSTATUS;
  __IM  uint32_t  RESERVED9[54];
  __IOM uint32_t  GPREGRET[2];                  /*!< (@ 0x0000051C) Description collection: General purpose retention
                                                                    register                                                   */
  __IM  uint32_t  RESERVED10[59];
  __IOM POWER_LTEMODEM_Type LTEMODEM;
} NRF_POWER_Type;



/* =========================================================================================================================== */
/* ================                                      CTRL_AP_PERI_S                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief Control access port (CTRL_AP_PERI_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[256];
  __IOM CTRLAPPERI_MAILBOX_Type MAILBOX;
  __IM  uint32_t  RESERVED1[30];
  __IOM CTRLAPPERI_ERASEPROTECT_Type ERASEPROTECT;
} NRF_CTRLAPPERI_Type;



/* =========================================================================================================================== */
/* ================                                         SPIM0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial Peripheral Interface Master with EasyDMA 0 (SPIM0_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[4];
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;
  __OM  uint32_t  TASKS_RESUME;
  __IM  uint32_t  RESERVED2[27];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;
  __IOM uint32_t  SUBSCRIBE_RESUME;
  __IM  uint32_t  RESERVED4[24];
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  EVENTS_ENDRX;
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  EVENTS_END;
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  EVENTS_ENDTX;
  __IM  uint32_t  RESERVED8[10];
  __IOM uint32_t  EVENTS_STARTED;
  __IM  uint32_t  RESERVED9[13];
  __IOM uint32_t  PUBLISH_STOPPED;
  __IM  uint32_t  RESERVED10[2];
  __IOM uint32_t  PUBLISH_ENDRX;
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  PUBLISH_END;
  __IM  uint32_t  RESERVED12;
  __IOM uint32_t  PUBLISH_ENDTX;
  __IM  uint32_t  RESERVED13[10];
  __IOM uint32_t  PUBLISH_STARTED;
  __IM  uint32_t  RESERVED14[12];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED15[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED16[125];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED17;
  __IOM SPIM_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED18[4];
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED19[3];
  __IOM SPIM_RXD_Type RXD;
  __IOM SPIM_TXD_Type TXD;
  __IOM uint32_t  CONFIG;
  __IM  uint32_t  RESERVED20[26];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character. Character clocked out in
                                                                    case an over-read of the TXD buffer.                       */
} NRF_SPIM_Type;



/* =========================================================================================================================== */
/* ================                                         SPIS0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Slave 0 (SPIS0_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[9];
  __OM  uint32_t  TASKS_ACQUIRE;
  __OM  uint32_t  TASKS_RELEASE;                /*!< (@ 0x00000028) Release SPI semaphore, enabling the SPI slave
                                                                    to acquire it                                              */
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  SUBSCRIBE_ACQUIRE;
  __IOM uint32_t  SUBSCRIBE_RELEASE;
  __IM  uint32_t  RESERVED2[22];
  __IOM uint32_t  EVENTS_END;
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_ENDRX;
  __IM  uint32_t  RESERVED4[5];
  __IOM uint32_t  EVENTS_ACQUIRED;
  __IM  uint32_t  RESERVED5[22];
  __IOM uint32_t  PUBLISH_END;
  __IM  uint32_t  RESERVED6[2];
  __IOM uint32_t  PUBLISH_ENDRX;
  __IM  uint32_t  RESERVED7[5];
  __IOM uint32_t  PUBLISH_ACQUIRED;
  __IM  uint32_t  RESERVED8[21];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED9[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED10[61];
  __IM  uint32_t  SEMSTAT;
  __IM  uint32_t  RESERVED11[15];
  __IOM uint32_t  STATUS;
  __IM  uint32_t  RESERVED12[47];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED13;
  __IOM SPIS_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED14[7];
  __IOM SPIS_RXD_Type RXD;
  __IOM SPIS_TXD_Type TXD;
  __IOM uint32_t  CONFIG;
  __IM  uint32_t  RESERVED15;
  __IOM uint32_t  DEF;                          /*!< (@ 0x0000055C) Default character. Character clocked out in case
                                                                    of an ignored transaction.                                 */
  __IM  uint32_t  RESERVED16[24];
  __IOM uint32_t  ORC;
} NRF_SPIS_Type;



/* =========================================================================================================================== */
/* ================                                         TWIM0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Master Interface with EasyDMA 0 (TWIM0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_STARTRX;
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTTX;
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction. Must be issued while the
                                                                    TWI master is not suspended.                               */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  TASKS_SUSPEND;
  __OM  uint32_t  TASKS_RESUME;
  __IM  uint32_t  RESERVED3[23];
  __IOM uint32_t  SUBSCRIBE_STARTRX;
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  SUBSCRIBE_STARTTX;
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;
  __IOM uint32_t  SUBSCRIBE_RESUME;
  __IM  uint32_t  RESERVED7[24];
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED8[7];
  __IOM uint32_t  EVENTS_ERROR;
  __IM  uint32_t  RESERVED9[8];
  __IOM uint32_t  EVENTS_SUSPENDED;             /*!< (@ 0x00000148) SUSPEND task has been issued, TWI traffic is
                                                                    now suspended.                                             */
  __IOM uint32_t  EVENTS_RXSTARTED;
  __IOM uint32_t  EVENTS_TXSTARTED;
  __IM  uint32_t  RESERVED10[2];
  __IOM uint32_t  EVENTS_LASTRX;
  __IOM uint32_t  EVENTS_LASTTX;                /*!< (@ 0x00000160) Byte boundary, starting to transmit the last
                                                                    byte                                                       */
  __IM  uint32_t  RESERVED11[8];
  __IOM uint32_t  PUBLISH_STOPPED;
  __IM  uint32_t  RESERVED12[7];
  __IOM uint32_t  PUBLISH_ERROR;
  __IM  uint32_t  RESERVED13[8];
  __IOM uint32_t  PUBLISH_SUSPENDED;
  __IOM uint32_t  PUBLISH_RXSTARTED;
  __IOM uint32_t  PUBLISH_TXSTARTED;
  __IM  uint32_t  RESERVED14[2];
  __IOM uint32_t  PUBLISH_LASTRX;
  __IOM uint32_t  PUBLISH_LASTTX;
  __IM  uint32_t  RESERVED15[7];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED16[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED17[110];
  __IOM uint32_t  ERRORSRC;
  __IM  uint32_t  RESERVED18[14];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED19;
  __IOM TWIM_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED20[5];
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED21[3];
  __IOM TWIM_RXD_Type RXD;
  __IOM TWIM_TXD_Type TXD;
  __IM  uint32_t  RESERVED22[13];
  __IOM uint32_t  ADDRESS;
} NRF_TWIM_Type;



/* =========================================================================================================================== */
/* ================                                         TWIS0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Slave Interface with EasyDMA 0 (TWIS0_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[5];
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;
  __OM  uint32_t  TASKS_RESUME;
  __IM  uint32_t  RESERVED2[3];
  __OM  uint32_t  TASKS_PREPARERX;
  __OM  uint32_t  TASKS_PREPARETX;
  __IM  uint32_t  RESERVED3[23];
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;
  __IOM uint32_t  SUBSCRIBE_RESUME;
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  SUBSCRIBE_PREPARERX;
  __IOM uint32_t  SUBSCRIBE_PREPARETX;
  __IM  uint32_t  RESERVED6[19];
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED7[7];
  __IOM uint32_t  EVENTS_ERROR;
  __IM  uint32_t  RESERVED8[9];
  __IOM uint32_t  EVENTS_RXSTARTED;
  __IOM uint32_t  EVENTS_TXSTARTED;
  __IM  uint32_t  RESERVED9[4];
  __IOM uint32_t  EVENTS_WRITE;
  __IOM uint32_t  EVENTS_READ;
  __IM  uint32_t  RESERVED10[6];
  __IOM uint32_t  PUBLISH_STOPPED;
  __IM  uint32_t  RESERVED11[7];
  __IOM uint32_t  PUBLISH_ERROR;
  __IM  uint32_t  RESERVED12[9];
  __IOM uint32_t  PUBLISH_RXSTARTED;
  __IOM uint32_t  PUBLISH_TXSTARTED;
  __IM  uint32_t  RESERVED13[4];
  __IOM uint32_t  PUBLISH_WRITE;
  __IOM uint32_t  PUBLISH_READ;
  __IM  uint32_t  RESERVED14[5];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED15[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED16[113];
  __IOM uint32_t  ERRORSRC;
  __IM  uint32_t  MATCH;                        /*!< (@ 0x000004D4) Status register indicating which address had
                                                                    a match                                                    */
  __IM  uint32_t  RESERVED17[10];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED18;
  __IOM TWIS_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED19[9];
  __IOM TWIS_RXD_Type RXD;
  __IOM TWIS_TXD_Type TXD;
  __IM  uint32_t  RESERVED20[13];
  __IOM uint32_t  ADDRESS[2];
  __IM  uint32_t  RESERVED21;
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000594) Configuration register for the address match
                                                                    mechanism                                                  */
  __IM  uint32_t  RESERVED22[10];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character. Character sent out in case
                                                                    of an over-read of the transmit buffer.                    */
} NRF_TWIS_Type;



/* =========================================================================================================================== */
/* ================                                         UARTE0_NS                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief UART with EasyDMA 0 (UARTE0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_STARTRX;
  __OM  uint32_t  TASKS_STOPRX;
  __OM  uint32_t  TASKS_STARTTX;
  __OM  uint32_t  TASKS_STOPTX;
  __IM  uint32_t  RESERVED[7];
  __OM  uint32_t  TASKS_FLUSHRX;
  __IM  uint32_t  RESERVED1[20];
  __IOM uint32_t  SUBSCRIBE_STARTRX;
  __IOM uint32_t  SUBSCRIBE_STOPRX;
  __IOM uint32_t  SUBSCRIBE_STARTTX;
  __IOM uint32_t  SUBSCRIBE_STOPTX;
  __IM  uint32_t  RESERVED2[7];
  __IOM uint32_t  SUBSCRIBE_FLUSHRX;
  __IM  uint32_t  RESERVED3[20];
  __IOM uint32_t  EVENTS_CTS;
  __IOM uint32_t  EVENTS_NCTS;
  __IOM uint32_t  EVENTS_RXDRDY;                /*!< (@ 0x00000108) Data received in RXD (but potentially not yet
                                                                    transferred to Data RAM)                                   */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  EVENTS_ENDRX;
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  EVENTS_TXDRDY;
  __IOM uint32_t  EVENTS_ENDTX;
  __IOM uint32_t  EVENTS_ERROR;
  __IM  uint32_t  RESERVED6[7];
  __IOM uint32_t  EVENTS_RXTO;
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  EVENTS_RXSTARTED;
  __IOM uint32_t  EVENTS_TXSTARTED;
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  EVENTS_TXSTOPPED;
  __IM  uint32_t  RESERVED9[9];
  __IOM uint32_t  PUBLISH_CTS;
  __IOM uint32_t  PUBLISH_NCTS;
  __IOM uint32_t  PUBLISH_RXDRDY;
  __IM  uint32_t  RESERVED10;
  __IOM uint32_t  PUBLISH_ENDRX;
  __IM  uint32_t  RESERVED11[2];
  __IOM uint32_t  PUBLISH_TXDRDY;
  __IOM uint32_t  PUBLISH_ENDTX;
  __IOM uint32_t  PUBLISH_ERROR;
  __IM  uint32_t  RESERVED12[7];
  __IOM uint32_t  PUBLISH_RXTO;
  __IM  uint32_t  RESERVED13;
  __IOM uint32_t  PUBLISH_RXSTARTED;
  __IOM uint32_t  PUBLISH_TXSTARTED;
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  PUBLISH_TXSTOPPED;
  __IM  uint32_t  RESERVED15[9];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED16[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED17[93];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x00000480) Error source This register is read/write one
                                                                    to clear.                                                  */
  __IM  uint32_t  RESERVED18[31];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED19;
  __IOM UARTE_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED20[3];
  __IOM uint32_t  BAUDRATE;                     /*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
                                                                    selected.                                                  */
  __IM  uint32_t  RESERVED21[3];
  __IOM UARTE_RXD_Type RXD;
  __IM  uint32_t  RESERVED22;
  __IOM UARTE_TXD_Type TXD;
  __IM  uint32_t  RESERVED23[7];
  __IOM uint32_t  CONFIG;
} NRF_UARTE_Type;



/* =========================================================================================================================== */
/* ================                                         GPIOTE0_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Tasks and Events 0 (GPIOTE0_S)
  */

typedef struct {
  __OM  uint32_t  TASKS_OUT[8];                 /*!< (@ 0x00000000) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is configured in CONFIG[n].POLARITY.                       */
  __IM  uint32_t  RESERVED[4];
  __OM  uint32_t  TASKS_SET[8];                 /*!< (@ 0x00000030) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is to set it high.                                         */
  __IM  uint32_t  RESERVED1[4];
  __OM  uint32_t  TASKS_CLR[8];                 /*!< (@ 0x00000060) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is to set it low.                                          */
  __IOM uint32_t  SUBSCRIBE_OUT[8];             /*!< (@ 0x00000080) Description collection: Subscribe configuration
                                                                    for task OUT[n]                                            */
  __IM  uint32_t  RESERVED2[4];
  __IOM uint32_t  SUBSCRIBE_SET[8];             /*!< (@ 0x000000B0) Description collection: Subscribe configuration
                                                                    for task SET[n]                                            */
  __IM  uint32_t  RESERVED3[4];
  __IOM uint32_t  SUBSCRIBE_CLR[8];             /*!< (@ 0x000000E0) Description collection: Subscribe configuration
                                                                    for task CLR[n]                                            */
  __IOM uint32_t  EVENTS_IN[8];                 /*!< (@ 0x00000100) Description collection: Event generated from
                                                                    pin specified in CONFIG[n].PSEL                            */
  __IM  uint32_t  RESERVED4[23];
  __IOM uint32_t  EVENTS_PORT;                  /*!< (@ 0x0000017C) Event generated from multiple input GPIO pins
                                                                    with SENSE mechanism enabled                               */
  __IOM uint32_t  PUBLISH_IN[8];                /*!< (@ 0x00000180) Description collection: Publish configuration
                                                                    for event IN[n]                                            */
  __IM  uint32_t  RESERVED5[23];
  __IOM uint32_t  PUBLISH_PORT;
  __IM  uint32_t  RESERVED6[65];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED7[129];
  __IOM uint32_t  CONFIG[8];                    /*!< (@ 0x00000510) Description collection: Configuration for OUT[n],
                                                                    SET[n], and CLR[n] tasks and IN[n] event                   */
} NRF_GPIOTE_Type;



/* =========================================================================================================================== */
/* ================                                         SAADC_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Analog to Digital Converter 0 (SAADC_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start the ADC and prepare the result buffer in
                                                                    RAM                                                        */
  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000004) Take one ADC sample, if scan is enabled all channels
                                                                    are sampled                                                */
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_CALIBRATEOFFSET;
  __IM  uint32_t  RESERVED[28];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_SAMPLE;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IOM uint32_t  SUBSCRIBE_CALIBRATEOFFSET;
  __IM  uint32_t  RESERVED1[28];
  __IOM uint32_t  EVENTS_STARTED;
  __IOM uint32_t  EVENTS_END;
  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x00000108) A conversion task has been completed. Depending
                                                                    on the mode, multiple conversions might
                                                                    be needed for a result to be transferred
                                                                    to RAM.                                                    */
  __IOM uint32_t  EVENTS_RESULTDONE;
  __IOM uint32_t  EVENTS_CALIBRATEDONE;
  __IOM uint32_t  EVENTS_STOPPED;
  __IOM SAADC_EVENTS_CH_Type EVENTS_CH[8];
  __IM  uint32_t  RESERVED2[10];
  __IOM uint32_t  PUBLISH_STARTED;
  __IOM uint32_t  PUBLISH_END;
  __IOM uint32_t  PUBLISH_DONE;
  __IOM uint32_t  PUBLISH_RESULTDONE;
  __IOM uint32_t  PUBLISH_CALIBRATEDONE;
  __IOM uint32_t  PUBLISH_STOPPED;
  __IOM SAADC_PUBLISH_CH_Type PUBLISH_CH[8];
  __IM  uint32_t  RESERVED3[74];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED4[61];
  __IM  uint32_t  STATUS;
  __IM  uint32_t  RESERVED5[63];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED6[3];
  __IOM SAADC_CH_Type CH[8];
  __IM  uint32_t  RESERVED7[24];
  __IOM uint32_t  RESOLUTION;
  __IOM uint32_t  OVERSAMPLE;                   /*!< (@ 0x000005F4) Oversampling configuration. OVERSAMPLE should
                                                                    not be combined with SCAN. The RESOLUTION
                                                                    is applied before averaging, thus for high
                                                                    OVERSAMPLE a higher RESOLUTION should be
                                                                    used.                                                      */
  __IOM uint32_t  SAMPLERATE;
  __IM  uint32_t  RESERVED8[12];
  __IOM SAADC_RESULT_Type RESULT;
} NRF_SAADC_Type;



/* =========================================================================================================================== */
/* ================                                         TIMER0_NS                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer/Counter 0 (TIMER0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_COUNT;
  __OM  uint32_t  TASKS_CLEAR;
  __OM  uint32_t  TASKS_SHUTDOWN;
  __IM  uint32_t  RESERVED[11];
  __OM  uint32_t  TASKS_CAPTURE[6];             /*!< (@ 0x00000040) Description collection: Capture Timer value to
                                                                    CC[n] register                                             */
  __IM  uint32_t  RESERVED1[10];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IOM uint32_t  SUBSCRIBE_COUNT;
  __IOM uint32_t  SUBSCRIBE_CLEAR;
  __IOM uint32_t  SUBSCRIBE_SHUTDOWN;           /*!< (@ 0x00000090) Deprecated register - Subscribe configuration
                                                                    for task SHUTDOWN                                          */
  __IM  uint32_t  RESERVED2[11];
  __IOM uint32_t  SUBSCRIBE_CAPTURE[6];         /*!< (@ 0x000000C0) Description collection: Subscribe configuration
                                                                    for task CAPTURE[n]                                        */
  __IM  uint32_t  RESERVED3[26];
  __IOM uint32_t  EVENTS_COMPARE[6];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED4[26];
  __IOM uint32_t  PUBLISH_COMPARE[6];           /*!< (@ 0x000001C0) Description collection: Publish configuration
                                                                    for event COMPARE[n]                                       */
  __IM  uint32_t  RESERVED5[10];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED6[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED7[126];
  __IOM uint32_t  MODE;
  __IOM uint32_t  BITMODE;
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  PRESCALER;
  __IOM uint32_t  ONESHOTEN[6];                 /*!< (@ 0x00000514) Description collection: Enable one-shot operation
                                                                    for Capture/Compare channel n                              */
  __IM  uint32_t  RESERVED9[5];
  __IOM uint32_t  CC[6];                        /*!< (@ 0x00000540) Description collection: Capture/Compare register
                                                                    n                                                          */
} NRF_TIMER_Type;



/* =========================================================================================================================== */
/* ================                                          RTC0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Real-time counter 0 (RTC0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_CLEAR;
  __OM  uint32_t  TASKS_TRIGOVRFLW;
  __IM  uint32_t  RESERVED[28];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IOM uint32_t  SUBSCRIBE_CLEAR;
  __IOM uint32_t  SUBSCRIBE_TRIGOVRFLW;
  __IM  uint32_t  RESERVED1[28];
  __IOM uint32_t  EVENTS_TICK;
  __IOM uint32_t  EVENTS_OVRFLW;
  __IM  uint32_t  RESERVED2[14];
  __IOM uint32_t  EVENTS_COMPARE[4];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED3[12];
  __IOM uint32_t  PUBLISH_TICK;
  __IOM uint32_t  PUBLISH_OVRFLW;
  __IM  uint32_t  RESERVED4[14];
  __IOM uint32_t  PUBLISH_COMPARE[4];           /*!< (@ 0x000001C0) Description collection: Publish configuration
                                                                    for event COMPARE[n]                                       */
  __IM  uint32_t  RESERVED5[77];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED6[13];
  __IOM uint32_t  EVTEN;
  __IOM uint32_t  EVTENSET;
  __IOM uint32_t  EVTENCLR;
  __IM  uint32_t  RESERVED7[110];
  __IM  uint32_t  COUNTER;
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000508) 12-bit prescaler for counter frequency (32768/(PRESCALER+1)).
                                                                    Must be written when RTC is stopped.                       */
  __IM  uint32_t  RESERVED8[13];
  __IOM uint32_t  CC[4];
} NRF_RTC_Type;



/* =========================================================================================================================== */
/* ================                                         DPPIC_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Distributed programmable peripheral interconnect controller 0 (DPPIC_NS)
  */

typedef struct {
  __OM  DPPIC_TASKS_CHG_Type TASKS_CHG[6];
  __IM  uint32_t  RESERVED[20];
  __IOM DPPIC_SUBSCRIBE_CHG_Type SUBSCRIBE_CHG[6];
  __IM  uint32_t  RESERVED1[276];
  __IOM uint32_t  CHEN;
  __IOM uint32_t  CHENSET;
  __IOM uint32_t  CHENCLR;
  __IM  uint32_t  RESERVED2[189];
  __IOM uint32_t  CHG[6];                       /*!< (@ 0x00000800) Description collection: Channel group n Note:
                                                                    Writes to this register are ignored if either
                                                                    SUBSCRIBE_CHG[n].EN or SUBSCRIBE_CHG[n].DIS
                                                                    is enabled                                                 */
} NRF_DPPIC_Type;



/* =========================================================================================================================== */
/* ================                                          WDT_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Watchdog Timer 0 (WDT_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __IM  uint32_t  RESERVED[31];
  __IOM uint32_t  SUBSCRIBE_START;
  __IM  uint32_t  RESERVED1[31];
  __IOM uint32_t  EVENTS_TIMEOUT;
  __IM  uint32_t  RESERVED2[31];
  __IOM uint32_t  PUBLISH_TIMEOUT;
  __IM  uint32_t  RESERVED3[96];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED4[61];
  __IM  uint32_t  RUNSTATUS;
  __IM  uint32_t  REQSTATUS;
  __IM  uint32_t  RESERVED5[63];
  __IOM uint32_t  CRV;
  __IOM uint32_t  RREN;
  __IOM uint32_t  CONFIG;
  __IM  uint32_t  RESERVED6[60];
  __OM  uint32_t  RR[8];
} NRF_WDT_Type;



/* =========================================================================================================================== */
/* ================                                          EGU0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Event generator unit 0 (EGU0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_TRIGGER[16];            /*!< (@ 0x00000000) Description collection: Trigger n for triggering
                                                                    the corresponding TRIGGERED[n] event                       */
  __IM  uint32_t  RESERVED[16];
  __IOM uint32_t  SUBSCRIBE_TRIGGER[16];        /*!< (@ 0x00000080) Description collection: Subscribe configuration
                                                                    for task TRIGGER[n]                                        */
  __IM  uint32_t  RESERVED1[16];
  __IOM uint32_t  EVENTS_TRIGGERED[16];         /*!< (@ 0x00000100) Description collection: Event number n generated
                                                                    by triggering the corresponding TRIGGER[n]
                                                                    task                                                       */
  __IM  uint32_t  RESERVED2[16];
  __IOM uint32_t  PUBLISH_TRIGGERED[16];        /*!< (@ 0x00000180) Description collection: Publish configuration
                                                                    for event TRIGGERED[n]                                     */
  __IM  uint32_t  RESERVED3[80];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
} NRF_EGU_Type;



/* =========================================================================================================================== */
/* ================                                          PWM0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse width modulation unit 0 (PWM0_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops PWM pulse generation on all channels at
                                                                    the end of current PWM period, and stops
                                                                    sequence playback                                          */
  __OM  uint32_t  TASKS_SEQSTART[2];            /*!< (@ 0x00000008) Description collection: Loads the first PWM value
                                                                    on all enabled channels from sequence n,
                                                                    and starts playing that sequence at the
                                                                    rate defined in SEQ[n]REFRESH and/or DECODER.MODE.
                                                                    Causes PWM generation to start if not running.             */
  __OM  uint32_t  TASKS_NEXTSTEP;               /*!< (@ 0x00000010) Steps by one value in the current sequence on
                                                                    all enabled channels if DECODER.MODE=NextStep.
                                                                    Does not cause PWM generation to start if
                                                                    not running.                                               */
  __IM  uint32_t  RESERVED1[28];
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IOM uint32_t  SUBSCRIBE_SEQSTART[2];        /*!< (@ 0x00000088) Description collection: Subscribe configuration
                                                                    for task SEQSTART[n]                                       */
  __IOM uint32_t  SUBSCRIBE_NEXTSTEP;
  __IM  uint32_t  RESERVED2[28];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) Response to STOP task, emitted when PWM pulses
                                                                    are no longer generated                                    */
  __IOM uint32_t  EVENTS_SEQSTARTED[2];         /*!< (@ 0x00000108) Description collection: First PWM period started
                                                                    on sequence n                                              */
  __IOM uint32_t  EVENTS_SEQEND[2];             /*!< (@ 0x00000110) Description collection: Emitted at end of every
                                                                    sequence n, when last value from RAM has
                                                                    been applied to wave counter                               */
  __IOM uint32_t  EVENTS_PWMPERIODEND;
  __IOM uint32_t  EVENTS_LOOPSDONE;             /*!< (@ 0x0000011C) Concatenated sequences have been played the amount
                                                                    of times defined in LOOP.CNT                               */
  __IM  uint32_t  RESERVED3[25];
  __IOM uint32_t  PUBLISH_STOPPED;
  __IOM uint32_t  PUBLISH_SEQSTARTED[2];        /*!< (@ 0x00000188) Description collection: Publish configuration
                                                                    for event SEQSTARTED[n]                                    */
  __IOM uint32_t  PUBLISH_SEQEND[2];            /*!< (@ 0x00000190) Description collection: Publish configuration
                                                                    for event SEQEND[n]                                        */
  __IOM uint32_t  PUBLISH_PWMPERIODEND;
  __IOM uint32_t  PUBLISH_LOOPSDONE;
  __IM  uint32_t  RESERVED4[24];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED5[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED6[125];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  MODE;
  __IOM uint32_t  COUNTERTOP;                   /*!< (@ 0x00000508) Value up to which the pulse generator counter
                                                                    counts                                                     */
  __IOM uint32_t  PRESCALER;
  __IOM uint32_t  DECODER;
  __IOM uint32_t  LOOP;
  __IM  uint32_t  RESERVED7[2];
  __IOM PWM_SEQ_Type SEQ[2];
  __IOM PWM_PSEL_Type PSEL;
} NRF_PWM_Type;



/* =========================================================================================================================== */
/* ================                                          PDM_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse Density Modulation (Digital Microphone) Interface 0 (PDM_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  EVENTS_STARTED;
  __IOM uint32_t  EVENTS_STOPPED;
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000108) The PDM has written the last sample specified
                                                                    by SAMPLE.MAXCNT (or the last sample after
                                                                    a STOP task has been received) to Data RAM                 */
  __IM  uint32_t  RESERVED2[29];
  __IOM uint32_t  PUBLISH_STARTED;
  __IOM uint32_t  PUBLISH_STOPPED;
  __IOM uint32_t  PUBLISH_END;
  __IM  uint32_t  RESERVED3[93];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED4[125];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  PDMCLKCTRL;
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000508) Defines the routing of the connected PDM microphones'
                                                                    signals                                                    */
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  GAINL;
  __IOM uint32_t  GAINR;
  __IOM uint32_t  RATIO;                        /*!< (@ 0x00000520) Selects the ratio between PDM_CLK and output
                                                                    sample rate. Change PDMCLKCTRL accordingly.                */
  __IM  uint32_t  RESERVED6[7];
  __IOM PDM_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED7[6];
  __IOM PDM_SAMPLE_Type SAMPLE;
} NRF_PDM_Type;



/* =========================================================================================================================== */
/* ================                                          I2S_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Inter-IC Sound 0 (I2S_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts continuous I2S transfer. Also starts MCK
                                                                    generator when this is enabled.                            */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops I2S transfer. Also stops MCK generator.
                                                                    Triggering this task will cause the STOPPED
                                                                    event to be generated.                                     */
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IM  uint32_t  RESERVED1[31];
  __IOM uint32_t  EVENTS_RXPTRUPD;              /*!< (@ 0x00000104) The RXD.PTR register has been copied to internal
                                                                    double-buffers. When the I2S module is started
                                                                    and RX is enabled, this event will be generated
                                                                    for every RXTXD.MAXCNT words that are received
                                                                    on the SDIN pin.                                           */
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  EVENTS_TXPTRUPD;              /*!< (@ 0x00000114) The TDX.PTR register has been copied to internal
                                                                    double-buffers. When the I2S module is started
                                                                    and TX is enabled, this event will be generated
                                                                    for every RXTXD.MAXCNT words that are sent
                                                                    on the SDOUT pin.                                          */
  __IM  uint32_t  RESERVED3[27];
  __IOM uint32_t  PUBLISH_RXPTRUPD;
  __IOM uint32_t  PUBLISH_STOPPED;
  __IM  uint32_t  RESERVED4[2];
  __IOM uint32_t  PUBLISH_TXPTRUPD;
  __IM  uint32_t  RESERVED5[90];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED6[125];
  __IOM uint32_t  ENABLE;
  __IOM I2S_CONFIG_Type CONFIG;
  __IM  uint32_t  RESERVED7[3];
  __IOM I2S_RXD_Type RXD;
  __IM  uint32_t  RESERVED8;
  __IOM I2S_TXD_Type TXD;
  __IM  uint32_t  RESERVED9[3];
  __IOM I2S_RXTXD_Type RXTXD;
  __IM  uint32_t  RESERVED10[3];
  __IOM I2S_PSEL_Type PSEL;
} NRF_I2S_Type;



/* =========================================================================================================================== */
/* ================                                          IPC_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Interprocessor communication 0 (IPC_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_SEND[8];                /*!< (@ 0x00000000) Description collection: Trigger events on IPC
                                                                    channel enabled in SEND_CNF[n]                             */
  __IM  uint32_t  RESERVED[24];
  __IOM uint32_t  SUBSCRIBE_SEND[8];            /*!< (@ 0x00000080) Description collection: Subscribe configuration
                                                                    for task SEND[n]                                           */
  __IM  uint32_t  RESERVED1[24];
  __IOM uint32_t  EVENTS_RECEIVE[8];            /*!< (@ 0x00000100) Description collection: Event received on one
                                                                    or more of the enabled IPC channels in RECEIVE_CNF[n]      */
  __IM  uint32_t  RESERVED2[24];
  __IOM uint32_t  PUBLISH_RECEIVE[8];           /*!< (@ 0x00000180) Description collection: Publish configuration
                                                                    for event RECEIVE[n]                                       */
  __IM  uint32_t  RESERVED3[88];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  INTPEND;
  __IM  uint32_t  RESERVED4[128];
  __IOM uint32_t  SEND_CNF[8];                  /*!< (@ 0x00000510) Description collection: Send event configuration
                                                                    for TASKS_SEND[n]                                          */
  __IM  uint32_t  RESERVED5[24];
  __IOM uint32_t  RECEIVE_CNF[8];               /*!< (@ 0x00000590) Description collection: Receive event configuration
                                                                    for EVENTS_RECEIVE[n]                                      */
  __IM  uint32_t  RESERVED6[24];
  __IOM uint32_t  GPMEM[4];
} NRF_IPC_Type;



/* =========================================================================================================================== */
/* ================                                          FPU_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief FPU (FPU_NS)
  */

typedef struct {
  __IM  uint32_t  UNUSED;
} NRF_FPU_Type;



/* =========================================================================================================================== */
/* ================                                       APPROTECT_NS                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief Access Port Protection 0 (APPROTECT_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[896];
  __IOM APPROTECT_SECUREAPPROTECT_Type SECUREAPPROTECT;
  __IM  uint32_t  RESERVED1[3];
  __IOM APPROTECT_APPROTECT_Type APPROTECT;
} NRF_APPROTECT_Type;



/* =========================================================================================================================== */
/* ================                                          KMU_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Key management unit 0 (KMU_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_PUSH_KEYSLOT;
  __IM  uint32_t  RESERVED[63];
  __IOM uint32_t  EVENTS_KEYSLOT_PUSHED;
  __IOM uint32_t  EVENTS_KEYSLOT_REVOKED;       /*!< (@ 0x00000104) Key slot has been revoked and cannot be tasked
                                                                    for selection                                              */
  __IOM uint32_t  EVENTS_KEYSLOT_ERROR;         /*!< (@ 0x00000108) No key slot selected, no destination address
                                                                    defined, or error during push operation                    */
  __IM  uint32_t  RESERVED1[125];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  INTPEND;
  __IM  uint32_t  RESERVED2[63];
  __IM  uint32_t  STATUS;
  __IM  uint32_t  RESERVED3[60];
  __IOM uint32_t  SELECTKEYSLOT;                /*!< (@ 0x00000500) Select key slot to be read over AHB or pushed
                                                                    over secure APB when TASKS_PUSH_KEYSLOT
                                                                    is started                                                 */
} NRF_KMU_Type;



/* =========================================================================================================================== */
/* ================                                          NVMC_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Non-volatile memory controller 0 (NVMC_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[256];
  __IM  uint32_t  READY;
  __IM  uint32_t  RESERVED1;
  __IM  uint32_t  READYNEXT;
  __IM  uint32_t  RESERVED2[62];
  __IOM uint32_t  CONFIG;
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  ERASEALL;
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  ERASEPAGEPARTIALCFG;
  __IM  uint32_t  RESERVED5[8];
  __IOM uint32_t  ICACHECNF;
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  IHIT;
  __IOM uint32_t  IMISS;
  __IM  uint32_t  RESERVED7[13];
  __IOM uint32_t  CONFIGNS;
  __OM  uint32_t  WRITEUICRNS;
} NRF_NVMC_Type;



/* =========================================================================================================================== */
/* ================                                          VMC_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Volatile Memory controller 0 (VMC_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[384];
  __IOM VMC_RAM_Type RAM[8];
} NRF_VMC_Type;



/* =========================================================================================================================== */
/* ================                                       CRYPTOCELL_S                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL register interface (CRYPTOCELL_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[320];
  __IOM uint32_t  ENABLE;
} NRF_CRYPTOCELL_Type;



/* =========================================================================================================================== */
/* ================                                         CC_AES_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL AES engine (CC_AES_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[256];
  __OM  uint32_t  AES_KEY_0[8];                 /*!< (@ 0x00000400) Description collection: AES key value to use.
                                                                    The initial AES_KEY_0[0] register holds
                                                                    the least significant bits [31:0] of the
                                                                    key value.                                                 */
  __IM  uint32_t  RESERVED1[8];
  __IOM uint32_t  AES_IV_0[4];                  /*!< (@ 0x00000440) Description collection: AES Initialization Vector
                                                                    (IV) to use. The initial AES_IV_0[0] register
                                                                    holds the least significant bits [31:0]
                                                                    of the IV.                                                 */
  __IM  uint32_t  RESERVED2[4];
  __IOM uint32_t  AES_CTR[4];                   /*!< (@ 0x00000460) Description collection: AES counter (CTR) to
                                                                    use. The initial AES_CTR[0] register holds
                                                                    the least significant bits [31:0] of the
                                                                    CTR.                                                       */
  __IM  uint32_t  AES_BUSY;
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  AES_SK;                       /*!< (@ 0x00000478) Writing to this address trigger sampling of the
                                                                    HW key to the AES_KEY_0 register                           */
  __OM  uint32_t  AES_CMAC_INIT;                /*!< (@ 0x0000047C) Writing to this address triggers the AES engine
                                                                    to generate K1 and K2 for AES-CMAC operations.             */
  __IM  uint32_t  RESERVED4[15];
  __IOM uint32_t  AES_REMAINING_BYTES;          /*!< (@ 0x000004BC) This register should be set with the amount of
                                                                    remaining bytes until the end of the current
                                                                    AES operation.                                             */
  __IOM uint32_t  AES_CONTROL;
  __IM  uint32_t  RESERVED5;
  __IM  uint32_t  AES_HW_FLAGS;                 /*!< (@ 0x000004C8) Hardware configuration of the AES engine. Reset
                                                                    value holds the supported features.                        */
  __IM  uint32_t  RESERVED6[3];
  __IOM uint32_t  AES_CTR_NO_INCREMENT;         /*!< (@ 0x000004D8) This register enables the AES CTR no increment
                                                                    mode in which the counter mode is not incremented
                                                                    between two blocks                                         */
  __IM  uint32_t  RESERVED7[6];
  __OM  uint32_t  AES_SW_RESET;
  __IM  uint32_t  RESERVED8[11];
  __OM  uint32_t  AES_CMAC_SIZE0_KICK;          /*!< (@ 0x00000524) Writing to this address triggers the AES engine
                                                                    to perform a CMAC operation with size 0.
                                                                    The CMAC result can be read from the AES_IV_0
                                                                    register.                                                  */
} NRF_CC_AES_Type;



/* =========================================================================================================================== */
/* ================                                         CC_AHB_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL AHB interface (CC_AHB_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[704];
  __IOM uint32_t  AHBM_SINGLES;                 /*!< (@ 0x00000B00) This register forces the AHB transactions from
                                                                    CRYPTOCELL master to be always singles.                    */
  __IOM uint32_t  AHBM_HPROT;
  __IOM uint32_t  AHBM_HMASTLOCK;
  __IOM uint32_t  AHBM_HNONSEC;
} NRF_CC_AHB_Type;



/* =========================================================================================================================== */
/* ================                                        CC_CHACHA_S                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL CHACHA engine (CC_CHACHA_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[224];
  __IOM uint32_t  CHACHA_CONTROL;
  __IM  uint32_t  CHACHA_VERSION;
  __OM  uint32_t  CHACHA_KEY[8];                /*!< (@ 0x00000388) Description collection: CHACHA key value to use.
                                                                    The initial CHACHA_KEY[0] register holds
                                                                    the least significant bits [31:0] of the
                                                                    key value.                                                 */
  __IOM uint32_t  CHACHA_IV[2];                 /*!< (@ 0x000003A8) Description collection: CHACHA Initialization
                                                                    Vector (IV) to use. The IV is also known
                                                                    as the nonce.                                              */
  __IM  uint32_t  CHACHA_BUSY;
  __IM  uint32_t  CHACHA_HW_FLAGS;              /*!< (@ 0x000003B4) Hardware configuration of the CHACHA engine.
                                                                    Reset value holds the supported features.                  */
  __IOM uint32_t  CHACHA_BLOCK_CNT_LSB;         /*!< (@ 0x000003B8) Store the LSB value of the block counter, in
                                                                    order to support suspend/resume of operation               */
  __IOM uint32_t  CHACHA_BLOCK_CNT_MSB;         /*!< (@ 0x000003BC) Store the MSB value of the block counter, in
                                                                    order to support suspend/resume of operation               */
  __OM  uint32_t  CHACHA_SW_RESET;
  __IM  uint32_t  CHACHA_POLY1305_KEY[8];       /*!< (@ 0x000003C4) Description collection: The auto-generated key
                                                                    to use in Poly1305 MAC calculation. The
                                                                    initial CHACHA_POLY1305_KEY[0] register
                                                                    holds the least significant bits [31:0]
                                                                    of the key value.                                          */
  __IOM uint32_t  CHACHA_ENDIANNESS;
  __IM  uint32_t  CHACHA_DEBUG;
} NRF_CC_CHACHA_Type;



/* =========================================================================================================================== */
/* ================                                         CC_CTL_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL CTL interface (CC_CTL_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[576];
  __OM  uint32_t  CRYPTO_CTL;
  __IM  uint32_t  RESERVED1[3];
  __IM  uint32_t  CRYPTO_BUSY;                  /*!< (@ 0x00000910) Status register for cryptographic cores engine
                                                                    activity.                                                  */
  __IM  uint32_t  RESERVED2[2];
  __IM  uint32_t  HASH_BUSY;
  __IM  uint32_t  RESERVED3[4];
  __IOM uint32_t  CONTEXT_ID;
} NRF_CC_CTL_Type;



/* =========================================================================================================================== */
/* ================                                         CC_DIN_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL Data IN interface (CC_DIN_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[768];
  __OM  uint32_t  DIN_BUFFER;                   /*!< (@ 0x00000C00) Used by CPU to write data directly to the DIN
                                                                    buffer, which is then sent to the cryptographic
                                                                    engines for processing.                                    */
  __IM  uint32_t  RESERVED1[7];
  __IM  uint32_t  DIN_DMA_MEM_BUSY;             /*!< (@ 0x00000C20) Status register for DIN DMA engine activity when
                                                                    accessing memory.                                          */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  SRC_MEM_ADDR;
  __OM  uint32_t  SRC_MEM_SIZE;                 /*!< (@ 0x00000C2C) The number of bytes to be read from memory. Writing
                                                                    to this register triggers the DMA operation.               */
  __IOM uint32_t  SRC_SRAM_ADDR;
  __OM  uint32_t  SRC_SRAM_SIZE;                /*!< (@ 0x00000C34) The number of bytes to be read from RNG SRAM.
                                                                    Writing to this register triggers the DMA
                                                                    operation.                                                 */
  __IM  uint32_t  DIN_DMA_SRAM_BUSY;            /*!< (@ 0x00000C38) Status register for DIN DMA engine activity when
                                                                    accessing RNG SRAM.                                        */
  __IOM uint32_t  DIN_DMA_SRAM_ENDIANNESS;      /*!< (@ 0x00000C3C) Configure the endianness of DIN DMA transactions
                                                                    towards RNG SRAM.                                          */
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  DIN_SW_RESET;
  __OM  uint32_t  DIN_CPU_DATA;                 /*!< (@ 0x00000C48) Specifies the number of bytes the CPU will write
                                                                    to the DIN_BUFFER, ensuring the cryptographic
                                                                    engine processes the correct amount of data.               */
  __OM  uint32_t  DIN_WRITE_ALIGN;              /*!< (@ 0x00000C4C) Indicates that the next CPU write to the DIN_BUFFER
                                                                    is the last in the sequence. This is needed
                                                                    only when the data size is NOT modulo 4
                                                                    (e.g. HASH padding).                                       */
  __IM  uint32_t  DIN_FIFO_EMPTY;               /*!< (@ 0x00000C50) Register indicating if DIN FIFO is empty and
                                                                    if more data can be accepted.                              */
  __IM  uint32_t  RESERVED4;
  __OM  uint32_t  DIN_FIFO_RESET;               /*!< (@ 0x00000C58) Reset the DIN FIFO, effectively clearing the
                                                                    FIFO for new data.                                         */
} NRF_CC_DIN_Type;



/* =========================================================================================================================== */
/* ================                                         CC_DOUT_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL Data OUT interface (CC_DOUT_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[768];
  __IM  uint32_t  DOUT_BUFFER;                  /*!< (@ 0x00000C00) Cryptographic results directly accessible by
                                                                    the CPU.                                                   */
  __IM  uint32_t  RESERVED1[71];
  __IM  uint32_t  DOUT_DMA_MEM_BUSY;            /*!< (@ 0x00000D20) Status register for DOUT DMA engine activity
                                                                    when accessing memory.                                     */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  DST_MEM_ADDR;
  __OM  uint32_t  DST_MEM_SIZE;
  __IOM uint32_t  DST_SRAM_ADDR;
  __OM  uint32_t  DST_SRAM_SIZE;
  __IM  uint32_t  DOUT_DMA_SRAM_BUSY;           /*!< (@ 0x00000D38) Status register for DOUT DMA engine activity
                                                                    when accessing RNG SRAM.                                   */
  __IOM uint32_t  DOUT_DMA_SRAM_ENDIANNESS;     /*!< (@ 0x00000D3C) Configure the endianness of DOUT DMA transactions
                                                                    towards RNG SRAM.                                          */
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  DOUT_READ_ALIGN;              /*!< (@ 0x00000D44) Indication that the next CPU read from the DOUT_BUFFER
                                                                    is the last in the sequence. This is needed
                                                                    only when the data size is NOT modulo 4
                                                                    (e.g. HASH padding).                                       */
  __IM  uint32_t  RESERVED4[2];
  __IM  uint32_t  DOUT_FIFO_EMPTY;              /*!< (@ 0x00000D50) Register indicating if DOUT FIFO is empty or
                                                                    if more data will come.                                    */
  __IM  uint32_t  RESERVED5;
  __OM  uint32_t  DOUT_SW_RESET;
} NRF_CC_DOUT_Type;



/* =========================================================================================================================== */
/* ================                                         CC_HASH_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL HASH engine (CC_HASH_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[400];
  __IOM uint32_t  HASH_H[8];                    /*!< (@ 0x00000640) Description collection: HASH_H value registers.
                                                                    The initial HASH_H[0] register holds the
                                                                    least significant bits [31:0] of the value.                */
  __IM  uint32_t  RESERVED1[9];
  __OM  uint32_t  HASH_PAD_AUTO;                /*!< (@ 0x00000684) Configure the HASH engine to automatically pad
                                                                    data at the end of the DMA transfer to complete
                                                                    the digest operation.                                      */
  __IM  uint32_t  RESERVED2[3];
  __OM  uint32_t  HASH_INIT_STATE;
  __IM  uint32_t  RESERVED3[70];
  __IM  uint32_t  HASH_VERSION;
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  HASH_CONTROL;
  __IOM uint32_t  HASH_PAD;                     /*!< (@ 0x000007C4) Enable the hardware padding feature of the HASH
                                                                    engine.                                                    */
  __IOM uint32_t  HASH_PAD_FORCE;               /*!< (@ 0x000007C8) Force the hardware padding operation to trigger
                                                                    if the input data length is zero bytes.                    */
  __IOM uint32_t  HASH_CUR_LEN_0;               /*!< (@ 0x000007CC) Bits [31:0] of the number of bytes that have
                                                                    been digested so far.                                      */
  __IOM uint32_t  HASH_CUR_LEN_1;               /*!< (@ 0x000007D0) Bits [63:32] of the number of bytes that have
                                                                    been digested so far.                                      */
  __IM  uint32_t  RESERVED5[2];
  __IM  uint32_t  HASH_HW_FLAGS;                /*!< (@ 0x000007DC) Hardware configuration of the HASH engine. Reset
                                                                    value holds the supported features.                        */
  __IM  uint32_t  RESERVED6;
  __OM  uint32_t  HASH_SW_RESET;
  __IOM uint32_t  HASH_ENDIANNESS;              /*!< (@ 0x000007E8) Configure the endianness of HASH data and padding
                                                                    generation.                                                */
} NRF_CC_HASH_Type;



/* =========================================================================================================================== */
/* ================                                       CC_HOST_RGF_S                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL HOST register interface (CC_HOST_RGF_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[640];
  __IM  uint32_t  IRR;                          /*!< (@ 0x00000A00) Interrupt request register. Each bit of this
                                                                    register holds the interrupt status of a
                                                                    single interrupt source. If corresponding
                                                                    IMR bit is unmasked, an interrupt is generated.            */
  __IOM uint32_t  IMR;                          /*!< (@ 0x00000A04) Interrupt mask register. Each bit of this register
                                                                    holds the mask of a single interrupt source.               */
  __OM  uint32_t  ICR;                          /*!< (@ 0x00000A08) Interrupt clear register. Writing a 1 bit into
                                                                    a field in this register will clear the
                                                                    corresponding bit in IRR.                                  */
  __IOM uint32_t  ENDIANNESS;                   /*!< (@ 0x00000A0C) This register defines the endianness of the Host-accessible
                                                                    registers, and can only be written once.                   */
  __IM  uint32_t  RESERVED1[5];
  __IM  uint32_t  HOST_SIGNATURE;               /*!< (@ 0x00000A24) This register holds the CRYPTOCELL subsystem
                                                                    signature. See reset value.                                */
  __IM  uint32_t  HOST_BOOT;                    /*!< (@ 0x00000A28) Hardware configuration of the CRYPTOCELL subsystem.
                                                                    Reset value holds the supported features.                  */
  __IM  uint32_t  RESERVED2[3];
  __IOM uint32_t  HOST_CRYPTOKEY_SEL;
  __IM  uint32_t  RESERVED3[4];
  __IOM uint32_t  HOST_IOT_KPRTL_LOCK;          /*!< (@ 0x00000A4C) This write-once register is the K_PRTL lock register.
                                                                    When this register is set, K_PRTL cannot
                                                                    be used and a zeroed key will be used instead.
                                                                    The value of this register is saved in the
                                                                    CRYPTOCELL AO power domain.                                */
  __IOM uint32_t  HOST_IOT_KDR0;                /*!< (@ 0x00000A50) This register holds bits 31:0 of K_DR. The value
                                                                    of this register is saved in the CRYPTOCELL
                                                                    AO power domain. Reading from this address
                                                                    returns the K_DR valid status indicating
                                                                    if K_DR is successfully retained.                          */
  __OM  uint32_t  HOST_IOT_KDR1;                /*!< (@ 0x00000A54) This register holds bits 63:32 of K_DR. The value
                                                                    of this register is saved in the CRYPTOCELL
                                                                    AO power domain.                                           */
  __OM  uint32_t  HOST_IOT_KDR2;                /*!< (@ 0x00000A58) This register holds bits 95:64 of K_DR. The value
                                                                    of this register is saved in the CRYPTOCELL
                                                                    AO power domain.                                           */
  __OM  uint32_t  HOST_IOT_KDR3;                /*!< (@ 0x00000A5C) This register holds bits 127:96 of K_DR. The
                                                                    value of this register is saved in the CRYPTOCELL
                                                                    AO power domain.                                           */
  __IOM uint32_t  HOST_IOT_LCS;                 /*!< (@ 0x00000A60) Controls life-cycle state (LCS) for CRYPTOCELL
                                                                    subsystem                                                  */
} NRF_CC_HOST_RGF_Type;



/* =========================================================================================================================== */
/* ================                                         CC_MISC_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL MISC interface (CC_MISC_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[516];
  __OM  uint32_t  AES_CLK;
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  HASH_CLK;
  __OM  uint32_t  PKA_CLK;
  __OM  uint32_t  DMA_CLK;
  __IM  uint32_t  CLK_STATUS;
  __IM  uint32_t  RESERVED2[12];
  __OM  uint32_t  CHACHA_CLK;
} NRF_CC_MISC_Type;



/* =========================================================================================================================== */
/* ================                                         CC_PKA_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL PKA engine (CC_PKA_S)
  */

typedef struct {
  __IOM uint32_t  MEMORY_MAP[32];               /*!< (@ 0x00000000) Description collection: Register for mapping
                                                                    the virtual register R[n] to a physical
                                                                    address in the PKA SRAM.                                   */
  __IOM uint32_t  OPCODE;                       /*!< (@ 0x00000080) Operation code to be executed by the PKA engine.
                                                                    Writing to this register triggers the PKA
                                                                    operation.                                                 */
  __IOM uint32_t  N_NP_T0_T1_ADDR;              /*!< (@ 0x00000084) This register defines the N, Np, T0, and T1 virtual
                                                                    register index.                                            */
  __IM  uint32_t  PKA_STATUS;
  __OM  uint32_t  PKA_SW_RESET;
  __IOM uint32_t  PKA_L[8];                     /*!< (@ 0x00000090) Description collection: This register holds the
                                                                    operands bit size.                                         */
  __IM  uint32_t  PKA_PIPE;                     /*!< (@ 0x000000B0) Status register indicating if the PKA pipeline
                                                                    is ready to receive a new OPCODE.                          */
  __IM  uint32_t  PKA_DONE;                     /*!< (@ 0x000000B4) Status register indicating if the PKA operation
                                                                    has been completed.                                        */
  __IM  uint32_t  RESERVED[3];
  __IM  uint32_t  PKA_VERSION;                  /*!< (@ 0x000000C4) PKA engine HW version. Reset value holds the
                                                                    version.                                                   */
  __IM  uint32_t  RESERVED1[3];
  __OM  uint32_t  PKA_SRAM_WADDR;               /*!< (@ 0x000000D4) Start address in PKA SRAM for subsequent write
                                                                    transactions.                                              */
  __OM  uint32_t  PKA_SRAM_WDATA;               /*!< (@ 0x000000D8) Write data to PKA SRAM. Writing to this register
                                                                    triggers a DMA transaction writing data
                                                                    into PKA SRAM. The DMA address offset is
                                                                    automatically incremented during write.                    */
  __IM  uint32_t  PKA_SRAM_RDATA;               /*!< (@ 0x000000DC) Read data from PKA SRAM. Reading from this register
                                                                    triggers a DMA transaction read data from
                                                                    PKA SRAM. The DMA address offset is automatically
                                                                    incremented during read.                                   */
  __OM  uint32_t  PKA_SRAM_WCLEAR;
  __OM  uint32_t  PKA_SRAM_RADDR;               /*!< (@ 0x000000E4) Start address in PKA SRAM for subsequent read
                                                                    transactions.                                              */
} NRF_CC_PKA_Type;



/* =========================================================================================================================== */
/* ================                                         CC_RNG_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL RNG engine (CC_RNG_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[64];
  __IOM uint32_t  RNG_IMR;                      /*!< (@ 0x00000100) Interrupt mask register. Each bit of this register
                                                                    holds the mask of a single interrupt source.               */
  __IM  uint32_t  RNG_ISR;                      /*!< (@ 0x00000104) Interrupt status register. Each bit of this register
                                                                    holds the interrupt status of a single interrupt
                                                                    source. If corresponding RNG_IMR bit is
                                                                    unmasked, an interrupt is generated.                       */
  __OM  uint32_t  RNG_ICR;                      /*!< (@ 0x00000108) Interrupt clear register. Writing a 1 bit into
                                                                    a field in this register will clear the
                                                                    corresponding bit in RNG_ISR.                              */
  __IOM uint32_t  TRNG_CONFIG;
  __IM  uint32_t  TRNG_VALID;                   /*!< (@ 0x00000110) This register indicates if TRNG entropy collection
                                                                    is valid.                                                  */
  __IM  uint32_t  EHR_DATA[6];                  /*!< (@ 0x00000114) Description collection: The entropy holding registers
                                                                    (EHR) hold 192-bits random data collected
                                                                    by the TRNG. The initial EHR_DATA[0] register
                                                                    holds the least significant bits [31:0]
                                                                    of the random data value.                                  */
  __IOM uint32_t  NOISE_SOURCE;                 /*!< (@ 0x0000012C) This register controls the ring oscillator circuit
                                                                    used as a noise source.                                    */
  __IOM uint32_t  SAMPLE_CNT;                   /*!< (@ 0x00000130) Sample count defining the number of CPU clock
                                                                    cycles between two consecutive noise source
                                                                    samples.                                                   */
  __IOM uint32_t  AUTOCORR_STATISTIC;           /*!< (@ 0x00000134) Statistics counter for autocorrelation test activations.
                                                                    Statistics collection is stopped if one
                                                                    of the counters reach its limit of all ones.               */
  __IOM uint32_t  TRNG_DEBUG;                   /*!< (@ 0x00000138) Debug register for the TRNG. This register is
                                                                    used to bypass TRNG tests in hardware.                     */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  RNG_SW_RESET;
  __IM  uint32_t  RESERVED2[29];
  __IM  uint32_t  RNG_BUSY;
  __OM  uint32_t  TRNG_RESET;                   /*!< (@ 0x000001BC) Reset the TRNG, including internal counter of
                                                                    collected bits and registers EHR_DATA and
                                                                    TRNG_VALID.                                                */
  __IM  uint32_t  RNG_HW_FLAGS;                 /*!< (@ 0x000001C0) Hardware configuration of RNG engine. Reset value
                                                                    holds the supported features.                              */
  __OM  uint32_t  RNG_CLK;
  __IOM uint32_t  RNG_DMA;                      /*!< (@ 0x000001C8) Writing to this register enables the RNG DMA
                                                                    engine.                                                    */
  __IOM uint32_t  RNG_DMA_ROSC_LEN;             /*!< (@ 0x000001CC) This register defines which ring oscillator length
                                                                    configuration should be used when using
                                                                    the RNG DMA engine.                                        */
  __IOM uint32_t  RNG_DMA_SRAM_ADDR;            /*!< (@ 0x000001D0) This register defines the start address in TRNG
                                                                    SRAM for the TRNG data to be collected by
                                                                    the RNG DMA engine.                                        */
  __IOM uint32_t  RNG_DMA_SAMPLES_NUM;          /*!< (@ 0x000001D4) This register defines the number of 192-bits
                                                                    samples that the RNG DMA engine collects
                                                                    per run.                                                   */
  __IOM uint32_t  RNG_WATCHDOG_VAL;             /*!< (@ 0x000001D8) This register defines the maximum number of CPU
                                                                    clock cycles per TRNG collection of 192-bits
                                                                    samples. If the number of cycles for a collection
                                                                    exceeds this threshold the WATCHDOG interrupt
                                                                    is triggered.                                              */
  __IM  uint32_t  RNG_DMA_BUSY;
} NRF_CC_RNG_Type;



/* =========================================================================================================================== */
/* ================                                       CC_RNG_SRAM_S                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL RNG SRAM interface (CC_RNG_SRAM_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[960];
  __IOM uint32_t  SRAM_DATA;
  __OM  uint32_t  SRAM_ADDR;                    /*!< (@ 0x00000F04) First address given to RNG SRAM DMA for read/write
                                                                    transactions from/to RNG SRAM.                             */
  __IM  uint32_t  SRAM_DATA_READY;              /*!< (@ 0x00000F08) RNG SRAM DMA engine is ready to read/write from/to
                                                                    RNG SRAM.                                                  */
} NRF_CC_RNG_SRAM_Type;



/* =========================================================================================================================== */
/* ================                                           P0_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Port 0 (P0_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  OUT;
  __IOM uint32_t  OUTSET;
  __IOM uint32_t  OUTCLR;
  __IM  uint32_t  IN;
  __IOM uint32_t  DIR;
  __IOM uint32_t  DIRSET;
  __IOM uint32_t  DIRCLR;
  __IOM uint32_t  LATCH;                        /*!< (@ 0x00000020) Latch register indicating what GPIO pins that
                                                                    have met the criteria set in the PIN_CNF[n].SENSE
                                                                    registers                                                  */
  __IOM uint32_t  DETECTMODE;                   /*!< (@ 0x00000024) Select between default DETECT signal behavior
                                                                    and LDETECT mode (For non-secure pin only)                 */
  __IOM uint32_t  DETECTMODE_SEC;               /*!< (@ 0x00000028) Select between default DETECT signal behavior
                                                                    and LDETECT mode (For secure pin only)                     */
  __IM  uint32_t  RESERVED1[117];
  __IOM uint32_t  PIN_CNF[32];                  /*!< (@ 0x00000200) Description collection: Configuration of GPIO
                                                                    pins                                                       */
} NRF_GPIO_Type;


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define NRF_FICR_S_BASE             0x00FF0000UL
#define NRF_UICR_S_BASE             0x00FF8000UL
#define NRF_ETM_NS_BASE             0xE0041000UL
#define NRF_ETB_NS_BASE             0xE0051000UL
#define NRF_TPIU_NS_BASE            0xE0054000UL
#define NRF_ATBREPLICATOR_NS_BASE   0xE0058000UL
#define NRF_ATBFUNNEL1_NS_BASE      0xE005A000UL
#define NRF_ATBFUNNEL2_NS_BASE      0xE005B000UL
#define NRF_TAD_S_BASE              0xE0080000UL
#define NRF_SPU_S_BASE              0x50003000UL
#define NRF_REGULATORS_NS_BASE      0x40004000UL
#define NRF_REGULATORS_S_BASE       0x50004000UL
#define NRF_CLOCK_NS_BASE           0x40005000UL
#define NRF_POWER_NS_BASE           0x40005000UL
#define NRF_CLOCK_S_BASE            0x50005000UL
#define NRF_POWER_S_BASE            0x50005000UL
#define NRF_CTRL_AP_PERI_S_BASE     0x50006000UL
#define NRF_SPIM0_NS_BASE           0x40008000UL
#define NRF_SPIS0_NS_BASE           0x40008000UL
#define NRF_TWIM0_NS_BASE           0x40008000UL
#define NRF_TWIS0_NS_BASE           0x40008000UL
#define NRF_UARTE0_NS_BASE          0x40008000UL
#define NRF_SPIM0_S_BASE            0x50008000UL
#define NRF_SPIS0_S_BASE            0x50008000UL
#define NRF_TWIM0_S_BASE            0x50008000UL
#define NRF_TWIS0_S_BASE            0x50008000UL
#define NRF_UARTE0_S_BASE           0x50008000UL
#define NRF_SPIM1_NS_BASE           0x40009000UL
#define NRF_SPIS1_NS_BASE           0x40009000UL
#define NRF_TWIM1_NS_BASE           0x40009000UL
#define NRF_TWIS1_NS_BASE           0x40009000UL
#define NRF_UARTE1_NS_BASE          0x40009000UL
#define NRF_SPIM1_S_BASE            0x50009000UL
#define NRF_SPIS1_S_BASE            0x50009000UL
#define NRF_TWIM1_S_BASE            0x50009000UL
#define NRF_TWIS1_S_BASE            0x50009000UL
#define NRF_UARTE1_S_BASE           0x50009000UL
#define NRF_SPIM2_NS_BASE           0x4000A000UL
#define NRF_SPIS2_NS_BASE           0x4000A000UL
#define NRF_TWIM2_NS_BASE           0x4000A000UL
#define NRF_TWIS2_NS_BASE           0x4000A000UL
#define NRF_UARTE2_NS_BASE          0x4000A000UL
#define NRF_SPIM2_S_BASE            0x5000A000UL
#define NRF_SPIS2_S_BASE            0x5000A000UL
#define NRF_TWIM2_S_BASE            0x5000A000UL
#define NRF_TWIS2_S_BASE            0x5000A000UL
#define NRF_UARTE2_S_BASE           0x5000A000UL
#define NRF_SPIM3_NS_BASE           0x4000B000UL
#define NRF_SPIS3_NS_BASE           0x4000B000UL
#define NRF_TWIM3_NS_BASE           0x4000B000UL
#define NRF_TWIS3_NS_BASE           0x4000B000UL
#define NRF_UARTE3_NS_BASE          0x4000B000UL
#define NRF_SPIM3_S_BASE            0x5000B000UL
#define NRF_SPIS3_S_BASE            0x5000B000UL
#define NRF_TWIM3_S_BASE            0x5000B000UL
#define NRF_TWIS3_S_BASE            0x5000B000UL
#define NRF_UARTE3_S_BASE           0x5000B000UL
#define NRF_GPIOTE0_S_BASE          0x5000D000UL
#define NRF_SAADC_NS_BASE           0x4000E000UL
#define NRF_SAADC_S_BASE            0x5000E000UL
#define NRF_TIMER0_NS_BASE          0x4000F000UL
#define NRF_TIMER0_S_BASE           0x5000F000UL
#define NRF_TIMER1_NS_BASE          0x40010000UL
#define NRF_TIMER1_S_BASE           0x50010000UL
#define NRF_TIMER2_NS_BASE          0x40011000UL
#define NRF_TIMER2_S_BASE           0x50011000UL
#define NRF_RTC0_NS_BASE            0x40014000UL
#define NRF_RTC0_S_BASE             0x50014000UL
#define NRF_RTC1_NS_BASE            0x40015000UL
#define NRF_RTC1_S_BASE             0x50015000UL
#define NRF_DPPIC_NS_BASE           0x40017000UL
#define NRF_DPPIC_S_BASE            0x50017000UL
#define NRF_WDT_NS_BASE             0x40018000UL
#define NRF_WDT_S_BASE              0x50018000UL
#define NRF_EGU0_NS_BASE            0x4001B000UL
#define NRF_EGU0_S_BASE             0x5001B000UL
#define NRF_EGU1_NS_BASE            0x4001C000UL
#define NRF_EGU1_S_BASE             0x5001C000UL
#define NRF_EGU2_NS_BASE            0x4001D000UL
#define NRF_EGU2_S_BASE             0x5001D000UL
#define NRF_EGU3_NS_BASE            0x4001E000UL
#define NRF_EGU3_S_BASE             0x5001E000UL
#define NRF_EGU4_NS_BASE            0x4001F000UL
#define NRF_EGU4_S_BASE             0x5001F000UL
#define NRF_EGU5_NS_BASE            0x40020000UL
#define NRF_EGU5_S_BASE             0x50020000UL
#define NRF_PWM0_NS_BASE            0x40021000UL
#define NRF_PWM0_S_BASE             0x50021000UL
#define NRF_PWM1_NS_BASE            0x40022000UL
#define NRF_PWM1_S_BASE             0x50022000UL
#define NRF_PWM2_NS_BASE            0x40023000UL
#define NRF_PWM2_S_BASE             0x50023000UL
#define NRF_PWM3_NS_BASE            0x40024000UL
#define NRF_PWM3_S_BASE             0x50024000UL
#define NRF_PDM_NS_BASE             0x40026000UL
#define NRF_PDM_S_BASE              0x50026000UL
#define NRF_I2S_NS_BASE             0x40028000UL
#define NRF_I2S_S_BASE              0x50028000UL
#define NRF_IPC_NS_BASE             0x4002A000UL
#define NRF_IPC_S_BASE              0x5002A000UL
#define NRF_FPU_NS_BASE             0x4002C000UL
#define NRF_GPIOTE1_NS_BASE         0x40031000UL
#define NRF_APPROTECT_NS_BASE       0x40039000UL
#define NRF_KMU_NS_BASE             0x40039000UL
#define NRF_NVMC_NS_BASE            0x40039000UL
#define NRF_APPROTECT_S_BASE        0x50039000UL
#define NRF_KMU_S_BASE              0x50039000UL
#define NRF_NVMC_S_BASE             0x50039000UL
#define NRF_VMC_NS_BASE             0x4003A000UL
#define NRF_VMC_S_BASE              0x5003A000UL
#define NRF_CRYPTOCELL_S_BASE       0x50840000UL
#define NRF_CC_AES_S_BASE           0x50841000UL
#define NRF_CC_AHB_S_BASE           0x50841000UL
#define NRF_CC_CHACHA_S_BASE        0x50841000UL
#define NRF_CC_CTL_S_BASE           0x50841000UL
#define NRF_CC_DIN_S_BASE           0x50841000UL
#define NRF_CC_DOUT_S_BASE          0x50841000UL
#define NRF_CC_HASH_S_BASE          0x50841000UL
#define NRF_CC_HOST_RGF_S_BASE      0x50841000UL
#define NRF_CC_MISC_S_BASE          0x50841000UL
#define NRF_CC_PKA_S_BASE           0x50841000UL
#define NRF_CC_RNG_S_BASE           0x50841000UL
#define NRF_CC_RNG_SRAM_S_BASE      0x50841000UL
#define NRF_P0_NS_BASE              0x40842500UL
#define NRF_P0_S_BASE               0x50842500UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define NRF_FICR_S                  ((NRF_FICR_Type*)          NRF_FICR_S_BASE)
#define NRF_UICR_S                  ((NRF_UICR_Type*)          NRF_UICR_S_BASE)
#define NRF_ETM_NS                  ((NRF_ETM_Type*)           NRF_ETM_NS_BASE)
#define NRF_ETB_NS                  ((NRF_ETB_Type*)           NRF_ETB_NS_BASE)
#define NRF_TPIU_NS                 ((NRF_TPIU_Type*)          NRF_TPIU_NS_BASE)
#define NRF_ATBREPLICATOR_NS        ((NRF_ATBREPLICATOR_Type*)  NRF_ATBREPLICATOR_NS_BASE)
#define NRF_ATBFUNNEL1_NS           ((NRF_ATBFUNNEL_Type*)     NRF_ATBFUNNEL1_NS_BASE)
#define NRF_ATBFUNNEL2_NS           ((NRF_ATBFUNNEL_Type*)     NRF_ATBFUNNEL2_NS_BASE)
#define NRF_TAD_S                   ((NRF_TAD_Type*)           NRF_TAD_S_BASE)
#define NRF_SPU_S                   ((NRF_SPU_Type*)           NRF_SPU_S_BASE)
#define NRF_REGULATORS_NS           ((NRF_REGULATORS_Type*)    NRF_REGULATORS_NS_BASE)
#define NRF_REGULATORS_S            ((NRF_REGULATORS_Type*)    NRF_REGULATORS_S_BASE)
#define NRF_CLOCK_NS                ((NRF_CLOCK_Type*)         NRF_CLOCK_NS_BASE)
#define NRF_POWER_NS                ((NRF_POWER_Type*)         NRF_POWER_NS_BASE)
#define NRF_CLOCK_S                 ((NRF_CLOCK_Type*)         NRF_CLOCK_S_BASE)
#define NRF_POWER_S                 ((NRF_POWER_Type*)         NRF_POWER_S_BASE)
#define NRF_CTRL_AP_PERI_S          ((NRF_CTRLAPPERI_Type*)    NRF_CTRL_AP_PERI_S_BASE)
#define NRF_SPIM0_NS                ((NRF_SPIM_Type*)          NRF_SPIM0_NS_BASE)
#define NRF_SPIS0_NS                ((NRF_SPIS_Type*)          NRF_SPIS0_NS_BASE)
#define NRF_TWIM0_NS                ((NRF_TWIM_Type*)          NRF_TWIM0_NS_BASE)
#define NRF_TWIS0_NS                ((NRF_TWIS_Type*)          NRF_TWIS0_NS_BASE)
#define NRF_UARTE0_NS               ((NRF_UARTE_Type*)         NRF_UARTE0_NS_BASE)
#define NRF_SPIM0_S                 ((NRF_SPIM_Type*)          NRF_SPIM0_S_BASE)
#define NRF_SPIS0_S                 ((NRF_SPIS_Type*)          NRF_SPIS0_S_BASE)
#define NRF_TWIM0_S                 ((NRF_TWIM_Type*)          NRF_TWIM0_S_BASE)
#define NRF_TWIS0_S                 ((NRF_TWIS_Type*)          NRF_TWIS0_S_BASE)
#define NRF_UARTE0_S                ((NRF_UARTE_Type*)         NRF_UARTE0_S_BASE)
#define NRF_SPIM1_NS                ((NRF_SPIM_Type*)          NRF_SPIM1_NS_BASE)
#define NRF_SPIS1_NS                ((NRF_SPIS_Type*)          NRF_SPIS1_NS_BASE)
#define NRF_TWIM1_NS                ((NRF_TWIM_Type*)          NRF_TWIM1_NS_BASE)
#define NRF_TWIS1_NS                ((NRF_TWIS_Type*)          NRF_TWIS1_NS_BASE)
#define NRF_UARTE1_NS               ((NRF_UARTE_Type*)         NRF_UARTE1_NS_BASE)
#define NRF_SPIM1_S                 ((NRF_SPIM_Type*)          NRF_SPIM1_S_BASE)
#define NRF_SPIS1_S                 ((NRF_SPIS_Type*)          NRF_SPIS1_S_BASE)
#define NRF_TWIM1_S                 ((NRF_TWIM_Type*)          NRF_TWIM1_S_BASE)
#define NRF_TWIS1_S                 ((NRF_TWIS_Type*)          NRF_TWIS1_S_BASE)
#define NRF_UARTE1_S                ((NRF_UARTE_Type*)         NRF_UARTE1_S_BASE)
#define NRF_SPIM2_NS                ((NRF_SPIM_Type*)          NRF_SPIM2_NS_BASE)
#define NRF_SPIS2_NS                ((NRF_SPIS_Type*)          NRF_SPIS2_NS_BASE)
#define NRF_TWIM2_NS                ((NRF_TWIM_Type*)          NRF_TWIM2_NS_BASE)
#define NRF_TWIS2_NS                ((NRF_TWIS_Type*)          NRF_TWIS2_NS_BASE)
#define NRF_UARTE2_NS               ((NRF_UARTE_Type*)         NRF_UARTE2_NS_BASE)
#define NRF_SPIM2_S                 ((NRF_SPIM_Type*)          NRF_SPIM2_S_BASE)
#define NRF_SPIS2_S                 ((NRF_SPIS_Type*)          NRF_SPIS2_S_BASE)
#define NRF_TWIM2_S                 ((NRF_TWIM_Type*)          NRF_TWIM2_S_BASE)
#define NRF_TWIS2_S                 ((NRF_TWIS_Type*)          NRF_TWIS2_S_BASE)
#define NRF_UARTE2_S                ((NRF_UARTE_Type*)         NRF_UARTE2_S_BASE)
#define NRF_SPIM3_NS                ((NRF_SPIM_Type*)          NRF_SPIM3_NS_BASE)
#define NRF_SPIS3_NS                ((NRF_SPIS_Type*)          NRF_SPIS3_NS_BASE)
#define NRF_TWIM3_NS                ((NRF_TWIM_Type*)          NRF_TWIM3_NS_BASE)
#define NRF_TWIS3_NS                ((NRF_TWIS_Type*)          NRF_TWIS3_NS_BASE)
#define NRF_UARTE3_NS               ((NRF_UARTE_Type*)         NRF_UARTE3_NS_BASE)
#define NRF_SPIM3_S                 ((NRF_SPIM_Type*)          NRF_SPIM3_S_BASE)
#define NRF_SPIS3_S                 ((NRF_SPIS_Type*)          NRF_SPIS3_S_BASE)
#define NRF_TWIM3_S                 ((NRF_TWIM_Type*)          NRF_TWIM3_S_BASE)
#define NRF_TWIS3_S                 ((NRF_TWIS_Type*)          NRF_TWIS3_S_BASE)
#define NRF_UARTE3_S                ((NRF_UARTE_Type*)         NRF_UARTE3_S_BASE)
#define NRF_GPIOTE0_S               ((NRF_GPIOTE_Type*)        NRF_GPIOTE0_S_BASE)
#define NRF_SAADC_NS                ((NRF_SAADC_Type*)         NRF_SAADC_NS_BASE)
#define NRF_SAADC_S                 ((NRF_SAADC_Type*)         NRF_SAADC_S_BASE)
#define NRF_TIMER0_NS               ((NRF_TIMER_Type*)         NRF_TIMER0_NS_BASE)
#define NRF_TIMER0_S                ((NRF_TIMER_Type*)         NRF_TIMER0_S_BASE)
#define NRF_TIMER1_NS               ((NRF_TIMER_Type*)         NRF_TIMER1_NS_BASE)
#define NRF_TIMER1_S                ((NRF_TIMER_Type*)         NRF_TIMER1_S_BASE)
#define NRF_TIMER2_NS               ((NRF_TIMER_Type*)         NRF_TIMER2_NS_BASE)
#define NRF_TIMER2_S                ((NRF_TIMER_Type*)         NRF_TIMER2_S_BASE)
#define NRF_RTC0_NS                 ((NRF_RTC_Type*)           NRF_RTC0_NS_BASE)
#define NRF_RTC0_S                  ((NRF_RTC_Type*)           NRF_RTC0_S_BASE)
#define NRF_RTC1_NS                 ((NRF_RTC_Type*)           NRF_RTC1_NS_BASE)
#define NRF_RTC1_S                  ((NRF_RTC_Type*)           NRF_RTC1_S_BASE)
#define NRF_DPPIC_NS                ((NRF_DPPIC_Type*)         NRF_DPPIC_NS_BASE)
#define NRF_DPPIC_S                 ((NRF_DPPIC_Type*)         NRF_DPPIC_S_BASE)
#define NRF_WDT_NS                  ((NRF_WDT_Type*)           NRF_WDT_NS_BASE)
#define NRF_WDT_S                   ((NRF_WDT_Type*)           NRF_WDT_S_BASE)
#define NRF_EGU0_NS                 ((NRF_EGU_Type*)           NRF_EGU0_NS_BASE)
#define NRF_EGU0_S                  ((NRF_EGU_Type*)           NRF_EGU0_S_BASE)
#define NRF_EGU1_NS                 ((NRF_EGU_Type*)           NRF_EGU1_NS_BASE)
#define NRF_EGU1_S                  ((NRF_EGU_Type*)           NRF_EGU1_S_BASE)
#define NRF_EGU2_NS                 ((NRF_EGU_Type*)           NRF_EGU2_NS_BASE)
#define NRF_EGU2_S                  ((NRF_EGU_Type*)           NRF_EGU2_S_BASE)
#define NRF_EGU3_NS                 ((NRF_EGU_Type*)           NRF_EGU3_NS_BASE)
#define NRF_EGU3_S                  ((NRF_EGU_Type*)           NRF_EGU3_S_BASE)
#define NRF_EGU4_NS                 ((NRF_EGU_Type*)           NRF_EGU4_NS_BASE)
#define NRF_EGU4_S                  ((NRF_EGU_Type*)           NRF_EGU4_S_BASE)
#define NRF_EGU5_NS                 ((NRF_EGU_Type*)           NRF_EGU5_NS_BASE)
#define NRF_EGU5_S                  ((NRF_EGU_Type*)           NRF_EGU5_S_BASE)
#define NRF_PWM0_NS                 ((NRF_PWM_Type*)           NRF_PWM0_NS_BASE)
#define NRF_PWM0_S                  ((NRF_PWM_Type*)           NRF_PWM0_S_BASE)
#define NRF_PWM1_NS                 ((NRF_PWM_Type*)           NRF_PWM1_NS_BASE)
#define NRF_PWM1_S                  ((NRF_PWM_Type*)           NRF_PWM1_S_BASE)
#define NRF_PWM2_NS                 ((NRF_PWM_Type*)           NRF_PWM2_NS_BASE)
#define NRF_PWM2_S                  ((NRF_PWM_Type*)           NRF_PWM2_S_BASE)
#define NRF_PWM3_NS                 ((NRF_PWM_Type*)           NRF_PWM3_NS_BASE)
#define NRF_PWM3_S                  ((NRF_PWM_Type*)           NRF_PWM3_S_BASE)
#define NRF_PDM_NS                  ((NRF_PDM_Type*)           NRF_PDM_NS_BASE)
#define NRF_PDM_S                   ((NRF_PDM_Type*)           NRF_PDM_S_BASE)
#define NRF_I2S_NS                  ((NRF_I2S_Type*)           NRF_I2S_NS_BASE)
#define NRF_I2S_S                   ((NRF_I2S_Type*)           NRF_I2S_S_BASE)
#define NRF_IPC_NS                  ((NRF_IPC_Type*)           NRF_IPC_NS_BASE)
#define NRF_IPC_S                   ((NRF_IPC_Type*)           NRF_IPC_S_BASE)
#define NRF_FPU_NS                  ((NRF_FPU_Type*)           NRF_FPU_NS_BASE)
#define NRF_GPIOTE1_NS              ((NRF_GPIOTE_Type*)        NRF_GPIOTE1_NS_BASE)
#define NRF_APPROTECT_NS            ((NRF_APPROTECT_Type*)     NRF_APPROTECT_NS_BASE)
#define NRF_KMU_NS                  ((NRF_KMU_Type*)           NRF_KMU_NS_BASE)
#define NRF_NVMC_NS                 ((NRF_NVMC_Type*)          NRF_NVMC_NS_BASE)
#define NRF_APPROTECT_S             ((NRF_APPROTECT_Type*)     NRF_APPROTECT_S_BASE)
#define NRF_KMU_S                   ((NRF_KMU_Type*)           NRF_KMU_S_BASE)
#define NRF_NVMC_S                  ((NRF_NVMC_Type*)          NRF_NVMC_S_BASE)
#define NRF_VMC_NS                  ((NRF_VMC_Type*)           NRF_VMC_NS_BASE)
#define NRF_VMC_S                   ((NRF_VMC_Type*)           NRF_VMC_S_BASE)
#define NRF_CRYPTOCELL_S            ((NRF_CRYPTOCELL_Type*)    NRF_CRYPTOCELL_S_BASE)
#define NRF_CC_AES_S                ((NRF_CC_AES_Type*)        NRF_CC_AES_S_BASE)
#define NRF_CC_AHB_S                ((NRF_CC_AHB_Type*)        NRF_CC_AHB_S_BASE)
#define NRF_CC_CHACHA_S             ((NRF_CC_CHACHA_Type*)     NRF_CC_CHACHA_S_BASE)
#define NRF_CC_CTL_S                ((NRF_CC_CTL_Type*)        NRF_CC_CTL_S_BASE)
#define NRF_CC_DIN_S                ((NRF_CC_DIN_Type*)        NRF_CC_DIN_S_BASE)
#define NRF_CC_DOUT_S               ((NRF_CC_DOUT_Type*)       NRF_CC_DOUT_S_BASE)
#define NRF_CC_HASH_S               ((NRF_CC_HASH_Type*)       NRF_CC_HASH_S_BASE)
#define NRF_CC_HOST_RGF_S           ((NRF_CC_HOST_RGF_Type*)   NRF_CC_HOST_RGF_S_BASE)
#define NRF_CC_MISC_S               ((NRF_CC_MISC_Type*)       NRF_CC_MISC_S_BASE)
#define NRF_CC_PKA_S                ((NRF_CC_PKA_Type*)        NRF_CC_PKA_S_BASE)
#define NRF_CC_RNG_S                ((NRF_CC_RNG_Type*)        NRF_CC_RNG_S_BASE)
#define NRF_CC_RNG_SRAM_S           ((NRF_CC_RNG_SRAM_Type*)   NRF_CC_RNG_SRAM_S_BASE)
#define NRF_P0_NS                   ((NRF_GPIO_Type*)          NRF_P0_NS_BASE)
#define NRF_P0_S                    ((NRF_GPIO_Type*)          NRF_P0_S_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================  End of section using anonymous unions  ========================================= */
#if defined (__CC_ARM)
  #pragma pop
#elif defined (__ICCARM__)
  /* leave anonymous unions enabled */
#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  #pragma clang diagnostic pop
#elif defined (__GNUC__)
  /* anonymous unions are enabled by default */
#elif defined (__TMS470__)
  /* anonymous unions are enabled by default */
#elif defined (__TASKING__)
  #pragma warning restore
#elif defined (__CSMC__)
  /* anonymous unions are enabled by default */
#endif


#ifdef __cplusplus
}
#endif

#endif /* NRF9120_H */


/** @} */ /* End of group nrf9120 */

/** @} */ /* End of group Nordic Semiconductor */
