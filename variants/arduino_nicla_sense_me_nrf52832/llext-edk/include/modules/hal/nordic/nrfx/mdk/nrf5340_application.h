/*
Copyright (c) 2010 - 2025, Nordic Semiconductor ASA All rights reserved.

SPDX-License-Identifier: BSD-3-Clause

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. Neither the name of Nordic Semiconductor ASA nor the names of its
   contributors may be used to endorse or promote products derived from this
   software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
 *
 * @file     nrf5340_application.h
 * @brief    CMSIS HeaderFile
 * @version  1
 * @date     12. February 2025
 * @note     Generated by SVDConv V3.3.35 on Wednesday, 12.02.2025 14:52:30
 *           from File 'nrf5340_application.svd',
 *           last modified on Wednesday, 12.02.2025 13:51:19
 */



/** @addtogroup Nordic Semiconductor
  * @{
  */


/** @addtogroup nrf5340_application
  * @{
  */


#ifndef NRF5340_APPLICATION_H
#define NRF5340_APPLICATION_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M33 Specific Interrupt Numbers  ======================================= */
  Reset_IRQn                = -15,
  NonMaskableInt_IRQn       = -14,
  HardFault_IRQn            = -13,
  MemoryManagement_IRQn     = -12,              /*!< -12  Memory Management, MPU mismatch, including Access Violation
                                                     and No Match                                                              */
  BusFault_IRQn             = -11,              /*!< -11  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                     related Fault                                                             */
  UsageFault_IRQn           = -10,
  SecureFault_IRQn          =  -9,
  SVCall_IRQn               =  -5,
  DebugMonitor_IRQn         =  -4,
  PendSV_IRQn               =  -2,
  SysTick_IRQn              =  -1,
/* ====================================  nrf5340_application Specific Interrupt Numbers  ===================================== */
  FPU_IRQn                  =   0,
  CACHE_IRQn                =   1,
  SPU_IRQn                  =   3,
  CLOCK_POWER_IRQn          =   5,
  SERIAL0_IRQn              =   8,
  SERIAL1_IRQn              =   9,
  SPIM4_IRQn                =  10,
  SERIAL2_IRQn              =  11,
  SERIAL3_IRQn              =  12,
  GPIOTE0_IRQn              =  13,
  SAADC_IRQn                =  14,
  TIMER0_IRQn               =  15,
  TIMER1_IRQn               =  16,
  TIMER2_IRQn               =  17,
  RTC0_IRQn                 =  20,
  RTC1_IRQn                 =  21,
  WDT0_IRQn                 =  24,
  WDT1_IRQn                 =  25,
  COMP_LPCOMP_IRQn          =  26,
  EGU0_IRQn                 =  27,
  EGU1_IRQn                 =  28,
  EGU2_IRQn                 =  29,
  EGU3_IRQn                 =  30,
  EGU4_IRQn                 =  31,
  EGU5_IRQn                 =  32,
  PWM0_IRQn                 =  33,
  PWM1_IRQn                 =  34,
  PWM2_IRQn                 =  35,
  PWM3_IRQn                 =  36,
  PDM0_IRQn                 =  38,
  I2S0_IRQn                 =  40,
  IPC_IRQn                  =  42,
  QSPI_IRQn                 =  43,
  NFCT_IRQn                 =  45,
  GPIOTE1_IRQn              =  47,
  QDEC0_IRQn                =  51,
  QDEC1_IRQn                =  52,
  USBD_IRQn                 =  54,
  USBREGULATOR_IRQn         =  55,
  KMU_IRQn                  =  57,
  CRYPTOCELL_IRQn           =  68
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ==========================  Configuration of the ARM Cortex-M33 Processor and Core Peripherals  =========================== */
#define __CM33_REV                 0x0004U
#define __INTERRUPTS_MAX                   240
#define __DSP_PRESENT                  1
#define __NVIC_PRIO_BITS               3
#define __Vendor_SysTickConfig         0
#define __VTOR_PRESENT                 1
#define __MPU_PRESENT                  1
#define __FPU_PRESENT                  1
#define __FPU_DP                       0
#define __SAUREGION_PRESENT            0


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm33.h"
#include "system_nrf5340_application.h"

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* =========================================================================================================================== */
/* ================                              Device Specific Cluster Section                              ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_clusters
  * @{
  */


/**
  * @brief CACHEDATA_SET_WAY [WAY] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DATA0;                        /*!< (@ 0x00000000) Description cluster: Cache data bits [31:0] of
                                                                    SET[n], WAY[o].                                            */
  __IOM uint32_t  DATA1;                        /*!< (@ 0x00000004) Description cluster: Cache data bits [63:32]
                                                                    of SET[n], WAY[o].                                         */
  __IOM uint32_t  DATA2;                        /*!< (@ 0x00000008) Description cluster: Cache data bits [95:64]
                                                                    of SET[n], WAY[o].                                         */
  __IOM uint32_t  DATA3;                        /*!< (@ 0x0000000C) Description cluster: Cache data bits [127:96]
                                                                    of SET[n], WAY[o].                                         */
} CACHEDATA_SET_WAY_Type;


/**
  * @brief CACHEDATA_SET [SET] (Unspecified)
  */
typedef struct {
  __IOM CACHEDATA_SET_WAY_Type WAY[2];
} CACHEDATA_SET_Type;


/**
  * @brief CACHEINFO_SET [SET] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  WAY[2];                       /*!< (@ 0x00000000) Description collection: Cache information for
                                                                    SET[n], WAY[o].                                            */
} CACHEINFO_SET_Type;


/**
  * @brief FICR_INFO [INFO] (Device info)
  */
typedef struct {
  __IM  uint32_t  CONFIGID;
  __IM  uint32_t  DEVICEID[2];
  __IM  uint32_t  PART;
  __IM  uint32_t  VARIANT;                      /*!< (@ 0x00000010) Part Variant, Hardware version and Production
                                                                    configuration                                              */
  __IM  uint32_t  PACKAGE;
  __IM  uint32_t  RAM;
  __IM  uint32_t  FLASH;
  __IM  uint32_t  CODEPAGESIZE;
  __IM  uint32_t  CODESIZE;
  __IM  uint32_t  DEVICETYPE;
} FICR_INFO_Type;


/**
  * @brief FICR_TRIMCNF [TRIMCNF] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  ADDR;                         /*!< (@ 0x00000000) Description cluster: Address of the PAR register
                                                                    which will be written                                      */
  __IM  uint32_t  DATA;
} FICR_TRIMCNF_Type;


/**
  * @brief FICR_NFC [NFC] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  TAGHEADER0;                   /*!< (@ 0x00000000) Default header for NFC Tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST and NFCID1_LAST.                           */
  __IM  uint32_t  TAGHEADER1;                   /*!< (@ 0x00000004) Default header for NFC Tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST and NFCID1_LAST.                           */
  __IM  uint32_t  TAGHEADER2;                   /*!< (@ 0x00000008) Default header for NFC Tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST and NFCID1_LAST.                           */
  __IM  uint32_t  TAGHEADER3;                   /*!< (@ 0x0000000C) Default header for NFC Tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST and NFCID1_LAST.                           */
} FICR_NFC_Type;


/**
  * @brief FICR_TRNG90B [TRNG90B] (NIST800-90B RNG calibration data)
  */
typedef struct {
  __IM  uint32_t  BYTES;
  __IM  uint32_t  RCCUTOFF;
  __IM  uint32_t  APCUTOFF;
  __IM  uint32_t  STARTUP;
  __IM  uint32_t  ROSC1;
  __IM  uint32_t  ROSC2;
  __IM  uint32_t  ROSC3;
  __IM  uint32_t  ROSC4;
} FICR_TRNG90B_Type;


/**
  * @brief UICR_KEYSLOT_CONFIG [CONFIG] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DEST;                         /*!< (@ 0x00000000) Description cluster: Destination address where
                                                                    content of the key value registers (KEYSLOT.KEYn.VALUE[0-3
                                                                    ) will be pushed by KMU. Note that this
                                                                    address must match that of a peripherals
                                                                    APB mapped write-only key registers, else
                                                                    the KMU can push this key value into an
                                                                    address range which the CPU can potentially
                                                                    read.                                                      */
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000004) Description cluster: Define permissions for the
                                                                    key slot. Bits 0-15 and 16-31 can only be
                                                                    written when equal to 0xFFFF.                              */
} UICR_KEYSLOT_CONFIG_Type;


/**
  * @brief UICR_KEYSLOT_KEY [KEY] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  VALUE[4];                     /*!< (@ 0x00000000) Description collection: Define bits [31+o*32:0+o*32]
                                                                    of value assigned to KMU key slot.                         */
} UICR_KEYSLOT_KEY_Type;


/**
  * @brief UICR_KEYSLOT [KEYSLOT] (Unspecified)
  */
typedef struct {
  __IOM UICR_KEYSLOT_CONFIG_Type CONFIG[128];
  __IOM UICR_KEYSLOT_KEY_Type KEY[128];
} UICR_KEYSLOT_Type;


/**
  * @brief TAD_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  TRACECLK;
  __IOM uint32_t  TRACEDATA0;
  __IOM uint32_t  TRACEDATA1;
  __IOM uint32_t  TRACEDATA2;
  __IOM uint32_t  TRACEDATA3;
} TAD_PSEL_Type;


/**
  * @brief DCNF_EXTPERI [EXTPERI] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PROTECT;                      /*!< (@ 0x00000000) Description cluster: Control access for master
                                                                    connected to AMLI master port EXTPERI[n]                   */
} DCNF_EXTPERI_Type;


/**
  * @brief DCNF_EXTRAM [EXTRAM] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PROTECT;                      /*!< (@ 0x00000000) Description cluster: Control access from master
                                                                    connected to AMLI master port EXTRAM[n]                    */
} DCNF_EXTRAM_Type;


/**
  * @brief DCNF_EXTCODE [EXTCODE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PROTECT;                      /*!< (@ 0x00000000) Description cluster: Control access from master
                                                                    connected to AMLI master port EXTCODE[n]                   */
} DCNF_EXTCODE_Type;


/**
  * @brief CACHE_PROFILING [PROFILING] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  IHIT;                         /*!< (@ 0x00000000) Description cluster: Instruction fetch cache
                                                                    hit counter for cache region n, where n=0
                                                                    means Flash and n=1 means XIP.                             */
  __IM  uint32_t  IMISS;                        /*!< (@ 0x00000004) Description cluster: Instruction fetch cache
                                                                    miss counter for cache region n, where n=0
                                                                    means Flash and n=1 means XIP.                             */
  __IM  uint32_t  DHIT;                         /*!< (@ 0x00000008) Description cluster: Data fetch cache hit counter
                                                                    for cache region n, where n=0 means Flash
                                                                    and n=1 means XIP.                                         */
  __IM  uint32_t  DMISS;                        /*!< (@ 0x0000000C) Description cluster: Data fetch cache miss counter
                                                                    for cache region n, where n=0 means Flash
                                                                    and n=1 means XIP.                                         */
  __IM  uint32_t  RESERVED[4];
} CACHE_PROFILING_Type;


/**
  * @brief SPU_EXTDOMAIN [EXTDOMAIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Access for bus access generated
                                                                    from the external domain n List capabilities
                                                                    of the external domain n                                   */
} SPU_EXTDOMAIN_Type;


/**
  * @brief SPU_DPPI [DPPI] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Select between secure and
                                                                    non-secure attribute for the DPPI channels                 */
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000004) Description cluster: Prevent further modification
                                                                    of the corresponding PERM register                         */
} SPU_DPPI_Type;


/**
  * @brief SPU_GPIOPORT [GPIOPORT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Select between secure and
                                                                    non-secure attribute for pins 0 to 31 of
                                                                    port n                                                     */
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000004) Description cluster: Prevent further modification
                                                                    of the corresponding PERM register                         */
} SPU_GPIOPORT_Type;


/**
  * @brief SPU_FLASHNSC [FLASHNSC] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  REGION;                       /*!< (@ 0x00000000) Description cluster: Define which flash region
                                                                    can contain the non-secure callable (NSC)
                                                                    region n                                                   */
  __IOM uint32_t  SIZE;                         /*!< (@ 0x00000004) Description cluster: Define the size of the non-secure
                                                                    callable (NSC) region n                                    */
} SPU_FLASHNSC_Type;


/**
  * @brief SPU_RAMNSC [RAMNSC] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  REGION;                       /*!< (@ 0x00000000) Description cluster: Define which RAM region
                                                                    can contain the non-secure callable (NSC)
                                                                    region n                                                   */
  __IOM uint32_t  SIZE;                         /*!< (@ 0x00000004) Description cluster: Define the size of the non-secure
                                                                    callable (NSC) region n                                    */
} SPU_RAMNSC_Type;


/**
  * @brief SPU_FLASHREGION [FLASHREGION] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Access permissions for flash
                                                                    region n                                                   */
} SPU_FLASHREGION_Type;


/**
  * @brief SPU_RAMREGION [RAMREGION] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: Access permissions for RAM
                                                                    region n                                                   */
} SPU_RAMREGION_Type;


/**
  * @brief SPU_PERIPHID [PERIPHID] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000000) Description cluster: List capabilities and access
                                                                    permissions for the peripheral with ID n                   */
} SPU_PERIPHID_Type;


/**
  * @brief OSCILLATORS_XOSC32KI [XOSC32KI] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  BYPASS;                       /*!< (@ 0x00000000) Enable or disable bypass of LFCLK crystal oscillator
                                                                    with external clock source                                 */
  __IM  uint32_t  RESERVED[3];
  __IOM uint32_t  INTCAP;
} OSCILLATORS_XOSC32KI_Type;


/**
  * @brief REGULATORS_VREGMAIN [VREGMAIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DCDCEN;
} REGULATORS_VREGMAIN_Type;


/**
  * @brief REGULATORS_VREGRADIO [VREGRADIO] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  DCDCEN;
} REGULATORS_VREGRADIO_Type;


/**
  * @brief REGULATORS_VREGH [VREGH] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DCDCEN;
  __IM  uint32_t  RESERVED[15];
  __IOM uint32_t  EXTSILENTEN;                  /*!< (@ 0x00000040) When VREGH is in DC/DC mode, enable VREGH silent
                                                                    mode to supply external components from
                                                                    VDD. Silent mode has lower voltage ripple.
                                                                    Silent mode is used when DC/DC is enabled,
                                                                    and is ignored in LDO mode. Disabling silent
                                                                    mode reduces current consumption in sleep.                 */
} REGULATORS_VREGH_Type;


/**
  * @brief CLOCK_HFCLKAUDIO [HFCLKAUDIO] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000000) Audio PLL frequency in 11.176 MHz - 11.402 MHz
                                                                    or 12.165 MHz - 12.411 MHz frequency bands                 */
} CLOCK_HFCLKAUDIO_Type;


/**
  * @brief RESET_NETWORK [NETWORK] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  FORCEOFF;
} RESET_NETWORK_Type;


/**
  * @brief CTRLAPPERI_MAILBOX [MAILBOX] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  RXDATA;
  __IM  uint32_t  RXSTATUS;                     /*!< (@ 0x00000004) This register shows a status that indicates if
                                                                    data sent from the debugger to the CPU has
                                                                    been read.                                                 */
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  TXDATA;
  __IM  uint32_t  TXSTATUS;                     /*!< (@ 0x00000084) This register shows a status that indicates if
                                                                    the data sent from the CPU to the debugger
                                                                    has been read.                                             */
} CTRLAPPERI_MAILBOX_Type;


/**
  * @brief CTRLAPPERI_ERASEPROTECT [ERASEPROTECT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000000) This register locks the ERASEPROTECT.DISABLE
                                                                    register from being written until next reset.              */
  __IOM uint32_t  DISABLE;                      /*!< (@ 0x00000004) This register disables the ERASEPROTECT register
                                                                    and performs an ERASEALL operation.                        */
} CTRLAPPERI_ERASEPROTECT_Type;


/**
  * @brief CTRLAPPERI_APPROTECT [APPROTECT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000000) This register locks the APPROTECT.DISABLE register
                                                                    from being written to until next reset.                    */
  __IOM uint32_t  DISABLE;                      /*!< (@ 0x00000004) This register disables the APPROTECT register
                                                                    and enables debug access to non-secure mode.               */
} CTRLAPPERI_APPROTECT_Type;


/**
  * @brief CTRLAPPERI_SECUREAPPROTECT [SECUREAPPROTECT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  LOCK;                         /*!< (@ 0x00000000) This register locks the SECUREAPPROTECT.DISABLE
                                                                    register from being written until next reset.              */
  __IOM uint32_t  DISABLE;                      /*!< (@ 0x00000004) This register disables the SECUREAPPROTECT register
                                                                    and enables debug access to secure mode.                   */
} CTRLAPPERI_SECUREAPPROTECT_Type;


/**
  * @brief SPIM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;
  __IOM uint32_t  MOSI;
  __IOM uint32_t  MISO;
  __IOM uint32_t  CSN;
} SPIM_PSEL_Type;


/**
  * @brief SPIM_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} SPIM_RXD_Type;


/**
  * @brief SPIM_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} SPIM_TXD_Type;


/**
  * @brief SPIM_IFTIMING [IFTIMING] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RXDELAY;
  __IOM uint32_t  CSNDUR;                       /*!< (@ 0x00000004) Minimum duration between edge of CSN and edge
                                                                    of SCK. When SHORTS.END_START is used, this
                                                                    is also the minimum duration CSN must stay
                                                                    high between transactions.                                 */
} SPIM_IFTIMING_Type;


/**
  * @brief SPIS_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;
  __IOM uint32_t  MISO;
  __IOM uint32_t  MOSI;
  __IOM uint32_t  CSN;
} SPIS_PSEL_Type;


/**
  * @brief SPIS_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} SPIS_RXD_Type;


/**
  * @brief SPIS_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} SPIS_TXD_Type;


/**
  * @brief TWIM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;
  __IOM uint32_t  SDA;
} TWIM_PSEL_Type;


/**
  * @brief TWIM_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} TWIM_RXD_Type;


/**
  * @brief TWIM_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} TWIM_TXD_Type;


/**
  * @brief TWIS_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;
  __IOM uint32_t  SDA;
} TWIS_PSEL_Type;


/**
  * @brief TWIS_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} TWIS_RXD_Type;


/**
  * @brief TWIS_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} TWIS_TXD_Type;


/**
  * @brief UARTE_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RTS;
  __IOM uint32_t  TXD;
  __IOM uint32_t  CTS;
  __IOM uint32_t  RXD;
} UARTE_PSEL_Type;


/**
  * @brief UARTE_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
} UARTE_RXD_Type;


/**
  * @brief UARTE_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
} UARTE_TXD_Type;


/**
  * @brief SAADC_EVENTS_CH [EVENTS_CH] (Peripheral events.)
  */
typedef struct {
  __IOM uint32_t  LIMITH;                       /*!< (@ 0x00000000) Description cluster: Last results is equal or
                                                                    above CH[n].LIMIT.HIGH                                     */
  __IOM uint32_t  LIMITL;                       /*!< (@ 0x00000004) Description cluster: Last results is equal or
                                                                    below CH[n].LIMIT.LOW                                      */
} SAADC_EVENTS_CH_Type;


/**
  * @brief SAADC_PUBLISH_CH [PUBLISH_CH] (Publish configuration for events)
  */
typedef struct {
  __IOM uint32_t  LIMITH;                       /*!< (@ 0x00000000) Description cluster: Publish configuration for
                                                                    event CH[n].LIMITH                                         */
  __IOM uint32_t  LIMITL;                       /*!< (@ 0x00000004) Description cluster: Publish configuration for
                                                                    event CH[n].LIMITL                                         */
} SAADC_PUBLISH_CH_Type;


/**
  * @brief SAADC_CH [CH] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PSELP;                        /*!< (@ 0x00000000) Description cluster: Input positive pin selection
                                                                    for CH[n]                                                  */
  __IOM uint32_t  PSELN;                        /*!< (@ 0x00000004) Description cluster: Input negative pin selection
                                                                    for CH[n]                                                  */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000008) Description cluster: Input configuration for
                                                                    CH[n]                                                      */
  __IOM uint32_t  LIMIT;                        /*!< (@ 0x0000000C) Description cluster: High/low limits for event
                                                                    monitoring a channel                                       */
} SAADC_CH_Type;


/**
  * @brief SAADC_RESULT [RESULT] (RESULT EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of buffer words transferred since last
                                                                    START                                                      */
} SAADC_RESULT_Type;


/**
  * @brief DPPIC_TASKS_CHG [TASKS_CHG] (Channel group tasks)
  */
typedef struct {
  __OM  uint32_t  EN;
  __OM  uint32_t  DIS;
} DPPIC_TASKS_CHG_Type;


/**
  * @brief DPPIC_SUBSCRIBE_CHG [SUBSCRIBE_CHG] (Subscribe configuration for tasks)
  */
typedef struct {
  __IOM uint32_t  EN;                           /*!< (@ 0x00000000) Description cluster: Subscribe configuration
                                                                    for task CHG[n].EN                                         */
  __IOM uint32_t  DIS;                          /*!< (@ 0x00000004) Description cluster: Subscribe configuration
                                                                    for task CHG[n].DIS                                        */
} DPPIC_SUBSCRIBE_CHG_Type;


/**
  * @brief PWM_SEQ [SEQ] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Description cluster: Beginning address in RAM
                                                                    of this sequence                                           */
  __IOM uint32_t  CNT;                          /*!< (@ 0x00000004) Description cluster: Number of values (duty cycles)
                                                                    in this sequence                                           */
  __IOM uint32_t  REFRESH;                      /*!< (@ 0x00000008) Description cluster: Number of additional PWM
                                                                    periods between samples loaded into compare
                                                                    register                                                   */
  __IOM uint32_t  ENDDELAY;
  __IM  uint32_t  RESERVED[4];
} PWM_SEQ_Type;


/**
  * @brief PWM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  OUT[4];                       /*!< (@ 0x00000000) Description collection: Output pin select for
                                                                    PWM channel n                                              */
} PWM_PSEL_Type;


/**
  * @brief PDM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  CLK;
  __IOM uint32_t  DIN;
} PDM_PSEL_Type;


/**
  * @brief PDM_SAMPLE [SAMPLE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RAM address pointer to write samples to with
                                                                    EasyDMA                                                    */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Number of samples to allocate memory for in EasyDMA
                                                                    mode                                                       */
} PDM_SAMPLE_Type;


/**
  * @brief I2S_CONFIG [CONFIG] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MODE;
  __IOM uint32_t  RXEN;
  __IOM uint32_t  TXEN;
  __IOM uint32_t  MCKEN;
  __IOM uint32_t  MCKFREQ;
  __IOM uint32_t  RATIO;
  __IOM uint32_t  SWIDTH;
  __IOM uint32_t  ALIGN;
  __IOM uint32_t  FORMAT;
  __IOM uint32_t  CHANNELS;
  __IOM uint32_t  CLKCONFIG;
} I2S_CONFIG_Type;


/**
  * @brief I2S_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
} I2S_RXD_Type;


/**
  * @brief I2S_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
} I2S_TXD_Type;


/**
  * @brief I2S_RXTXD [RXTXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MAXCNT;
} I2S_RXTXD_Type;


/**
  * @brief I2S_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MCK;
  __IOM uint32_t  SCK;
  __IOM uint32_t  LRCK;
  __IOM uint32_t  SDIN;
  __IOM uint32_t  SDOUT;
} I2S_PSEL_Type;


/**
  * @brief QSPI_READ [READ] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SRC;
  __IOM uint32_t  DST;
  __IOM uint32_t  CNT;
} QSPI_READ_Type;


/**
  * @brief QSPI_WRITE [WRITE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DST;
  __IOM uint32_t  SRC;
  __IOM uint32_t  CNT;
} QSPI_WRITE_Type;


/**
  * @brief QSPI_ERASE [ERASE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  LEN;
} QSPI_ERASE_Type;


/**
  * @brief QSPI_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;
  __IOM uint32_t  CSN;
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  IO0;
  __IOM uint32_t  IO1;
  __IOM uint32_t  IO2;
  __IOM uint32_t  IO3;
} QSPI_PSEL_Type;


/**
  * @brief QSPI_XIP_ENC [XIP_ENC] (Unspecified)
  */
typedef struct {
  __OM  uint32_t  KEY0;
  __OM  uint32_t  KEY1;
  __OM  uint32_t  KEY2;
  __OM  uint32_t  KEY3;
  __OM  uint32_t  NONCE0;
  __OM  uint32_t  NONCE1;
  __OM  uint32_t  NONCE2;
  __IOM uint32_t  ENABLE;
} QSPI_XIP_ENC_Type;


/**
  * @brief QSPI_DMA_ENC [DMA_ENC] (Unspecified)
  */
typedef struct {
  __OM  uint32_t  KEY0;
  __OM  uint32_t  KEY1;
  __OM  uint32_t  KEY2;
  __OM  uint32_t  KEY3;
  __OM  uint32_t  NONCE0;
  __OM  uint32_t  NONCE1;
  __OM  uint32_t  NONCE2;
  __IOM uint32_t  ENABLE;
} QSPI_DMA_ENC_Type;


/**
  * @brief NFCT_FRAMESTATUS [FRAMESTATUS] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RX;
} NFCT_FRAMESTATUS_Type;


/**
  * @brief NFCT_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  FRAMECONFIG;
  __IOM uint32_t  AMOUNT;
} NFCT_TXD_Type;


/**
  * @brief NFCT_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  FRAMECONFIG;
  __IM  uint32_t  AMOUNT;
} NFCT_RXD_Type;


/**
  * @brief QDEC_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  LED;
  __IOM uint32_t  A;
  __IOM uint32_t  B;
} QDEC_PSEL_Type;


/**
  * @brief USBD_HALTED [HALTED] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  EPIN[8];                      /*!< (@ 0x00000000) Description collection: IN endpoint halted status.
                                                                    Can be used as is as response to a GetStatus()
                                                                    request to endpoint.                                       */
  __IM  uint32_t  RESERVED;
  __IM  uint32_t  EPOUT[8];                     /*!< (@ 0x00000024) Description collection: OUT endpoint halted status.
                                                                    Can be used as is as response to a GetStatus()
                                                                    request to endpoint.                                       */
} USBD_HALTED_Type;


/**
  * @brief USBD_SIZE [SIZE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  EPOUT[8];                     /*!< (@ 0x00000000) Description collection: Number of bytes received
                                                                    last in the data stage of this OUT endpoint                */
  __IM  uint32_t  ISOOUT;                       /*!< (@ 0x00000020) Number of bytes received last on this ISO OUT
                                                                    data endpoint                                              */
} USBD_SIZE_Type;


/**
  * @brief USBD_EPIN [EPIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Description cluster: Maximum number of bytes
                                                                    to transfer                                                */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Description cluster: Number of bytes transferred
                                                                    in the last transaction                                    */
  __IM  uint32_t  RESERVED[2];
} USBD_EPIN_Type;


/**
  * @brief USBD_ISOIN [ISOIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
} USBD_ISOIN_Type;


/**
  * @brief USBD_EPOUT [EPOUT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Description cluster: Maximum number of bytes
                                                                    to transfer                                                */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Description cluster: Number of bytes transferred
                                                                    in the last transaction                                    */
  __IM  uint32_t  RESERVED[2];
} USBD_EPOUT_Type;


/**
  * @brief USBD_ISOOUT [ISOOUT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
} USBD_ISOOUT_Type;


/**
  * @brief VMC_RAM [RAM] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  POWER;
  __IOM uint32_t  POWERSET;                     /*!< (@ 0x00000004) Description cluster: RAM[n] power control set
                                                                    register                                                   */
  __IOM uint32_t  POWERCLR;                     /*!< (@ 0x00000008) Description cluster: RAM[n] power control clear
                                                                    register                                                   */
  __IM  uint32_t  RESERVED;
} VMC_RAM_Type;


/** @} */ /* End of group Device_Peripheral_clusters */


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                        CACHEDATA_S                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CACHEDATA (CACHEDATA_S)
  */

typedef struct {
  __IOM CACHEDATA_SET_Type SET[256];
} NRF_CACHEDATA_Type;



/* =========================================================================================================================== */
/* ================                                        CACHEINFO_S                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CACHEINFO (CACHEINFO_S)
  */

typedef struct {
  __IOM CACHEINFO_SET_Type SET[256];
} NRF_CACHEINFO_Type;



/* =========================================================================================================================== */
/* ================                                          FICR_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Factory Information Configuration Registers (FICR_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[128];
  __IOM FICR_INFO_Type INFO;
  __IM  uint32_t  RESERVED1[53];
  __IOM FICR_TRIMCNF_Type TRIMCNF[32];
  __IM  uint32_t  RESERVED2[20];
  __IOM FICR_NFC_Type NFC;
  __IM  uint32_t  RESERVED3[488];
  __IOM FICR_TRNG90B_Type TRNG90B;
  __IM  uint32_t  XOSC32MTRIM;
} NRF_FICR_Type;



/* =========================================================================================================================== */
/* ================                                          UICR_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief User Information Configuration Registers User information configuration registers (UICR_S)
  */

typedef struct {
  __IOM uint32_t  APPROTECT;
  __IM  uint32_t  RESERVED[3];
  __IOM uint32_t  VREGHVOUT;                    /*!< (@ 0x00000010) Output voltage from the high voltage (VREGH)
                                                                    regulator stage. The maximum output voltage
                                                                    from this stage is given as VDDH - VREGHDROP.              */
  __IOM uint32_t  HFXOCNT;
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  SECUREAPPROTECT;
  __IOM uint32_t  ERASEPROTECT;
  __IOM uint32_t  TINSTANCE;
  __IOM uint32_t  NFCPINS;                      /*!< (@ 0x00000028) Setting of pins dedicated to NFC functionality:
                                                                    NFC antenna or GPIO                                        */
  __IM  uint32_t  RESERVED2[53];
  __IOM uint32_t  OTP[192];                     /*!< (@ 0x00000100) Description collection: One time programmable
                                                                    memory                                                     */
  __IOM UICR_KEYSLOT_Type KEYSLOT;
} NRF_UICR_Type;



/* =========================================================================================================================== */
/* ================                                           CTI_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Cross-Trigger Interface control. NOTE: this is not a separate peripheral, but describes CM33 functionality. (CTI_S)
  */

typedef struct {
  __IOM uint32_t  CTICONTROL;
  __IM  uint32_t  RESERVED[3];
  __OM  uint32_t  CTIINTACK;
  __IOM uint32_t  CTIAPPSET;
  __OM  uint32_t  CTIAPPCLEAR;
  __OM  uint32_t  CTIAPPPULSE;
  __IOM uint32_t  CTIINEN[8];                   /*!< (@ 0x00000020) Description collection: CTI Trigger to Channel
                                                                    Enable register                                            */
  __IM  uint32_t  RESERVED1[24];
  __IOM uint32_t  CTIOUTEN[8];                  /*!< (@ 0x000000A0) Description collection: CTI Channel to Trigger
                                                                    Enable register                                            */
  __IM  uint32_t  RESERVED2[28];
  __IM  uint32_t  CTITRIGINSTATUS;
  __IM  uint32_t  CTITRIGOUTSTATUS;
  __IM  uint32_t  CTICHINSTATUS;
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  CTIGATE;
  __IM  uint32_t  RESERVED4[926];
  __IM  uint32_t  DEVARCH;
  __IM  uint32_t  RESERVED5[2];
  __IM  uint32_t  DEVID;
  __IM  uint32_t  DEVTYPE;
  __IM  uint32_t  PIDR4;
  __IM  uint32_t  PIDR5;
  __IM  uint32_t  PIDR6;
  __IM  uint32_t  PIDR7;
  __IM  uint32_t  PIDR0;
  __IM  uint32_t  PIDR1;
  __IM  uint32_t  PIDR2;
  __IM  uint32_t  PIDR3;
  __IM  uint32_t  CIDR0;
  __IM  uint32_t  CIDR1;
  __IM  uint32_t  CIDR2;
  __IM  uint32_t  CIDR3;
} NRF_CTI_Type;



/* =========================================================================================================================== */
/* ================                                           TAD_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Trace and debug control (TAD_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  CLOCKSTART;
  __OM  uint32_t  CLOCKSTOP;
  __IM  uint32_t  RESERVED1[317];
  __IOM uint32_t  ENABLE;
  __IOM TAD_PSEL_Type PSEL;
  __IOM uint32_t  TRACEPORTSPEED;               /*!< (@ 0x00000518) Clocking options for the Trace Port debug interface
                                                                    Reset behavior is the same as debug components             */
} NRF_TAD_Type;



/* =========================================================================================================================== */
/* ================                                          DCNF_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Domain configuration management 0 (DCNF_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[264];
  __IM  uint32_t  CPUID;
  __IM  uint32_t  RESERVED1[7];
  __IOM DCNF_EXTPERI_Type EXTPERI[1];
  __IM  uint32_t  RESERVED2[7];
  __IOM DCNF_EXTRAM_Type EXTRAM[1];
  __IM  uint32_t  RESERVED3[7];
  __IOM DCNF_EXTCODE_Type EXTCODE[1];
} NRF_DCNF_Type;



/* =========================================================================================================================== */
/* ================                                          FPU_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief FPU control peripheral 0 (FPU_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[64];
  __IOM uint32_t  EVENTS_INVALIDOPERATION;      /*!< (@ 0x00000100) An FPUIOC exception triggered by an invalid operation
                                                                    has occurred in the FPU                                    */
  __IOM uint32_t  EVENTS_DIVIDEBYZERO;          /*!< (@ 0x00000104) An FPUDZC exception triggered by a floating-point
                                                                    divide-by-zero operation has occurred in
                                                                    the FPU                                                    */
  __IOM uint32_t  EVENTS_OVERFLOW;              /*!< (@ 0x00000108) An FPUOFC exception triggered by a floating-point
                                                                    overflow has occurred in the FPU                           */
  __IOM uint32_t  EVENTS_UNDERFLOW;             /*!< (@ 0x0000010C) An FPUUFC exception triggered by a floating-point
                                                                    underflow has occurred in the FPU                          */
  __IOM uint32_t  EVENTS_INEXACT;               /*!< (@ 0x00000110) An FPUIXC exception triggered by an inexact floating-point
                                                                    operation has occurred in the FPU                          */
  __IOM uint32_t  EVENTS_DENORMALINPUT;         /*!< (@ 0x00000114) An FPUIDC exception triggered by a denormal floating-point
                                                                    input has occurred in the FPU                              */
  __IM  uint32_t  RESERVED1[122];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
} NRF_FPU_Type;



/* =========================================================================================================================== */
/* ================                                          CACHE_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Cache (CACHE_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[256];
  __IOM CACHE_PROFILING_Type PROFILING[2];
  __IM  uint32_t  RESERVED1[48];
  __IOM uint32_t  ENABLE;
  __OM  uint32_t  INVALIDATE;
  __OM  uint32_t  ERASE;
  __IOM uint32_t  PROFILINGENABLE;
  __OM  uint32_t  PROFILINGCLEAR;
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000514) Cache mode. Switching from Cache to Ram mode
                                                                    causes the RAM to be cleared. Switching
                                                                    from RAM to Cache mode causes the cache
                                                                    to be invalidated.                                         */
  __IOM uint32_t  DEBUGLOCK;
  __IOM uint32_t  ERASESTATUS;
  __IOM uint32_t  WRITELOCK;                    /*!< (@ 0x00000520) Lock cache updates. Prevents updating of cache
                                                                    content on cache misses, but will continue
                                                                    to lookup instruction/data fetches in content
                                                                    already present in the cache. Ignored in
                                                                    RAM mode.                                                  */
} NRF_CACHE_Type;



/* =========================================================================================================================== */
/* ================                                           SPU_S                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief System protection unit (SPU_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[64];
  __IOM uint32_t  EVENTS_RAMACCERR;             /*!< (@ 0x00000100) A security violation has been detected for the
                                                                    RAM memory space                                           */
  __IOM uint32_t  EVENTS_FLASHACCERR;           /*!< (@ 0x00000104) A security violation has been detected for the
                                                                    flash memory space                                         */
  __IOM uint32_t  EVENTS_PERIPHACCERR;          /*!< (@ 0x00000108) A security violation has been detected on one
                                                                    or several peripherals                                     */
  __IM  uint32_t  RESERVED1[29];
  __IOM uint32_t  PUBLISH_RAMACCERR;
  __IOM uint32_t  PUBLISH_FLASHACCERR;
  __IOM uint32_t  PUBLISH_PERIPHACCERR;
  __IM  uint32_t  RESERVED2[93];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  CAP;
  __IOM uint32_t  CPULOCK;
  __IM  uint32_t  RESERVED4[14];
  __IOM SPU_EXTDOMAIN_Type EXTDOMAIN[1];
  __IM  uint32_t  RESERVED5[15];
  __IOM SPU_DPPI_Type DPPI[1];
  __IM  uint32_t  RESERVED6[14];
  __IOM SPU_GPIOPORT_Type GPIOPORT[2];
  __IM  uint32_t  RESERVED7[12];
  __IOM SPU_FLASHNSC_Type FLASHNSC[2];
  __IM  uint32_t  RESERVED8[12];
  __IOM SPU_RAMNSC_Type RAMNSC[2];
  __IM  uint32_t  RESERVED9[44];
  __IOM SPU_FLASHREGION_Type FLASHREGION[64];
  __IOM SPU_RAMREGION_Type RAMREGION[64];
  __IOM SPU_PERIPHID_Type PERIPHID[256];
} NRF_SPU_Type;



/* =========================================================================================================================== */
/* ================                                      OSCILLATORS_NS                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief Oscillator control 0 (OSCILLATORS_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[369];
  __IOM uint32_t  XOSC32MCAPS;
  __IM  uint32_t  RESERVED1[62];
  __IOM OSCILLATORS_XOSC32KI_Type XOSC32KI;
} NRF_OSCILLATORS_Type;



/* =========================================================================================================================== */
/* ================                                       REGULATORS_NS                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief Voltage regulators 0 (REGULATORS_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[266];
  __IM  uint32_t  MAINREGSTATUS;
  __IM  uint32_t  RESERVED1[53];
  __OM  uint32_t  SYSTEMOFF;
  __IM  uint32_t  RESERVED2[3];
  __IOM uint32_t  POFCON;
  __IM  uint32_t  RESERVED3[124];
  __IOM REGULATORS_VREGMAIN_Type VREGMAIN;
  __IM  uint32_t  RESERVED4[126];
  __IOM REGULATORS_VREGRADIO_Type VREGRADIO;
  __IM  uint32_t  RESERVED5[126];
  __IOM REGULATORS_VREGH_Type VREGH;
} NRF_REGULATORS_Type;



/* =========================================================================================================================== */
/* ================                                         CLOCK_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Clock management 0 (CLOCK_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_HFCLKSTART;             /*!< (@ 0x00000000) Start HFCLK128M/HFCLK64M source as selected in
                                                                    HFCLKSRC                                                   */
  __OM  uint32_t  TASKS_HFCLKSTOP;
  __OM  uint32_t  TASKS_LFCLKSTART;
  __OM  uint32_t  TASKS_LFCLKSTOP;
  __OM  uint32_t  TASKS_CAL;
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_HFCLKAUDIOSTART;
  __OM  uint32_t  TASKS_HFCLKAUDIOSTOP;
  __OM  uint32_t  TASKS_HFCLK192MSTART;
  __OM  uint32_t  TASKS_HFCLK192MSTOP;
  __IM  uint32_t  RESERVED1[22];
  __IOM uint32_t  SUBSCRIBE_HFCLKSTART;
  __IOM uint32_t  SUBSCRIBE_HFCLKSTOP;
  __IOM uint32_t  SUBSCRIBE_LFCLKSTART;
  __IOM uint32_t  SUBSCRIBE_LFCLKSTOP;
  __IOM uint32_t  SUBSCRIBE_CAL;
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  SUBSCRIBE_HFCLKAUDIOSTART;
  __IOM uint32_t  SUBSCRIBE_HFCLKAUDIOSTOP;
  __IOM uint32_t  SUBSCRIBE_HFCLK192MSTART;
  __IOM uint32_t  SUBSCRIBE_HFCLK192MSTOP;
  __IM  uint32_t  RESERVED3[22];
  __IOM uint32_t  EVENTS_HFCLKSTARTED;
  __IOM uint32_t  EVENTS_LFCLKSTARTED;
  __IM  uint32_t  RESERVED4[5];
  __IOM uint32_t  EVENTS_DONE;
  __IOM uint32_t  EVENTS_HFCLKAUDIOSTARTED;
  __IOM uint32_t  EVENTS_HFCLK192MSTARTED;
  __IM  uint32_t  RESERVED5[22];
  __IOM uint32_t  PUBLISH_HFCLKSTARTED;
  __IOM uint32_t  PUBLISH_LFCLKSTARTED;
  __IM  uint32_t  RESERVED6[5];
  __IOM uint32_t  PUBLISH_DONE;
  __IOM uint32_t  PUBLISH_HFCLKAUDIOSTARTED;
  __IOM uint32_t  PUBLISH_HFCLK192MSTARTED;
  __IM  uint32_t  RESERVED7[86];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  INTPEND;
  __IM  uint32_t  RESERVED8[62];
  __IM  uint32_t  HFCLKRUN;                     /*!< (@ 0x00000408) Status indicating that HFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  HFCLKSTAT;                    /*!< (@ 0x0000040C) Status indicating which HFCLK128M/HFCLK64M source
                                                                    is running This register value in any CLOCK
                                                                    instance reflects status only due to configurations/action
                                                                    in that CLOCK instance.                                    */
  __IM  uint32_t  RESERVED9;
  __IM  uint32_t  LFCLKRUN;                     /*!< (@ 0x00000414) Status indicating that LFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  LFCLKSTAT;                    /*!< (@ 0x00000418) Status indicating which LFCLK source is running
                                                                    This register value in any CLOCK instance
                                                                    reflects status only due to configurations/actions
                                                                    in that CLOCK instance.                                    */
  __IM  uint32_t  LFCLKSRCCOPY;                 /*!< (@ 0x0000041C) Copy of LFCLKSRC register, set when LFCLKSTART
                                                                    task was triggered                                         */
  __IM  uint32_t  RESERVED10[12];
  __IM  uint32_t  HFCLKAUDIORUN;                /*!< (@ 0x00000450) Status indicating that HFCLKAUDIOSTART task has
                                                                    been triggered                                             */
  __IM  uint32_t  HFCLKAUDIOSTAT;               /*!< (@ 0x00000454) Status indicating which HFCLKAUDIO source is
                                                                    running                                                    */
  __IM  uint32_t  HFCLK192MRUN;                 /*!< (@ 0x00000458) Status indicating that HFCLK192MSTART task has
                                                                    been triggered                                             */
  __IM  uint32_t  HFCLK192MSTAT;
  __IM  uint32_t  RESERVED11[45];
  __IOM uint32_t  HFCLKSRC;
  __IOM uint32_t  LFCLKSRC;
  __IM  uint32_t  RESERVED12[15];
  __IOM uint32_t  HFCLKCTRL;
  __IOM CLOCK_HFCLKAUDIO_Type HFCLKAUDIO;
  __IM  uint32_t  RESERVED13[4];
  __IOM uint32_t  HFCLKALWAYSRUN;
  __IOM uint32_t  LFCLKALWAYSRUN;
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  HFCLKAUDIOALWAYSRUN;
  __IOM uint32_t  HFCLK192MSRC;
  __IOM uint32_t  HFCLK192MALWAYSRUN;
  __IM  uint32_t  RESERVED15[12];
  __IOM uint32_t  HFCLK192MCTRL;
} NRF_CLOCK_Type;



/* =========================================================================================================================== */
/* ================                                         POWER_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Power control 0 (POWER_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[30];
  __OM  uint32_t  TASKS_CONSTLAT;
  __OM  uint32_t  TASKS_LOWPWR;
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  SUBSCRIBE_CONSTLAT;
  __IOM uint32_t  SUBSCRIBE_LOWPWR;
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  EVENTS_POFWARN;
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_SLEEPENTER;
  __IOM uint32_t  EVENTS_SLEEPEXIT;
  __IM  uint32_t  RESERVED4[27];
  __IOM uint32_t  PUBLISH_POFWARN;
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  PUBLISH_SLEEPENTER;
  __IOM uint32_t  PUBLISH_SLEEPEXIT;
  __IM  uint32_t  RESERVED6[89];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED7[132];
  __IOM uint32_t  GPREGRET[2];                  /*!< (@ 0x0000051C) Description collection: General purpose retention
                                                                    register                                                   */
} NRF_POWER_Type;



/* =========================================================================================================================== */
/* ================                                         RESET_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Reset control 0 (RESET_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[256];
  __IOM uint32_t  RESETREAS;
  __IM  uint32_t  RESERVED1[131];
  __IOM RESET_NETWORK_Type NETWORK;
} NRF_RESET_Type;



/* =========================================================================================================================== */
/* ================                                         CTRLAP_NS                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Control access port 0 (CTRLAP_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[256];
  __IOM CTRLAPPERI_MAILBOX_Type MAILBOX;
  __IM  uint32_t  RESERVED1[30];
  __IOM CTRLAPPERI_ERASEPROTECT_Type ERASEPROTECT;
  __IM  uint32_t  RESERVED2[14];
  __IOM CTRLAPPERI_APPROTECT_Type APPROTECT;
  __IOM CTRLAPPERI_SECUREAPPROTECT_Type SECUREAPPROTECT;
  __IM  uint32_t  RESERVED3[44];
  __IM  uint32_t  STATUS;
} NRF_CTRLAPPERI_Type;



/* =========================================================================================================================== */
/* ================                                         SPIM0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial Peripheral Interface Master with EasyDMA 0 (SPIM0_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[4];
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;
  __OM  uint32_t  TASKS_RESUME;
  __IM  uint32_t  RESERVED2[27];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;
  __IOM uint32_t  SUBSCRIBE_RESUME;
  __IM  uint32_t  RESERVED4[24];
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  EVENTS_ENDRX;
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  EVENTS_END;
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  EVENTS_ENDTX;
  __IM  uint32_t  RESERVED8[10];
  __IOM uint32_t  EVENTS_STARTED;
  __IM  uint32_t  RESERVED9[13];
  __IOM uint32_t  PUBLISH_STOPPED;
  __IM  uint32_t  RESERVED10[2];
  __IOM uint32_t  PUBLISH_ENDRX;
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  PUBLISH_END;
  __IM  uint32_t  RESERVED12;
  __IOM uint32_t  PUBLISH_ENDTX;
  __IM  uint32_t  RESERVED13[10];
  __IOM uint32_t  PUBLISH_STARTED;
  __IM  uint32_t  RESERVED14[12];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED15[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED16[61];
  __IOM uint32_t  STALLSTAT;                    /*!< (@ 0x00000400) Stall status for EasyDMA RAM accesses. The fields
                                                                    in this register are set to STALL by hardware
                                                                    whenever a stall occurres and can be cleared
                                                                    (set to NOSTALL) by the CPU.                               */
  __IM  uint32_t  RESERVED17[63];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED18;
  __IOM SPIM_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED19[3];
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED20[3];
  __IOM SPIM_RXD_Type RXD;
  __IOM SPIM_TXD_Type TXD;
  __IOM uint32_t  CONFIG;
  __IM  uint32_t  RESERVED21[2];
  __IOM SPIM_IFTIMING_Type IFTIMING;
  __IOM uint32_t  CSNPOL;
  __IOM uint32_t  PSELDCX;
  __IOM uint32_t  DCXCNT;
  __IM  uint32_t  RESERVED22[19];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Byte transmitted after TXD.MAXCNT bytes have
                                                                    been transmitted in the case when RXD.MAXCNT
                                                                    is greater than TXD.MAXCNT                                 */
} NRF_SPIM_Type;



/* =========================================================================================================================== */
/* ================                                         SPIS0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Slave 0 (SPIS0_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[9];
  __OM  uint32_t  TASKS_ACQUIRE;
  __OM  uint32_t  TASKS_RELEASE;                /*!< (@ 0x00000028) Release SPI semaphore, enabling the SPI slave
                                                                    to acquire it                                              */
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  SUBSCRIBE_ACQUIRE;
  __IOM uint32_t  SUBSCRIBE_RELEASE;
  __IM  uint32_t  RESERVED2[22];
  __IOM uint32_t  EVENTS_END;
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_ENDRX;
  __IM  uint32_t  RESERVED4[5];
  __IOM uint32_t  EVENTS_ACQUIRED;
  __IM  uint32_t  RESERVED5[22];
  __IOM uint32_t  PUBLISH_END;
  __IM  uint32_t  RESERVED6[2];
  __IOM uint32_t  PUBLISH_ENDRX;
  __IM  uint32_t  RESERVED7[5];
  __IOM uint32_t  PUBLISH_ACQUIRED;
  __IM  uint32_t  RESERVED8[21];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED9[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED10[61];
  __IM  uint32_t  SEMSTAT;
  __IM  uint32_t  RESERVED11[15];
  __IOM uint32_t  STATUS;
  __IM  uint32_t  RESERVED12[47];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED13;
  __IOM SPIS_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED14[7];
  __IOM SPIS_RXD_Type RXD;
  __IOM SPIS_TXD_Type TXD;
  __IOM uint32_t  CONFIG;
  __IM  uint32_t  RESERVED15;
  __IOM uint32_t  DEF;                          /*!< (@ 0x0000055C) Default character. Character clocked out in case
                                                                    of an ignored transaction.                                 */
  __IM  uint32_t  RESERVED16[24];
  __IOM uint32_t  ORC;
} NRF_SPIS_Type;



/* =========================================================================================================================== */
/* ================                                         TWIM0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Master Interface with EasyDMA 0 (TWIM0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_STARTRX;
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTTX;
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction. Must be issued while the
                                                                    TWI master is not suspended.                               */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  TASKS_SUSPEND;
  __OM  uint32_t  TASKS_RESUME;
  __IM  uint32_t  RESERVED3[23];
  __IOM uint32_t  SUBSCRIBE_STARTRX;
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  SUBSCRIBE_STARTTX;
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;
  __IOM uint32_t  SUBSCRIBE_RESUME;
  __IM  uint32_t  RESERVED7[24];
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED8[7];
  __IOM uint32_t  EVENTS_ERROR;
  __IM  uint32_t  RESERVED9[8];
  __IOM uint32_t  EVENTS_SUSPENDED;             /*!< (@ 0x00000148) SUSPEND task has been issued, TWI traffic is
                                                                    now suspended.                                             */
  __IOM uint32_t  EVENTS_RXSTARTED;
  __IOM uint32_t  EVENTS_TXSTARTED;
  __IM  uint32_t  RESERVED10[2];
  __IOM uint32_t  EVENTS_LASTRX;
  __IOM uint32_t  EVENTS_LASTTX;                /*!< (@ 0x00000160) Byte boundary, starting to transmit the last
                                                                    byte                                                       */
  __IM  uint32_t  RESERVED11[8];
  __IOM uint32_t  PUBLISH_STOPPED;
  __IM  uint32_t  RESERVED12[7];
  __IOM uint32_t  PUBLISH_ERROR;
  __IM  uint32_t  RESERVED13[8];
  __IOM uint32_t  PUBLISH_SUSPENDED;
  __IOM uint32_t  PUBLISH_RXSTARTED;
  __IOM uint32_t  PUBLISH_TXSTARTED;
  __IM  uint32_t  RESERVED14[2];
  __IOM uint32_t  PUBLISH_LASTRX;
  __IOM uint32_t  PUBLISH_LASTTX;
  __IM  uint32_t  RESERVED15[7];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED16[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED17[110];
  __IOM uint32_t  ERRORSRC;
  __IM  uint32_t  RESERVED18[14];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED19;
  __IOM TWIM_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED20[5];
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED21[3];
  __IOM TWIM_RXD_Type RXD;
  __IOM TWIM_TXD_Type TXD;
  __IM  uint32_t  RESERVED22[13];
  __IOM uint32_t  ADDRESS;
} NRF_TWIM_Type;



/* =========================================================================================================================== */
/* ================                                         TWIS0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Slave Interface with EasyDMA 0 (TWIS0_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[5];
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;
  __OM  uint32_t  TASKS_RESUME;
  __IM  uint32_t  RESERVED2[3];
  __OM  uint32_t  TASKS_PREPARERX;
  __OM  uint32_t  TASKS_PREPARETX;
  __IM  uint32_t  RESERVED3[23];
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  SUBSCRIBE_SUSPEND;
  __IOM uint32_t  SUBSCRIBE_RESUME;
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  SUBSCRIBE_PREPARERX;
  __IOM uint32_t  SUBSCRIBE_PREPARETX;
  __IM  uint32_t  RESERVED6[19];
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED7[7];
  __IOM uint32_t  EVENTS_ERROR;
  __IM  uint32_t  RESERVED8[9];
  __IOM uint32_t  EVENTS_RXSTARTED;
  __IOM uint32_t  EVENTS_TXSTARTED;
  __IM  uint32_t  RESERVED9[4];
  __IOM uint32_t  EVENTS_WRITE;
  __IOM uint32_t  EVENTS_READ;
  __IM  uint32_t  RESERVED10[6];
  __IOM uint32_t  PUBLISH_STOPPED;
  __IM  uint32_t  RESERVED11[7];
  __IOM uint32_t  PUBLISH_ERROR;
  __IM  uint32_t  RESERVED12[9];
  __IOM uint32_t  PUBLISH_RXSTARTED;
  __IOM uint32_t  PUBLISH_TXSTARTED;
  __IM  uint32_t  RESERVED13[4];
  __IOM uint32_t  PUBLISH_WRITE;
  __IOM uint32_t  PUBLISH_READ;
  __IM  uint32_t  RESERVED14[5];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED15[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED16[113];
  __IOM uint32_t  ERRORSRC;
  __IM  uint32_t  MATCH;                        /*!< (@ 0x000004D4) Status register indicating which address had
                                                                    a match                                                    */
  __IM  uint32_t  RESERVED17[10];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED18;
  __IOM TWIS_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED19[9];
  __IOM TWIS_RXD_Type RXD;
  __IOM TWIS_TXD_Type TXD;
  __IM  uint32_t  RESERVED20[13];
  __IOM uint32_t  ADDRESS[2];
  __IM  uint32_t  RESERVED21;
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000594) Configuration register for the address match
                                                                    mechanism                                                  */
  __IM  uint32_t  RESERVED22[10];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character. Character sent out in case
                                                                    of an over-read of the transmit buffer.                    */
} NRF_TWIS_Type;



/* =========================================================================================================================== */
/* ================                                         UARTE0_NS                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief UART with EasyDMA 0 (UARTE0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_STARTRX;
  __OM  uint32_t  TASKS_STOPRX;
  __OM  uint32_t  TASKS_STARTTX;
  __OM  uint32_t  TASKS_STOPTX;
  __IM  uint32_t  RESERVED[7];
  __OM  uint32_t  TASKS_FLUSHRX;
  __IM  uint32_t  RESERVED1[20];
  __IOM uint32_t  SUBSCRIBE_STARTRX;
  __IOM uint32_t  SUBSCRIBE_STOPRX;
  __IOM uint32_t  SUBSCRIBE_STARTTX;
  __IOM uint32_t  SUBSCRIBE_STOPTX;
  __IM  uint32_t  RESERVED2[7];
  __IOM uint32_t  SUBSCRIBE_FLUSHRX;
  __IM  uint32_t  RESERVED3[20];
  __IOM uint32_t  EVENTS_CTS;
  __IOM uint32_t  EVENTS_NCTS;
  __IOM uint32_t  EVENTS_RXDRDY;                /*!< (@ 0x00000108) Data received in RXD (but potentially not yet
                                                                    transferred to Data RAM)                                   */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  EVENTS_ENDRX;
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  EVENTS_TXDRDY;
  __IOM uint32_t  EVENTS_ENDTX;
  __IOM uint32_t  EVENTS_ERROR;
  __IM  uint32_t  RESERVED6[7];
  __IOM uint32_t  EVENTS_RXTO;
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  EVENTS_RXSTARTED;
  __IOM uint32_t  EVENTS_TXSTARTED;
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  EVENTS_TXSTOPPED;
  __IM  uint32_t  RESERVED9[9];
  __IOM uint32_t  PUBLISH_CTS;
  __IOM uint32_t  PUBLISH_NCTS;
  __IOM uint32_t  PUBLISH_RXDRDY;
  __IM  uint32_t  RESERVED10;
  __IOM uint32_t  PUBLISH_ENDRX;
  __IM  uint32_t  RESERVED11[2];
  __IOM uint32_t  PUBLISH_TXDRDY;
  __IOM uint32_t  PUBLISH_ENDTX;
  __IOM uint32_t  PUBLISH_ERROR;
  __IM  uint32_t  RESERVED12[7];
  __IOM uint32_t  PUBLISH_RXTO;
  __IM  uint32_t  RESERVED13;
  __IOM uint32_t  PUBLISH_RXSTARTED;
  __IOM uint32_t  PUBLISH_TXSTARTED;
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  PUBLISH_TXSTOPPED;
  __IM  uint32_t  RESERVED15[9];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED16[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED17[93];
  __IOM uint32_t  ERRORSRC;
  __IM  uint32_t  RESERVED18[31];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED19;
  __IOM UARTE_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED20[3];
  __IOM uint32_t  BAUDRATE;                     /*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
                                                                    selected.                                                  */
  __IM  uint32_t  RESERVED21[3];
  __IOM UARTE_RXD_Type RXD;
  __IM  uint32_t  RESERVED22;
  __IOM UARTE_TXD_Type TXD;
  __IM  uint32_t  RESERVED23[7];
  __IOM uint32_t  CONFIG;
} NRF_UARTE_Type;



/* =========================================================================================================================== */
/* ================                                         GPIOTE0_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Tasks and Events 0 (GPIOTE0_S)
  */

typedef struct {
  __OM  uint32_t  TASKS_OUT[8];                 /*!< (@ 0x00000000) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is configured in CONFIG[n].POLARITY.                       */
  __IM  uint32_t  RESERVED[4];
  __OM  uint32_t  TASKS_SET[8];                 /*!< (@ 0x00000030) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is to set it high.                                         */
  __IM  uint32_t  RESERVED1[4];
  __OM  uint32_t  TASKS_CLR[8];                 /*!< (@ 0x00000060) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is to set it low.                                          */
  __IOM uint32_t  SUBSCRIBE_OUT[8];             /*!< (@ 0x00000080) Description collection: Subscribe configuration
                                                                    for task OUT[n]                                            */
  __IM  uint32_t  RESERVED2[4];
  __IOM uint32_t  SUBSCRIBE_SET[8];             /*!< (@ 0x000000B0) Description collection: Subscribe configuration
                                                                    for task SET[n]                                            */
  __IM  uint32_t  RESERVED3[4];
  __IOM uint32_t  SUBSCRIBE_CLR[8];             /*!< (@ 0x000000E0) Description collection: Subscribe configuration
                                                                    for task CLR[n]                                            */
  __IOM uint32_t  EVENTS_IN[8];                 /*!< (@ 0x00000100) Description collection: Event generated from
                                                                    pin specified in CONFIG[n].PSEL                            */
  __IM  uint32_t  RESERVED4[23];
  __IOM uint32_t  EVENTS_PORT;                  /*!< (@ 0x0000017C) Event generated from multiple input GPIO pins
                                                                    with SENSE mechanism enabled                               */
  __IOM uint32_t  PUBLISH_IN[8];                /*!< (@ 0x00000180) Description collection: Publish configuration
                                                                    for event IN[n]                                            */
  __IM  uint32_t  RESERVED5[23];
  __IOM uint32_t  PUBLISH_PORT;
  __IM  uint32_t  RESERVED6[65];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED7[126];
  __IOM uint32_t  LATENCY;                      /*!< (@ 0x00000504) Latency selection for Event mode (MODE=Event)
                                                                    with rising or falling edge detection on
                                                                    the pin.                                                   */
  __IM  uint32_t  RESERVED8[2];
  __IOM uint32_t  CONFIG[8];                    /*!< (@ 0x00000510) Description collection: Configuration for OUT[n],
                                                                    SET[n], and CLR[n] tasks and IN[n] event                   */
} NRF_GPIOTE_Type;



/* =========================================================================================================================== */
/* ================                                         SAADC_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Analog to Digital Converter 0 (SAADC_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start the ADC and prepare the result buffer in
                                                                    RAM                                                        */
  __OM  uint32_t  TASKS_SAMPLE;                 /*!< (@ 0x00000004) Take one ADC sample, if scan is enabled all channels
                                                                    are sampled                                                */
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_CALIBRATEOFFSET;
  __IM  uint32_t  RESERVED[28];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_SAMPLE;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IOM uint32_t  SUBSCRIBE_CALIBRATEOFFSET;
  __IM  uint32_t  RESERVED1[28];
  __IOM uint32_t  EVENTS_STARTED;
  __IOM uint32_t  EVENTS_END;
  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x00000108) A conversion task has been completed. Depending
                                                                    on the mode, multiple conversions might
                                                                    be needed for a result to be transferred
                                                                    to RAM.                                                    */
  __IOM uint32_t  EVENTS_RESULTDONE;
  __IOM uint32_t  EVENTS_CALIBRATEDONE;
  __IOM uint32_t  EVENTS_STOPPED;
  __IOM SAADC_EVENTS_CH_Type EVENTS_CH[8];
  __IM  uint32_t  RESERVED2[10];
  __IOM uint32_t  PUBLISH_STARTED;
  __IOM uint32_t  PUBLISH_END;
  __IOM uint32_t  PUBLISH_DONE;
  __IOM uint32_t  PUBLISH_RESULTDONE;
  __IOM uint32_t  PUBLISH_CALIBRATEDONE;
  __IOM uint32_t  PUBLISH_STOPPED;
  __IOM SAADC_PUBLISH_CH_Type PUBLISH_CH[8];
  __IM  uint32_t  RESERVED3[74];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED4[61];
  __IM  uint32_t  STATUS;
  __IM  uint32_t  RESERVED5[63];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED6[3];
  __IOM SAADC_CH_Type CH[8];
  __IM  uint32_t  RESERVED7[24];
  __IOM uint32_t  RESOLUTION;
  __IOM uint32_t  OVERSAMPLE;                   /*!< (@ 0x000005F4) Oversampling configuration. OVERSAMPLE should
                                                                    not be combined with SCAN. The RESOLUTION
                                                                    is applied before averaging, thus for high
                                                                    OVERSAMPLE a higher RESOLUTION should be
                                                                    used.                                                      */
  __IOM uint32_t  SAMPLERATE;
  __IM  uint32_t  RESERVED8[12];
  __IOM SAADC_RESULT_Type RESULT;
} NRF_SAADC_Type;



/* =========================================================================================================================== */
/* ================                                         TIMER0_NS                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer/Counter 0 (TIMER0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_COUNT;
  __OM  uint32_t  TASKS_CLEAR;
  __OM  uint32_t  TASKS_SHUTDOWN;
  __IM  uint32_t  RESERVED[11];
  __OM  uint32_t  TASKS_CAPTURE[6];             /*!< (@ 0x00000040) Description collection: Capture Timer value to
                                                                    CC[n] register                                             */
  __IM  uint32_t  RESERVED1[10];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IOM uint32_t  SUBSCRIBE_COUNT;
  __IOM uint32_t  SUBSCRIBE_CLEAR;
  __IOM uint32_t  SUBSCRIBE_SHUTDOWN;           /*!< (@ 0x00000090) Deprecated register - Subscribe configuration
                                                                    for task SHUTDOWN                                          */
  __IM  uint32_t  RESERVED2[11];
  __IOM uint32_t  SUBSCRIBE_CAPTURE[6];         /*!< (@ 0x000000C0) Description collection: Subscribe configuration
                                                                    for task CAPTURE[n]                                        */
  __IM  uint32_t  RESERVED3[26];
  __IOM uint32_t  EVENTS_COMPARE[6];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED4[26];
  __IOM uint32_t  PUBLISH_COMPARE[6];           /*!< (@ 0x000001C0) Description collection: Publish configuration
                                                                    for event COMPARE[n]                                       */
  __IM  uint32_t  RESERVED5[10];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED6[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED7[126];
  __IOM uint32_t  MODE;
  __IOM uint32_t  BITMODE;
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  PRESCALER;
  __IM  uint32_t  RESERVED9[11];
  __IOM uint32_t  CC[6];                        /*!< (@ 0x00000540) Description collection: Capture/Compare register
                                                                    n                                                          */
  __IM  uint32_t  RESERVED10[10];
  __IOM uint32_t  ONESHOTEN[6];                 /*!< (@ 0x00000580) Description collection: Enable one-shot operation
                                                                    for Capture/Compare channel n                              */
} NRF_TIMER_Type;



/* =========================================================================================================================== */
/* ================                                          RTC0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Real-time counter 0 (RTC0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_CLEAR;
  __OM  uint32_t  TASKS_TRIGOVRFLW;
  __IM  uint32_t  RESERVED[12];
  __OM  uint32_t  TASKS_CAPTURE[4];             /*!< (@ 0x00000040) Description collection: Capture RTC counter to
                                                                    CC[n] register                                             */
  __IM  uint32_t  RESERVED1[12];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IOM uint32_t  SUBSCRIBE_CLEAR;
  __IOM uint32_t  SUBSCRIBE_TRIGOVRFLW;
  __IM  uint32_t  RESERVED2[12];
  __IOM uint32_t  SUBSCRIBE_CAPTURE[4];         /*!< (@ 0x000000C0) Description collection: Subscribe configuration
                                                                    for task CAPTURE[n]                                        */
  __IM  uint32_t  RESERVED3[12];
  __IOM uint32_t  EVENTS_TICK;
  __IOM uint32_t  EVENTS_OVRFLW;
  __IM  uint32_t  RESERVED4[14];
  __IOM uint32_t  EVENTS_COMPARE[4];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED5[12];
  __IOM uint32_t  PUBLISH_TICK;
  __IOM uint32_t  PUBLISH_OVRFLW;
  __IM  uint32_t  RESERVED6[14];
  __IOM uint32_t  PUBLISH_COMPARE[4];           /*!< (@ 0x000001C0) Description collection: Publish configuration
                                                                    for event COMPARE[n]                                       */
  __IM  uint32_t  RESERVED7[12];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED8[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED9[13];
  __IOM uint32_t  EVTEN;
  __IOM uint32_t  EVTENSET;
  __IOM uint32_t  EVTENCLR;
  __IM  uint32_t  RESERVED10[110];
  __IM  uint32_t  COUNTER;
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000508) 12-bit prescaler for counter frequency (32768
                                                                    / (PRESCALER + 1)). Must be written when
                                                                    RTC is stopped.                                            */
  __IM  uint32_t  RESERVED11[13];
  __IOM uint32_t  CC[4];
} NRF_RTC_Type;



/* =========================================================================================================================== */
/* ================                                         DPPIC_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Distributed programmable peripheral interconnect controller 0 (DPPIC_NS)
  */

typedef struct {
  __OM  DPPIC_TASKS_CHG_Type TASKS_CHG[6];
  __IM  uint32_t  RESERVED[20];
  __IOM DPPIC_SUBSCRIBE_CHG_Type SUBSCRIBE_CHG[6];
  __IM  uint32_t  RESERVED1[276];
  __IOM uint32_t  CHEN;
  __IOM uint32_t  CHENSET;
  __IOM uint32_t  CHENCLR;
  __IM  uint32_t  RESERVED2[189];
  __IOM uint32_t  CHG[6];                       /*!< (@ 0x00000800) Description collection: Channel group n Note:
                                                                    Writes to this register are ignored if either
                                                                    SUBSCRIBE_CHG[n].EN or SUBSCRIBE_CHG[n].DIS
                                                                    is enabled                                                 */
} NRF_DPPIC_Type;



/* =========================================================================================================================== */
/* ================                                          WDT0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Watchdog Timer 0 (WDT0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  EVENTS_TIMEOUT;
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED2[30];
  __IOM uint32_t  PUBLISH_TIMEOUT;
  __IOM uint32_t  PUBLISH_STOPPED;
  __IM  uint32_t  RESERVED3[95];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED4[6];
  __IOM uint32_t  NMIENSET;
  __IOM uint32_t  NMIENCLR;
  __IM  uint32_t  RESERVED5[53];
  __IM  uint32_t  RUNSTATUS;
  __IM  uint32_t  REQSTATUS;
  __IM  uint32_t  RESERVED6[63];
  __IOM uint32_t  CRV;
  __IOM uint32_t  RREN;
  __IOM uint32_t  CONFIG;
  __IM  uint32_t  RESERVED7[4];
  __OM  uint32_t  TSEN;
  __IM  uint32_t  RESERVED8[55];
  __OM  uint32_t  RR[8];
} NRF_WDT_Type;



/* =========================================================================================================================== */
/* ================                                          COMP_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Comparator 0 (COMP_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_SAMPLE;
  __IM  uint32_t  RESERVED[29];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IOM uint32_t  SUBSCRIBE_SAMPLE;
  __IM  uint32_t  RESERVED1[29];
  __IOM uint32_t  EVENTS_READY;
  __IOM uint32_t  EVENTS_DOWN;
  __IOM uint32_t  EVENTS_UP;
  __IOM uint32_t  EVENTS_CROSS;
  __IM  uint32_t  RESERVED2[28];
  __IOM uint32_t  PUBLISH_READY;
  __IOM uint32_t  PUBLISH_DOWN;
  __IOM uint32_t  PUBLISH_UP;
  __IOM uint32_t  PUBLISH_CROSS;
  __IM  uint32_t  RESERVED3[28];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED5[61];
  __IM  uint32_t  RESULT;
  __IM  uint32_t  RESERVED6[63];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  PSEL;
  __IOM uint32_t  REFSEL;
  __IOM uint32_t  EXTREFSEL;
  __IM  uint32_t  RESERVED7[8];
  __IOM uint32_t  TH;
  __IOM uint32_t  MODE;
  __IOM uint32_t  HYST;
  __IOM uint32_t  ISOURCE;
} NRF_COMP_Type;



/* =========================================================================================================================== */
/* ================                                         LPCOMP_NS                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Low-power comparator 0 (LPCOMP_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_SAMPLE;
  __IM  uint32_t  RESERVED[29];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IOM uint32_t  SUBSCRIBE_SAMPLE;
  __IM  uint32_t  RESERVED1[29];
  __IOM uint32_t  EVENTS_READY;
  __IOM uint32_t  EVENTS_DOWN;
  __IOM uint32_t  EVENTS_UP;
  __IOM uint32_t  EVENTS_CROSS;
  __IM  uint32_t  RESERVED2[28];
  __IOM uint32_t  PUBLISH_READY;
  __IOM uint32_t  PUBLISH_DOWN;
  __IOM uint32_t  PUBLISH_UP;
  __IOM uint32_t  PUBLISH_CROSS;
  __IM  uint32_t  RESERVED3[28];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED4[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED5[61];
  __IM  uint32_t  RESULT;
  __IM  uint32_t  RESERVED6[63];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  PSEL;
  __IOM uint32_t  REFSEL;
  __IOM uint32_t  EXTREFSEL;
  __IM  uint32_t  RESERVED7[4];
  __IOM uint32_t  ANADETECT;
  __IM  uint32_t  RESERVED8[5];
  __IOM uint32_t  HYST;
} NRF_LPCOMP_Type;



/* =========================================================================================================================== */
/* ================                                          EGU0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Event generator unit 0 (EGU0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_TRIGGER[16];            /*!< (@ 0x00000000) Description collection: Trigger n for triggering
                                                                    the corresponding TRIGGERED[n] event                       */
  __IM  uint32_t  RESERVED[16];
  __IOM uint32_t  SUBSCRIBE_TRIGGER[16];        /*!< (@ 0x00000080) Description collection: Subscribe configuration
                                                                    for task TRIGGER[n]                                        */
  __IM  uint32_t  RESERVED1[16];
  __IOM uint32_t  EVENTS_TRIGGERED[16];         /*!< (@ 0x00000100) Description collection: Event number n generated
                                                                    by triggering the corresponding TRIGGER[n]
                                                                    task                                                       */
  __IM  uint32_t  RESERVED2[16];
  __IOM uint32_t  PUBLISH_TRIGGERED[16];        /*!< (@ 0x00000180) Description collection: Publish configuration
                                                                    for event TRIGGERED[n]                                     */
  __IM  uint32_t  RESERVED3[80];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
} NRF_EGU_Type;



/* =========================================================================================================================== */
/* ================                                          PWM0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse width modulation unit 0 (PWM0_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops PWM pulse generation on all channels at
                                                                    the end of current PWM period, and stops
                                                                    sequence playback                                          */
  __OM  uint32_t  TASKS_SEQSTART[2];            /*!< (@ 0x00000008) Description collection: Loads the first PWM value
                                                                    on all enabled channels from sequence n,
                                                                    and starts playing that sequence at the
                                                                    rate defined in SEQ[n]REFRESH and/or DECODER.MODE.
                                                                    Causes PWM generation to start if not running.             */
  __OM  uint32_t  TASKS_NEXTSTEP;               /*!< (@ 0x00000010) Steps by one value in the current sequence on
                                                                    all enabled channels if DECODER.MODE=NextStep.
                                                                    Does not cause PWM generation to start if
                                                                    not running.                                               */
  __IM  uint32_t  RESERVED1[28];
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IOM uint32_t  SUBSCRIBE_SEQSTART[2];        /*!< (@ 0x00000088) Description collection: Subscribe configuration
                                                                    for task SEQSTART[n]                                       */
  __IOM uint32_t  SUBSCRIBE_NEXTSTEP;
  __IM  uint32_t  RESERVED2[28];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) Response to STOP task, emitted when PWM pulses
                                                                    are no longer generated                                    */
  __IOM uint32_t  EVENTS_SEQSTARTED[2];         /*!< (@ 0x00000108) Description collection: First PWM period started
                                                                    on sequence n                                              */
  __IOM uint32_t  EVENTS_SEQEND[2];             /*!< (@ 0x00000110) Description collection: Emitted at end of every
                                                                    sequence n, when last value from RAM has
                                                                    been applied to wave counter                               */
  __IOM uint32_t  EVENTS_PWMPERIODEND;
  __IOM uint32_t  EVENTS_LOOPSDONE;             /*!< (@ 0x0000011C) Concatenated sequences have been played the amount
                                                                    of times defined in LOOP.CNT                               */
  __IM  uint32_t  RESERVED3[25];
  __IOM uint32_t  PUBLISH_STOPPED;
  __IOM uint32_t  PUBLISH_SEQSTARTED[2];        /*!< (@ 0x00000188) Description collection: Publish configuration
                                                                    for event SEQSTARTED[n]                                    */
  __IOM uint32_t  PUBLISH_SEQEND[2];            /*!< (@ 0x00000190) Description collection: Publish configuration
                                                                    for event SEQEND[n]                                        */
  __IOM uint32_t  PUBLISH_PWMPERIODEND;
  __IOM uint32_t  PUBLISH_LOOPSDONE;
  __IM  uint32_t  RESERVED4[24];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED5[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED6[125];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  MODE;
  __IOM uint32_t  COUNTERTOP;                   /*!< (@ 0x00000508) Value up to which the pulse generator counter
                                                                    counts                                                     */
  __IOM uint32_t  PRESCALER;
  __IOM uint32_t  DECODER;
  __IOM uint32_t  LOOP;
  __IM  uint32_t  RESERVED7[2];
  __IOM PWM_SEQ_Type SEQ[2];
  __IOM PWM_PSEL_Type PSEL;
} NRF_PWM_Type;



/* =========================================================================================================================== */
/* ================                                          PDM0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse Density Modulation (Digital Microphone) Interface 0 (PDM0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IM  uint32_t  RESERVED1[30];
  __IOM uint32_t  EVENTS_STARTED;
  __IOM uint32_t  EVENTS_STOPPED;
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000108) The PDM has written the last sample specified
                                                                    by SAMPLE.MAXCNT (or the last sample after
                                                                    a STOP task has been received) to Data RAM                 */
  __IM  uint32_t  RESERVED2[29];
  __IOM uint32_t  PUBLISH_STARTED;
  __IOM uint32_t  PUBLISH_STOPPED;
  __IOM uint32_t  PUBLISH_END;
  __IM  uint32_t  RESERVED3[93];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED4[125];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  PDMCLKCTRL;
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000508) Defines the routing of the connected PDM microphones'
                                                                    signals                                                    */
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  GAINL;
  __IOM uint32_t  GAINR;
  __IOM uint32_t  RATIO;                        /*!< (@ 0x00000520) Selects the ratio between PDM_CLK and output
                                                                    sample rate. Change PDMCLKCTRL accordingly.                */
  __IM  uint32_t  RESERVED6[7];
  __IOM PDM_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  MCLKCONFIG;
  __IM  uint32_t  RESERVED8[4];
  __IOM PDM_SAMPLE_Type SAMPLE;
} NRF_PDM_Type;



/* =========================================================================================================================== */
/* ================                                          I2S0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Inter-IC Sound 0 (I2S0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts continuous I2S transfer. Also starts MCK
                                                                    generator when this is enabled                             */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops I2S transfer and MCK generator. Triggering
                                                                    this task will cause the event STOPPED to
                                                                    be generated.                                              */
  __IM  uint32_t  RESERVED[30];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IM  uint32_t  RESERVED1[31];
  __IOM uint32_t  EVENTS_RXPTRUPD;              /*!< (@ 0x00000104) The RXD.PTR register has been copied to internal
                                                                    double-buffers. When the I2S module is started
                                                                    and RX is enabled, this event will be generated
                                                                    for every RXTXD.MAXCNT words received on
                                                                    the SDIN pin.                                              */
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  EVENTS_TXPTRUPD;              /*!< (@ 0x00000114) The TDX.PTR register has been copied to internal
                                                                    double-buffers. When the I2S module is started
                                                                    and TX is enabled, this event will be generated
                                                                    for every RXTXD.MAXCNT words that are sent
                                                                    on the SDOUT pin.                                          */
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  EVENTS_FRAMESTART;            /*!< (@ 0x0000011C) Frame start event, generated on the active edge
                                                                    of LRCK                                                    */
  __IM  uint32_t  RESERVED4[25];
  __IOM uint32_t  PUBLISH_RXPTRUPD;
  __IOM uint32_t  PUBLISH_STOPPED;
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  PUBLISH_TXPTRUPD;
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  PUBLISH_FRAMESTART;
  __IM  uint32_t  RESERVED7[88];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED8[125];
  __IOM uint32_t  ENABLE;
  __IOM I2S_CONFIG_Type CONFIG;
  __IM  uint32_t  RESERVED9[2];
  __IOM I2S_RXD_Type RXD;
  __IM  uint32_t  RESERVED10;
  __IOM I2S_TXD_Type TXD;
  __IM  uint32_t  RESERVED11[3];
  __IOM I2S_RXTXD_Type RXTXD;
  __IM  uint32_t  RESERVED12[3];
  __IOM I2S_PSEL_Type PSEL;
} NRF_I2S_Type;



/* =========================================================================================================================== */
/* ================                                          IPC_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Interprocessor communication 0 (IPC_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_SEND[16];               /*!< (@ 0x00000000) Description collection: Trigger events on IPC
                                                                    channel enabled in SEND_CNF[n]                             */
  __IM  uint32_t  RESERVED[16];
  __IOM uint32_t  SUBSCRIBE_SEND[16];           /*!< (@ 0x00000080) Description collection: Subscribe configuration
                                                                    for task SEND[n]                                           */
  __IM  uint32_t  RESERVED1[16];
  __IOM uint32_t  EVENTS_RECEIVE[16];           /*!< (@ 0x00000100) Description collection: Event received on one
                                                                    or more of the enabled IPC channels in RECEIVE_CNF[n]      */
  __IM  uint32_t  RESERVED2[16];
  __IOM uint32_t  PUBLISH_RECEIVE[16];          /*!< (@ 0x00000180) Description collection: Publish configuration
                                                                    for event RECEIVE[n]                                       */
  __IM  uint32_t  RESERVED3[80];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  INTPEND;
  __IM  uint32_t  RESERVED4[128];
  __IOM uint32_t  SEND_CNF[16];                 /*!< (@ 0x00000510) Description collection: Send event configuration
                                                                    for TASKS_SEND[n]                                          */
  __IM  uint32_t  RESERVED5[16];
  __IOM uint32_t  RECEIVE_CNF[16];              /*!< (@ 0x00000590) Description collection: Receive event configuration
                                                                    for EVENTS_RECEIVE[n]                                      */
  __IM  uint32_t  RESERVED6[16];
  __IOM uint32_t  GPMEM[2];
} NRF_IPC_Type;



/* =========================================================================================================================== */
/* ================                                          QSPI_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief External flash interface 0 (QSPI_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_ACTIVATE;
  __OM  uint32_t  TASKS_READSTART;              /*!< (@ 0x00000004) Start transfer from external flash memory to
                                                                    internal RAM                                               */
  __OM  uint32_t  TASKS_WRITESTART;             /*!< (@ 0x00000008) Start transfer from internal RAM to external
                                                                    flash memory                                               */
  __OM  uint32_t  TASKS_ERASESTART;
  __OM  uint32_t  TASKS_DEACTIVATE;
  __IM  uint32_t  RESERVED[27];
  __IOM uint32_t  SUBSCRIBE_ACTIVATE;
  __IOM uint32_t  SUBSCRIBE_READSTART;
  __IOM uint32_t  SUBSCRIBE_WRITESTART;
  __IOM uint32_t  SUBSCRIBE_ERASESTART;
  __IOM uint32_t  SUBSCRIBE_DEACTIVATE;
  __IM  uint32_t  RESERVED1[27];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) QSPI peripheral is ready. This event will be
                                                                    generated as a response to all QSPI tasks
                                                                    except DEACTIVATE.                                         */
  __IM  uint32_t  RESERVED2[31];
  __IOM uint32_t  PUBLISH_READY;
  __IM  uint32_t  RESERVED3[95];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED4[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable QSPI peripheral and acquire the pins selected
                                                                    in PSELn registers                                         */
  __IOM QSPI_READ_Type READ;
  __IOM QSPI_WRITE_Type WRITE;
  __IOM QSPI_ERASE_Type ERASE;
  __IOM QSPI_PSEL_Type PSEL;
  __IOM uint32_t  XIPOFFSET;                    /*!< (@ 0x00000540) Address offset into the external memory for Execute
                                                                    in Place operation.                                        */
  __IOM uint32_t  IFCONFIG0;
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  XIPEN;
  __IM  uint32_t  RESERVED6[4];
  __IOM QSPI_XIP_ENC_Type XIP_ENC;
  __IOM QSPI_DMA_ENC_Type DMA_ENC;
  __IM  uint32_t  RESERVED7[24];
  __IOM uint32_t  IFCONFIG1;
  __IM  uint32_t  STATUS;
  __IM  uint32_t  RESERVED8[3];
  __IOM uint32_t  DPMDUR;                       /*!< (@ 0x00000614) Set the duration required to enter/exit deep
                                                                    power-down mode (DPM).                                     */
  __IM  uint32_t  RESERVED9[3];
  __IOM uint32_t  ADDRCONF;
  __IM  uint32_t  RESERVED10[3];
  __IOM uint32_t  CINSTRCONF;
  __IOM uint32_t  CINSTRDAT0;
  __IOM uint32_t  CINSTRDAT1;
  __IOM uint32_t  IFTIMING;
} NRF_QSPI_Type;



/* =========================================================================================================================== */
/* ================                                          NFCT_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief NFC-A compatible radio 0 (NFCT_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_ACTIVATE;               /*!< (@ 0x00000000) Activate NFCT peripheral for incoming and outgoing
                                                                    frames, change state to activated                          */
  __OM  uint32_t  TASKS_DISABLE;
  __OM  uint32_t  TASKS_SENSE;                  /*!< (@ 0x00000008) Enable NFC sense field mode, change state to
                                                                    sense mode                                                 */
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x0000000C) Start transmission of an outgoing frame, change
                                                                    state to transmit                                          */
  __IM  uint32_t  RESERVED[3];
  __OM  uint32_t  TASKS_ENABLERXDATA;
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_GOIDLE;
  __OM  uint32_t  TASKS_GOSLEEP;
  __IM  uint32_t  RESERVED2[21];
  __IOM uint32_t  SUBSCRIBE_ACTIVATE;
  __IOM uint32_t  SUBSCRIBE_DISABLE;
  __IOM uint32_t  SUBSCRIBE_SENSE;
  __IOM uint32_t  SUBSCRIBE_STARTTX;
  __IM  uint32_t  RESERVED3[3];
  __IOM uint32_t  SUBSCRIBE_ENABLERXDATA;
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  SUBSCRIBE_GOIDLE;
  __IOM uint32_t  SUBSCRIBE_GOSLEEP;
  __IM  uint32_t  RESERVED5[21];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) The NFCT peripheral is ready to receive and send
                                                                    frames                                                     */
  __IOM uint32_t  EVENTS_FIELDDETECTED;
  __IOM uint32_t  EVENTS_FIELDLOST;
  __IOM uint32_t  EVENTS_TXFRAMESTART;          /*!< (@ 0x0000010C) Marks the start of the first symbol of a transmitted
                                                                    frame                                                      */
  __IOM uint32_t  EVENTS_TXFRAMEEND;            /*!< (@ 0x00000110) Marks the end of the last transmitted on-air
                                                                    symbol of a frame                                          */
  __IOM uint32_t  EVENTS_RXFRAMESTART;          /*!< (@ 0x00000114) Marks the end of the first symbol of a received
                                                                    frame                                                      */
  __IOM uint32_t  EVENTS_RXFRAMEEND;            /*!< (@ 0x00000118) Received data has been checked (CRC, parity)
                                                                    and transferred to RAM, and EasyDMA has
                                                                    ended accessing the RX buffer                              */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x0000011C) NFC error reported. The ERRORSTATUS register
                                                                    contains details on the source of the error.               */
  __IM  uint32_t  RESERVED6[2];
  __IOM uint32_t  EVENTS_RXERROR;               /*!< (@ 0x00000128) NFC RX frame error reported. The FRAMESTATUS.RX
                                                                    register contains details on the source
                                                                    of the error.                                              */
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x0000012C) RX buffer (as defined by PACKETPTR and MAXLEN)
                                                                    in Data RAM full.                                          */
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000130) Transmission of data in RAM has ended, and EasyDMA
                                                                    has ended accessing the TX buffer                          */
  __IM  uint32_t  RESERVED7;
  __IOM uint32_t  EVENTS_AUTOCOLRESSTARTED;
  __IM  uint32_t  RESERVED8[3];
  __IOM uint32_t  EVENTS_COLLISION;
  __IOM uint32_t  EVENTS_SELECTED;
  __IOM uint32_t  EVENTS_STARTED;
  __IM  uint32_t  RESERVED9[11];
  __IOM uint32_t  PUBLISH_READY;
  __IOM uint32_t  PUBLISH_FIELDDETECTED;
  __IOM uint32_t  PUBLISH_FIELDLOST;
  __IOM uint32_t  PUBLISH_TXFRAMESTART;
  __IOM uint32_t  PUBLISH_TXFRAMEEND;
  __IOM uint32_t  PUBLISH_RXFRAMESTART;
  __IOM uint32_t  PUBLISH_RXFRAMEEND;
  __IOM uint32_t  PUBLISH_ERROR;
  __IM  uint32_t  RESERVED10[2];
  __IOM uint32_t  PUBLISH_RXERROR;
  __IOM uint32_t  PUBLISH_ENDRX;
  __IOM uint32_t  PUBLISH_ENDTX;
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  PUBLISH_AUTOCOLRESSTARTED;
  __IM  uint32_t  RESERVED12[3];
  __IOM uint32_t  PUBLISH_COLLISION;
  __IOM uint32_t  PUBLISH_SELECTED;
  __IOM uint32_t  PUBLISH_STARTED;
  __IM  uint32_t  RESERVED13[11];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED14[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED15[62];
  __IOM uint32_t  ERRORSTATUS;
  __IM  uint32_t  RESERVED16;
  __IOM NFCT_FRAMESTATUS_Type FRAMESTATUS;
  __IM  uint32_t  NFCTAGSTATE;
  __IM  uint32_t  RESERVED17[3];
  __IM  uint32_t  SLEEPSTATE;
  __IM  uint32_t  RESERVED18[6];
  __IM  uint32_t  FIELDPRESENT;
  __IM  uint32_t  RESERVED19[49];
  __IOM uint32_t  FRAMEDELAYMIN;
  __IOM uint32_t  FRAMEDELAYMAX;
  __IOM uint32_t  FRAMEDELAYMODE;
  __IOM uint32_t  PACKETPTR;                    /*!< (@ 0x00000510) Packet pointer for TXD and RXD data storage in
                                                                    Data RAM                                                   */
  __IOM uint32_t  MAXLEN;                       /*!< (@ 0x00000514) Size of the RAM buffer allocated to TXD and RXD
                                                                    data storage each                                          */
  __IOM NFCT_TXD_Type TXD;
  __IOM NFCT_RXD_Type RXD;
  __IM  uint32_t  RESERVED20;
  __IOM uint32_t  MODULATIONCTRL;               /*!< (@ 0x0000052C) Enables the modulation output to a GPIO pin which
                                                                    can be connected to a second external antenna.             */
  __IM  uint32_t  RESERVED21[2];
  __IOM uint32_t  MODULATIONPSEL;
  __IM  uint32_t  RESERVED22[21];
  __IOM uint32_t  NFCID1_LAST;
  __IOM uint32_t  NFCID1_2ND_LAST;
  __IOM uint32_t  NFCID1_3RD_LAST;
  __IOM uint32_t  AUTOCOLRESCONFIG;             /*!< (@ 0x0000059C) Controls the auto collision resolution function.
                                                                    This setting must be done before the NFCT
                                                                    peripheral is activated.                                   */
  __IOM uint32_t  SENSRES;
  __IOM uint32_t  SELRES;
} NRF_NFCT_Type;



/* =========================================================================================================================== */
/* ================                                         MUTEX_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief MUTEX 0 (MUTEX_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[256];
  __IOM uint32_t  MUTEX[16];
} NRF_MUTEX_Type;



/* =========================================================================================================================== */
/* ================                                         QDEC0_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Quadrature Decoder 0 (QDEC0_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_READCLRACC;
  __OM  uint32_t  TASKS_RDCLRACC;
  __OM  uint32_t  TASKS_RDCLRDBL;
  __IM  uint32_t  RESERVED[27];
  __IOM uint32_t  SUBSCRIBE_START;
  __IOM uint32_t  SUBSCRIBE_STOP;
  __IOM uint32_t  SUBSCRIBE_READCLRACC;
  __IOM uint32_t  SUBSCRIBE_RDCLRACC;
  __IOM uint32_t  SUBSCRIBE_RDCLRDBL;
  __IM  uint32_t  RESERVED1[27];
  __IOM uint32_t  EVENTS_SAMPLERDY;             /*!< (@ 0x00000100) Event being generated for every new sample value
                                                                    written to the SAMPLE register                             */
  __IOM uint32_t  EVENTS_REPORTRDY;
  __IOM uint32_t  EVENTS_ACCOF;
  __IOM uint32_t  EVENTS_DBLRDY;
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED2[27];
  __IOM uint32_t  PUBLISH_SAMPLERDY;
  __IOM uint32_t  PUBLISH_REPORTRDY;
  __IOM uint32_t  PUBLISH_ACCOF;
  __IOM uint32_t  PUBLISH_DBLRDY;
  __IOM uint32_t  PUBLISH_STOPPED;
  __IM  uint32_t  RESERVED3[27];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED4[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED5[125];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  LEDPOL;
  __IOM uint32_t  SAMPLEPER;
  __IM  int32_t   SAMPLE;
  __IOM uint32_t  REPORTPER;                    /*!< (@ 0x00000510) Number of samples to be taken before REPORTRDY
                                                                    and DBLRDY events can be generated                         */
  __IM  int32_t   ACC;
  __IM  int32_t   ACCREAD;                      /*!< (@ 0x00000518) Snapshot of the ACC register, updated by the
                                                                    READCLRACC or RDCLRACC task                                */
  __IOM QDEC_PSEL_Type PSEL;
  __IOM uint32_t  DBFEN;
  __IM  uint32_t  RESERVED6[5];
  __IOM uint32_t  LEDPRE;
  __IM  uint32_t  ACCDBL;                       /*!< (@ 0x00000544) Register accumulating the number of detected
                                                                    double transitions                                         */
  __IM  uint32_t  ACCDBLREAD;                   /*!< (@ 0x00000548) Snapshot of the ACCDBL, updated by the READCLRACC
                                                                    or RDCLRDBL task                                           */
} NRF_QDEC_Type;



/* =========================================================================================================================== */
/* ================                                          USBD_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal serial bus device 0 (USBD_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTEPIN[8];           /*!< (@ 0x00000004) Description collection: Captures the EPIN[n].PTR
                                                                    and EPIN[n].MAXCNT registers values, and
                                                                    enables endpoint IN n to respond to traffic
                                                                    from host                                                  */
  __OM  uint32_t  TASKS_STARTISOIN;             /*!< (@ 0x00000024) Captures the ISOIN.PTR and ISOIN.MAXCNT registers
                                                                    values, and enables sending data on ISO
                                                                    endpoint                                                   */
  __OM  uint32_t  TASKS_STARTEPOUT[8];          /*!< (@ 0x00000028) Description collection: Captures the EPOUT[n].PTR
                                                                    and EPOUT[n].MAXCNT registers values, and
                                                                    enables endpoint n to respond to traffic
                                                                    from host                                                  */
  __OM  uint32_t  TASKS_STARTISOOUT;            /*!< (@ 0x00000048) Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers
                                                                    values, and enables receiving of data on
                                                                    ISO endpoint                                               */
  __OM  uint32_t  TASKS_EP0RCVOUT;
  __OM  uint32_t  TASKS_EP0STATUS;
  __OM  uint32_t  TASKS_EP0STALL;               /*!< (@ 0x00000054) Stalls data and status stage on control endpoint
                                                                    0                                                          */
  __OM  uint32_t  TASKS_DPDMDRIVE;              /*!< (@ 0x00000058) Forces D+ and D- lines into the state defined
                                                                    in the DPDMVALUE register                                  */
  __OM  uint32_t  TASKS_DPDMNODRIVE;            /*!< (@ 0x0000005C) Stops forcing D+ and D- lines into any state
                                                                    (USB engine takes control)                                 */
  __IM  uint32_t  RESERVED1[9];
  __IOM uint32_t  SUBSCRIBE_STARTEPIN[8];       /*!< (@ 0x00000084) Description collection: Subscribe configuration
                                                                    for task STARTEPIN[n]                                      */
  __IOM uint32_t  SUBSCRIBE_STARTISOIN;
  __IOM uint32_t  SUBSCRIBE_STARTEPOUT[8];      /*!< (@ 0x000000A8) Description collection: Subscribe configuration
                                                                    for task STARTEPOUT[n]                                     */
  __IOM uint32_t  SUBSCRIBE_STARTISOOUT;
  __IOM uint32_t  SUBSCRIBE_EP0RCVOUT;
  __IOM uint32_t  SUBSCRIBE_EP0STATUS;
  __IOM uint32_t  SUBSCRIBE_EP0STALL;
  __IOM uint32_t  SUBSCRIBE_DPDMDRIVE;
  __IOM uint32_t  SUBSCRIBE_DPDMNODRIVE;
  __IM  uint32_t  RESERVED2[8];
  __IOM uint32_t  EVENTS_USBRESET;              /*!< (@ 0x00000100) Signals that a USB reset condition has been detected
                                                                    on USB lines                                               */
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000104) Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT,
                                                                    or EPOUT[n].PTR and EPOUT[n].MAXCNT registers
                                                                    have been captured on all endpoints reported
                                                                    in the EPSTATUS register                                   */
  __IOM uint32_t  EVENTS_ENDEPIN[8];            /*!< (@ 0x00000108) Description collection: The whole EPIN[n] buffer
                                                                    has been consumed. The buffer can be accessed
                                                                    safely by software.                                        */
  __IOM uint32_t  EVENTS_EP0DATADONE;           /*!< (@ 0x00000128) An acknowledged data transfer has taken place
                                                                    on the control endpoint                                    */
  __IOM uint32_t  EVENTS_ENDISOIN;              /*!< (@ 0x0000012C) The whole ISOIN buffer has been consumed. The
                                                                    buffer can be accessed safely by software.                 */
  __IOM uint32_t  EVENTS_ENDEPOUT[8];           /*!< (@ 0x00000130) Description collection: The whole EPOUT[n] buffer
                                                                    has been consumed. The buffer can be accessed
                                                                    safely by software.                                        */
  __IOM uint32_t  EVENTS_ENDISOOUT;             /*!< (@ 0x00000150) The whole ISOOUT buffer has been consumed. The
                                                                    buffer can be accessed safely by software.                 */
  __IOM uint32_t  EVENTS_SOF;                   /*!< (@ 0x00000154) Signals that a SOF (start of frame) condition
                                                                    has been detected on USB lines                             */
  __IOM uint32_t  EVENTS_USBEVENT;              /*!< (@ 0x00000158) An event or an error not covered by specific
                                                                    events has occurred. Check EVENTCAUSE register
                                                                    to find the cause.                                         */
  __IOM uint32_t  EVENTS_EP0SETUP;              /*!< (@ 0x0000015C) A valid SETUP token has been received (and acknowledged)
                                                                    on the control endpoint                                    */
  __IOM uint32_t  EVENTS_EPDATA;                /*!< (@ 0x00000160) A data transfer has occurred on a data endpoint,
                                                                    indicated by the EPDATASTATUS register                     */
  __IM  uint32_t  RESERVED3[7];
  __IOM uint32_t  PUBLISH_USBRESET;
  __IOM uint32_t  PUBLISH_STARTED;
  __IOM uint32_t  PUBLISH_ENDEPIN[8];           /*!< (@ 0x00000188) Description collection: Publish configuration
                                                                    for event ENDEPIN[n]                                       */
  __IOM uint32_t  PUBLISH_EP0DATADONE;
  __IOM uint32_t  PUBLISH_ENDISOIN;
  __IOM uint32_t  PUBLISH_ENDEPOUT[8];          /*!< (@ 0x000001B0) Description collection: Publish configuration
                                                                    for event ENDEPOUT[n]                                      */
  __IOM uint32_t  PUBLISH_ENDISOOUT;
  __IOM uint32_t  PUBLISH_SOF;
  __IOM uint32_t  PUBLISH_USBEVENT;
  __IOM uint32_t  PUBLISH_EP0SETUP;
  __IOM uint32_t  PUBLISH_EPDATA;
  __IM  uint32_t  RESERVED4[7];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED5[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED6[61];
  __IOM uint32_t  EVENTCAUSE;
  __IM  uint32_t  RESERVED7[7];
  __IOM USBD_HALTED_Type HALTED;
  __IM  uint32_t  RESERVED8;
  __IOM uint32_t  EPSTATUS;                     /*!< (@ 0x00000468) Provides information on which endpoint's EasyDMA
                                                                    registers have been captured                               */
  __IOM uint32_t  EPDATASTATUS;                 /*!< (@ 0x0000046C) Provides information on which endpoint(s) an
                                                                    acknowledged data transfer has occurred
                                                                    (EPDATA event)                                             */
  __IM  uint32_t  USBADDR;
  __IM  uint32_t  RESERVED9[3];
  __IM  uint32_t  BMREQUESTTYPE;
  __IM  uint32_t  BREQUEST;
  __IM  uint32_t  WVALUEL;
  __IM  uint32_t  WVALUEH;
  __IM  uint32_t  WINDEXL;
  __IM  uint32_t  WINDEXH;
  __IM  uint32_t  WLENGTHL;
  __IM  uint32_t  WLENGTHH;
  __IOM USBD_SIZE_Type SIZE;
  __IM  uint32_t  RESERVED10[15];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  USBPULLUP;
  __IOM uint32_t  DPDMVALUE;                    /*!< (@ 0x00000508) State D+ and D- lines will be forced into by
                                                                    the DPDMDRIVE task. The DPDMNODRIVE task
                                                                    reverts the control of the lines to MAC
                                                                    IP (no forcing).                                           */
  __IOM uint32_t  DTOGGLE;
  __IOM uint32_t  EPINEN;
  __IOM uint32_t  EPOUTEN;
  __OM  uint32_t  EPSTALL;
  __IOM uint32_t  ISOSPLIT;
  __IM  uint32_t  FRAMECNTR;                    /*!< (@ 0x00000520) Returns the current value of the start of frame
                                                                    counter                                                    */
  __IM  uint32_t  RESERVED11[2];
  __IOM uint32_t  LOWPOWER;                     /*!< (@ 0x0000052C) Controls USBD peripheral Low-power mode during
                                                                    USB suspend                                                */
  __IOM uint32_t  ISOINCONFIG;                  /*!< (@ 0x00000530) Controls the response of the ISO IN endpoint
                                                                    to an IN token when no data is ready to
                                                                    be sent                                                    */
  __IM  uint32_t  RESERVED12[51];
  __IOM USBD_EPIN_Type EPIN[8];
  __IOM USBD_ISOIN_Type ISOIN;
  __IM  uint32_t  RESERVED13[21];
  __IOM USBD_EPOUT_Type EPOUT[8];
  __IOM USBD_ISOOUT_Type ISOOUT;
} NRF_USBD_Type;



/* =========================================================================================================================== */
/* ================                                      USBREGULATOR_NS                                      ================ */
/* =========================================================================================================================== */


/**
  * @brief USB Regulator 0 (USBREGULATOR_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[64];
  __IOM uint32_t  EVENTS_USBDETECTED;
  __IOM uint32_t  EVENTS_USBREMOVED;
  __IOM uint32_t  EVENTS_USBPWRRDY;
  __IM  uint32_t  RESERVED1[29];
  __IOM uint32_t  PUBLISH_USBDETECTED;
  __IOM uint32_t  PUBLISH_USBREMOVED;
  __IOM uint32_t  PUBLISH_USBPWRRDY;
  __IM  uint32_t  RESERVED2[93];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  USBREGSTATUS;
} NRF_USBREG_Type;



/* =========================================================================================================================== */
/* ================                                          KMU_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Key management unit 0 (KMU_NS)
  */

typedef struct {
  __OM  uint32_t  TASKS_PUSH_KEYSLOT;
  __IM  uint32_t  RESERVED[63];
  __IOM uint32_t  EVENTS_KEYSLOT_PUSHED;
  __IOM uint32_t  EVENTS_KEYSLOT_REVOKED;       /*!< (@ 0x00000104) Key slot has been revoked and cannot be tasked
                                                                    for selection                                              */
  __IOM uint32_t  EVENTS_KEYSLOT_ERROR;         /*!< (@ 0x00000108) No key slot selected, no destination address
                                                                    defined, or error during push operation                    */
  __IM  uint32_t  RESERVED1[125];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  INTPEND;
  __IM  uint32_t  RESERVED2[63];
  __IM  uint32_t  STATUS;
  __IM  uint32_t  RESERVED3[60];
  __IOM uint32_t  SELECTKEYSLOT;                /*!< (@ 0x00000500) Select key slot to be read over AHB or pushed
                                                                    over secure APB when TASKS_PUSH_KEYSLOT
                                                                    is started                                                 */
} NRF_KMU_Type;



/* =========================================================================================================================== */
/* ================                                          NVMC_NS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Non-volatile memory controller 0 (NVMC_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[256];
  __IM  uint32_t  READY;
  __IM  uint32_t  RESERVED1;
  __IM  uint32_t  READYNEXT;
  __IM  uint32_t  RESERVED2[62];
  __IOM uint32_t  CONFIG;
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  ERASEALL;
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  ERASEPAGEPARTIALCFG;
  __IM  uint32_t  RESERVED5[25];
  __IOM uint32_t  CONFIGNS;
  __OM  uint32_t  WRITEUICRNS;
} NRF_NVMC_Type;



/* =========================================================================================================================== */
/* ================                                           P0_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Port 0 (P0_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  OUT;
  __IOM uint32_t  OUTSET;
  __IOM uint32_t  OUTCLR;
  __IM  uint32_t  IN;
  __IOM uint32_t  DIR;
  __IOM uint32_t  DIRSET;
  __IOM uint32_t  DIRCLR;
  __IOM uint32_t  LATCH;                        /*!< (@ 0x00000020) Latch register indicating what GPIO pins that
                                                                    have met the criteria set in the PIN_CNF[n].SENSE
                                                                    registers                                                  */
  __IOM uint32_t  DETECTMODE;                   /*!< (@ 0x00000024) Select between default DETECT signal behavior
                                                                    and LDETECT mode                                           */
  __IOM uint32_t  DETECTMODE_SEC;               /*!< (@ 0x00000028) Select between default DETECT signal behavior
                                                                    and LDETECT mode                                           */
  __IM  uint32_t  RESERVED1[117];
  __IOM uint32_t  PIN_CNF[32];                  /*!< (@ 0x00000200) Description collection: Configuration of GPIO
                                                                    pins                                                       */
} NRF_GPIO_Type;



/* =========================================================================================================================== */
/* ================                                       CRYPTOCELL_S                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL register interface (CRYPTOCELL_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[320];
  __IOM uint32_t  ENABLE;
} NRF_CRYPTOCELL_Type;



/* =========================================================================================================================== */
/* ================                                         CC_AES_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL AES engine (CC_AES_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[256];
  __OM  uint32_t  AES_KEY_0[8];                 /*!< (@ 0x00000400) Description collection: AES key value to use
                                                                    in non-tunneling operations, or as the first
                                                                    tunnel stage key in tunneling operations.
                                                                    The initial AES_KEY_0[0] register holds
                                                                    the least significant bits [31:0] of the
                                                                    key value.                                                 */
  __OM  uint32_t  AES_KEY_1[8];                 /*!< (@ 0x00000420) Description collection: AES key value to use
                                                                    as the second tunnel stage key in tunneling
                                                                    operations. The initial AES_KEY_1[0] register
                                                                    holds the least significant bits [31:0]
                                                                    of the key value.                                          */
  __IOM uint32_t  AES_IV_0[4];                  /*!< (@ 0x00000440) Description collection: AES Initialization Vector
                                                                    (IV) to use in non-tunneling operations,
                                                                    or as the first tunnel stage IV in tunneling
                                                                    operations. The initial AES_IV_0[0] register
                                                                    holds the least significant bits [31:0]
                                                                    of the IV.                                                 */
  __IOM uint32_t  AES_IV_1[4];                  /*!< (@ 0x00000450) Description collection: AES Initialization Vector
                                                                    (IV) to use as the second tunnel stage IV
                                                                    in tunneling operations. The initial AES_IV_1[0]
                                                                    register holds the least significant bits
                                                                    [31:0] of the IV.                                          */
  __IOM uint32_t  AES_CTR[4];                   /*!< (@ 0x00000460) Description collection: AES counter (CTR) to
                                                                    use in non-tunneling and tunneling operations.
                                                                    The initial AES_CTR[0] register holds the
                                                                    least significant bits [31:0] of the CTR.                  */
  __IM  uint32_t  AES_BUSY;
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  AES_CMAC_INIT;                /*!< (@ 0x0000047C) Writing to this address triggers the AES engine
                                                                    to generate K1 and K2 for AES-CMAC operations.             */
  __IM  uint32_t  RESERVED2[15];
  __IOM uint32_t  AES_REMAINING_BYTES;          /*!< (@ 0x000004BC) This register should be set with the amount of
                                                                    remaining bytes until the end of the current
                                                                    AES operation.                                             */
  __IOM uint32_t  AES_CONTROL;
  __IM  uint32_t  RESERVED3;
  __IM  uint32_t  AES_HW_FLAGS;                 /*!< (@ 0x000004C8) Hardware configuration of the AES engine. Reset
                                                                    value holds the supported features.                        */
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  AES_CTR_NO_INCREMENT;         /*!< (@ 0x000004D8) This register enables the AES CTR no increment
                                                                    mode in which the counter mode is not incremented
                                                                    between two blocks                                         */
  __IM  uint32_t  RESERVED5[6];
  __OM  uint32_t  AES_SW_RESET;
  __IM  uint32_t  RESERVED6[11];
  __OM  uint32_t  AES_CMAC_SIZE0_KICK;          /*!< (@ 0x00000524) Writing to this address triggers the AES engine
                                                                    to perform a CMAC operation with size 0.
                                                                    The CMAC result can be read from the AES_IV_0
                                                                    register.                                                  */
} NRF_CC_AES_Type;



/* =========================================================================================================================== */
/* ================                                         CC_AHB_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL AHB interface (CC_AHB_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[704];
  __IOM uint32_t  AHBM_SINGLES;                 /*!< (@ 0x00000B00) This register forces the AHB transactions from
                                                                    CRYPTOCELL master to be always singles.                    */
  __IOM uint32_t  AHBM_HPROT;
  __IOM uint32_t  AHBM_HMASTLOCK;
  __IOM uint32_t  AHBM_HNONSEC;
} NRF_CC_AHB_Type;



/* =========================================================================================================================== */
/* ================                                          CC_AO_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CryptoCell AO (CC_AO_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[910];
  __IOM uint32_t  AO_APB_FILTERING;
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  CC_SW_RESET;
} NRF_CC_AO_Type;



/* =========================================================================================================================== */
/* ================                                        CC_CHACHA_S                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL CHACHA engine (CC_CHACHA_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[224];
  __IOM uint32_t  CHACHA_CONTROL;
  __IM  uint32_t  CHACHA_VERSION;
  __OM  uint32_t  CHACHA_KEY[8];                /*!< (@ 0x00000388) Description collection: CHACHA key value to use.
                                                                    The initial CHACHA_KEY[0] register holds
                                                                    the least significant bits [31:0] of the
                                                                    key value.                                                 */
  __IOM uint32_t  CHACHA_IV[2];                 /*!< (@ 0x000003A8) Description collection: CHACHA Initialization
                                                                    Vector (IV) to use. The IV is also known
                                                                    as the nonce.                                              */
  __IM  uint32_t  CHACHA_BUSY;
  __IM  uint32_t  CHACHA_HW_FLAGS;              /*!< (@ 0x000003B4) Hardware configuration of the CHACHA engine.
                                                                    Reset value holds the supported features.                  */
  __IOM uint32_t  CHACHA_BLOCK_CNT_LSB;         /*!< (@ 0x000003B8) Store the LSB value of the block counter, in
                                                                    order to support suspend/resume of operation               */
  __IOM uint32_t  CHACHA_BLOCK_CNT_MSB;         /*!< (@ 0x000003BC) Store the MSB value of the block counter, in
                                                                    order to support suspend/resume of operation               */
  __OM  uint32_t  CHACHA_SW_RESET;
  __IM  uint32_t  CHACHA_POLY1305_KEY[8];       /*!< (@ 0x000003C4) Description collection: The auto-generated key
                                                                    to use in Poly1305 MAC calculation. The
                                                                    initial CHACHA_POLY1305_KEY[0] register
                                                                    holds the least significant bits [31:0]
                                                                    of the key value.                                          */
  __IOM uint32_t  CHACHA_ENDIANNESS;
  __IM  uint32_t  CHACHA_DEBUG;
} NRF_CC_CHACHA_Type;



/* =========================================================================================================================== */
/* ================                                         CC_CTL_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL CTL interface (CC_CTL_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[576];
  __OM  uint32_t  CRYPTO_CTL;
  __IM  uint32_t  RESERVED1[3];
  __IM  uint32_t  CRYPTO_BUSY;                  /*!< (@ 0x00000910) Status register for cryptographic cores engine
                                                                    activity.                                                  */
  __IM  uint32_t  RESERVED2[2];
  __IM  uint32_t  HASH_BUSY;
  __IM  uint32_t  RESERVED3[4];
  __IOM uint32_t  CONTEXT_ID;
} NRF_CC_CTL_Type;



/* =========================================================================================================================== */
/* ================                                         CC_DIN_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL Data IN interface (CC_DIN_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[768];
  __OM  uint32_t  DIN_BUFFER;                   /*!< (@ 0x00000C00) Used by CPU to write data directly to the DIN
                                                                    buffer, which is then sent to the cryptographic
                                                                    engines for processing.                                    */
  __IM  uint32_t  RESERVED1[7];
  __IM  uint32_t  DIN_DMA_MEM_BUSY;             /*!< (@ 0x00000C20) Status register for DIN DMA engine activity when
                                                                    accessing memory.                                          */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  SRC_MEM_ADDR;
  __OM  uint32_t  SRC_MEM_SIZE;                 /*!< (@ 0x00000C2C) The number of bytes to be read from memory. Writing
                                                                    to this register triggers the DMA operation.               */
  __IOM uint32_t  SRC_SRAM_ADDR;
  __OM  uint32_t  SRC_SRAM_SIZE;                /*!< (@ 0x00000C34) The number of bytes to be read from RNG SRAM.
                                                                    Writing to this register triggers the DMA
                                                                    operation.                                                 */
  __IM  uint32_t  DIN_DMA_SRAM_BUSY;            /*!< (@ 0x00000C38) Status register for DIN DMA engine activity when
                                                                    accessing RNG SRAM.                                        */
  __IOM uint32_t  DIN_DMA_SRAM_ENDIANNESS;      /*!< (@ 0x00000C3C) Configure the endianness of DIN DMA transactions
                                                                    towards RNG SRAM.                                          */
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  DIN_SW_RESET;
  __OM  uint32_t  DIN_CPU_DATA;                 /*!< (@ 0x00000C48) Specifies the number of bytes the CPU will write
                                                                    to the DIN_BUFFER, ensuring the cryptographic
                                                                    engine processes the correct amount of data.               */
  __OM  uint32_t  DIN_WRITE_ALIGN;              /*!< (@ 0x00000C4C) Indicates that the next CPU write to the DIN_BUFFER
                                                                    is the last in the sequence. This is needed
                                                                    only when the data size is NOT modulo 4
                                                                    (e.g. HASH padding).                                       */
  __IM  uint32_t  DIN_FIFO_EMPTY;               /*!< (@ 0x00000C50) Register indicating if DIN FIFO is empty and
                                                                    if more data can be accepted.                              */
  __IM  uint32_t  RESERVED4;
  __OM  uint32_t  DIN_FIFO_RESET;               /*!< (@ 0x00000C58) Reset the DIN FIFO, effectively clearing the
                                                                    FIFO for new data.                                         */
} NRF_CC_DIN_Type;



/* =========================================================================================================================== */
/* ================                                         CC_DOUT_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL Data OUT interface (CC_DOUT_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[832];
  __IM  uint32_t  DOUT_BUFFER;                  /*!< (@ 0x00000D00) Cryptographic results directly accessible by
                                                                    the CPU.                                                   */
  __IM  uint32_t  RESERVED1[7];
  __IM  uint32_t  DOUT_DMA_MEM_BUSY;            /*!< (@ 0x00000D20) Status register for DOUT DMA engine activity
                                                                    when accessing memory.                                     */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  DST_MEM_ADDR;
  __OM  uint32_t  DST_MEM_SIZE;
  __IOM uint32_t  DST_SRAM_ADDR;
  __OM  uint32_t  DST_SRAM_SIZE;
  __IM  uint32_t  DOUT_DMA_SRAM_BUSY;           /*!< (@ 0x00000D38) Status register for DOUT DMA engine activity
                                                                    when accessing RNG SRAM.                                   */
  __IOM uint32_t  DOUT_DMA_SRAM_ENDIANNESS;     /*!< (@ 0x00000D3C) Configure the endianness of DOUT DMA transactions
                                                                    towards RNG SRAM.                                          */
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  DOUT_READ_ALIGN;              /*!< (@ 0x00000D44) Indication that the next CPU read from the DOUT_BUFFER
                                                                    is the last in the sequence. This is needed
                                                                    only when the data size is NOT modulo 4
                                                                    (e.g. HASH padding).                                       */
  __IM  uint32_t  RESERVED4[2];
  __IM  uint32_t  DOUT_FIFO_EMPTY;              /*!< (@ 0x00000D50) Register indicating if DOUT FIFO is empty or
                                                                    if more data will come.                                    */
  __IM  uint32_t  RESERVED5;
  __OM  uint32_t  DOUT_SW_RESET;
} NRF_CC_DOUT_Type;



/* =========================================================================================================================== */
/* ================                                        CC_GHASH_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL GHASH engine (CC_GHASH_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[600];
  __OM  uint32_t  GHASH_SUBKEY[4];              /*!< (@ 0x00000960) Description collection: GHASH subkey value to
                                                                    use. The initial GHASH_SUBKEY[0] register
                                                                    holds the least significant bits [31:0]
                                                                    of the subkey value.                                       */
  __IOM uint32_t  GHASH_IV[4];                  /*!< (@ 0x00000970) Description collection: GHASH Initialization
                                                                    Vector (IV) to use. The initial GHASH_IV[0]
                                                                    register holds the least significant bits
                                                                    [31:0] of the IV.                                          */
  __IM  uint32_t  GHASH_BUSY;
  __OM  uint32_t  GHASH_INIT;
} NRF_CC_GHASH_Type;



/* =========================================================================================================================== */
/* ================                                         CC_HASH_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL HASH engine (CC_HASH_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[400];
  __IOM uint32_t  HASH_H[8];                    /*!< (@ 0x00000640) Description collection: HASH_H value registers.
                                                                    The initial HASH_H[0] register holds the
                                                                    least significant bits [31:0] of the value.                */
  __IM  uint32_t  RESERVED1[9];
  __OM  uint32_t  HASH_PAD_AUTO;                /*!< (@ 0x00000684) Configure the HASH engine to automatically pad
                                                                    data at the end of the DMA transfer to complete
                                                                    the digest operation.                                      */
  __IOM uint32_t  HASH_XOR_DIN;                 /*!< (@ 0x00000688) Perform an XOR operation of the DIN DMA engine
                                                                    input data being fed into the HASH engine.
                                                                    Set this register to '0' if XOR is not required.           */
  __IM  uint32_t  RESERVED2[2];
  __OM  uint32_t  HASH_INIT_STATE;
  __IM  uint32_t  RESERVED3[3];
  __OM  uint32_t  HASH_SELECT;                  /*!< (@ 0x000006A4) Select HASH or GHASH engine as the digest engine
                                                                    to use.                                                    */
  __IM  uint32_t  RESERVED4[70];
  __IOM uint32_t  HASH_CONTROL;
  __IOM uint32_t  HASH_PAD;                     /*!< (@ 0x000007C4) Enable the hardware padding feature of the HASH
                                                                    engine.                                                    */
  __IOM uint32_t  HASH_PAD_FORCE;               /*!< (@ 0x000007C8) Force the hardware padding operation to trigger
                                                                    if the input data length is zero bytes.                    */
  __IOM uint32_t  HASH_CUR_LEN_0;               /*!< (@ 0x000007CC) Bits [31:0] of the number of bytes that have
                                                                    been digested so far.                                      */
  __IOM uint32_t  HASH_CUR_LEN_1;               /*!< (@ 0x000007D0) Bits [63:32] of the number of bytes that have
                                                                    been digested so far.                                      */
  __IM  uint32_t  RESERVED5[2];
  __IM  uint32_t  HASH_HW_FLAGS;                /*!< (@ 0x000007DC) Hardware configuration of the HASH engine. Reset
                                                                    value holds the supported features.                        */
  __IM  uint32_t  RESERVED6;
  __OM  uint32_t  HASH_SW_RESET;
  __IOM uint32_t  HASH_ENDIANNESS;              /*!< (@ 0x000007E8) Configure the endianness of HASH data and padding
                                                                    generation.                                                */
} NRF_CC_HASH_Type;



/* =========================================================================================================================== */
/* ================                                       CC_HOST_RGF_S                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL HOST register interface (CC_HOST_RGF_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[640];
  __IM  uint32_t  IRR;                          /*!< (@ 0x00000A00) Interrupt request register. Each bit of this
                                                                    register holds the interrupt status of a
                                                                    single interrupt source. If corresponding
                                                                    IMR bit is unmasked, an interrupt is generated.            */
  __IOM uint32_t  IMR;                          /*!< (@ 0x00000A04) Interrupt mask register. Each bit of this register
                                                                    holds the mask of a single interrupt source.               */
  __OM  uint32_t  ICR;                          /*!< (@ 0x00000A08) Interrupt clear register. Writing a 1 bit into
                                                                    a field in this register will clear the
                                                                    corresponding bit in IRR.                                  */
  __IOM uint32_t  ENDIANNESS;                   /*!< (@ 0x00000A0C) This register defines the endianness of the Host-accessible
                                                                    registers, and can only be written once.                   */
  __IM  uint32_t  RESERVED1[5];
  __IM  uint32_t  HOST_SIGNATURE;               /*!< (@ 0x00000A24) This register holds the CRYPTOCELL subsystem
                                                                    signature. See reset value.                                */
  __IM  uint32_t  HOST_BOOT;                    /*!< (@ 0x00000A28) Hardware configuration of the CRYPTOCELL subsystem.
                                                                    Reset value holds the supported features.                  */
  __IM  uint32_t  RESERVED2[20];
  __IM  uint32_t  HOST_CC_IS_IDLE;
  __IOM uint32_t  HOST_POWERDOWN;
} NRF_CC_HOST_RGF_Type;



/* =========================================================================================================================== */
/* ================                                         CC_MISC_S                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL MISC interface (CC_MISC_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[516];
  __OM  uint32_t  AES_CLK;
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  HASH_CLK;
  __OM  uint32_t  PKA_CLK;
  __OM  uint32_t  DMA_CLK;
  __IM  uint32_t  CLK_STATUS;
  __IM  uint32_t  RESERVED2[12];
  __OM  uint32_t  CHACHA_CLK;
} NRF_CC_MISC_Type;



/* =========================================================================================================================== */
/* ================                                         CC_PKA_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL PKA engine (CC_PKA_S)
  */

typedef struct {
  __IOM uint32_t  MEMORY_MAP[32];               /*!< (@ 0x00000000) Description collection: Register for mapping
                                                                    the virtual register R[n] to a physical
                                                                    address in the PKA SRAM.                                   */
  __IOM uint32_t  OPCODE;                       /*!< (@ 0x00000080) Operation code to be executed by the PKA engine.
                                                                    Writing to this register triggers the PKA
                                                                    operation.                                                 */
  __IOM uint32_t  N_NP_T0_T1_ADDR;              /*!< (@ 0x00000084) This register defines the N, Np, T0, and T1 virtual
                                                                    register index.                                            */
  __IM  uint32_t  PKA_STATUS;
  __OM  uint32_t  PKA_SW_RESET;
  __IOM uint32_t  PKA_L[8];                     /*!< (@ 0x00000090) Description collection: This register holds the
                                                                    operands bit size.                                         */
  __IM  uint32_t  PKA_PIPE;                     /*!< (@ 0x000000B0) Status register indicating if the PKA pipeline
                                                                    is ready to receive a new OPCODE.                          */
  __IM  uint32_t  PKA_DONE;                     /*!< (@ 0x000000B4) Status register indicating if the PKA operation
                                                                    has been completed.                                        */
  __IM  uint32_t  RESERVED[3];
  __IM  uint32_t  PKA_VERSION;                  /*!< (@ 0x000000C4) PKA engine HW version. Reset value holds the
                                                                    version.                                                   */
  __IM  uint32_t  RESERVED1[3];
  __OM  uint32_t  PKA_SRAM_WADDR;               /*!< (@ 0x000000D4) Start address in PKA SRAM for subsequent write
                                                                    transactions.                                              */
  __OM  uint32_t  PKA_SRAM_WDATA;               /*!< (@ 0x000000D8) Write data to PKA SRAM. Writing to this register
                                                                    triggers a DMA transaction writing data
                                                                    into PKA SRAM. The DMA address offset is
                                                                    automatically incremented during write.                    */
  __IM  uint32_t  PKA_SRAM_RDATA;               /*!< (@ 0x000000DC) Read data from PKA SRAM. Reading from this register
                                                                    triggers a DMA transaction read data from
                                                                    PKA SRAM. The DMA address offset is automatically
                                                                    incremented during read.                                   */
  __OM  uint32_t  PKA_SRAM_WCLEAR;
  __OM  uint32_t  PKA_SRAM_RADDR;               /*!< (@ 0x000000E4) Start address in PKA SRAM for subsequent read
                                                                    transactions.                                              */
} NRF_CC_PKA_Type;



/* =========================================================================================================================== */
/* ================                                         CC_RNG_S                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL RNG engine (CC_RNG_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[64];
  __IOM uint32_t  RNG_IMR;                      /*!< (@ 0x00000100) Interrupt mask register. Each bit of this register
                                                                    holds the mask of a single interrupt source.               */
  __IM  uint32_t  RNG_ISR;                      /*!< (@ 0x00000104) Interrupt status register. Each bit of this register
                                                                    holds the interrupt status of a single interrupt
                                                                    source. If corresponding RNG_IMR bit is
                                                                    unmasked, an interrupt is generated.                       */
  __OM  uint32_t  RNG_ICR;                      /*!< (@ 0x00000108) Interrupt clear register. Writing a 1 bit into
                                                                    a field in this register will clear the
                                                                    corresponding bit in RNG_ISR.                              */
  __IOM uint32_t  TRNG_CONFIG;
  __IM  uint32_t  TRNG_VALID;                   /*!< (@ 0x00000110) This register indicates if TRNG entropy collection
                                                                    is valid.                                                  */
  __IM  uint32_t  EHR_DATA[6];                  /*!< (@ 0x00000114) Description collection: The entropy holding registers
                                                                    (EHR) hold 192-bits random data collected
                                                                    by the TRNG. The initial EHR_DATA[0] register
                                                                    holds the least significant bits [31:0]
                                                                    of the random data value.                                  */
  __IOM uint32_t  NOISE_SOURCE;                 /*!< (@ 0x0000012C) This register controls the ring oscillator circuit
                                                                    used as a noise source.                                    */
  __IOM uint32_t  SAMPLE_CNT;                   /*!< (@ 0x00000130) Sample count defining the number of CPU clock
                                                                    cycles between two consecutive noise source
                                                                    samples.                                                   */
  __IOM uint32_t  AUTOCORR_STATISTIC;           /*!< (@ 0x00000134) Statistics counter for autocorrelation test activations.
                                                                    Statistics collection is stopped if one
                                                                    of the counters reach its limit of all ones.               */
  __IOM uint32_t  TRNG_DEBUG;                   /*!< (@ 0x00000138) Debug register for the TRNG. This register is
                                                                    used to bypass TRNG tests in hardware.                     */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  RNG_SW_RESET;
  __IM  uint32_t  RESERVED2[29];
  __IM  uint32_t  RNG_BUSY;
  __OM  uint32_t  TRNG_RESET;                   /*!< (@ 0x000001BC) Reset the TRNG, including internal counter of
                                                                    collected bits and registers EHR_DATA and
                                                                    TRNG_VALID.                                                */
  __IM  uint32_t  RNG_HW_FLAGS;                 /*!< (@ 0x000001C0) Hardware configuration of RNG engine. Reset value
                                                                    holds the supported features.                              */
  __OM  uint32_t  RNG_CLK;
  __IOM uint32_t  RNG_DMA;                      /*!< (@ 0x000001C8) Writing to this register enables the RNG DMA
                                                                    engine.                                                    */
  __IOM uint32_t  RNG_DMA_ROSC_LEN;             /*!< (@ 0x000001CC) This register defines which ring oscillator length
                                                                    configuration should be used when using
                                                                    the RNG DMA engine.                                        */
  __IOM uint32_t  RNG_DMA_SRAM_ADDR;            /*!< (@ 0x000001D0) This register defines the start address in TRNG
                                                                    SRAM for the TRNG data to be collected by
                                                                    the RNG DMA engine.                                        */
  __IOM uint32_t  RNG_DMA_SAMPLES_NUM;          /*!< (@ 0x000001D4) This register defines the number of 192-bits
                                                                    samples that the RNG DMA engine collects
                                                                    per run.                                                   */
  __IOM uint32_t  RNG_WATCHDOG_VAL;             /*!< (@ 0x000001D8) This register defines the maximum number of CPU
                                                                    clock cycles per TRNG collection of 192-bits
                                                                    samples. If the number of cycles for a collection
                                                                    exceeds this threshold the WATCHDOG interrupt
                                                                    is triggered.                                              */
  __IM  uint32_t  RNG_DMA_BUSY;
} NRF_CC_RNG_Type;



/* =========================================================================================================================== */
/* ================                                       CC_RNG_SRAM_S                                       ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL RNG SRAM interface (CC_RNG_SRAM_S)
  */

typedef struct {
  __IM  uint32_t  RESERVED[960];
  __IOM uint32_t  SRAM_DATA;
  __OM  uint32_t  SRAM_ADDR;                    /*!< (@ 0x00000F04) First address given to RNG SRAM DMA for read/write
                                                                    transactions from/to RNG SRAM.                             */
  __IM  uint32_t  SRAM_DATA_READY;              /*!< (@ 0x00000F08) RNG SRAM DMA engine is ready to read/write from/to
                                                                    RNG SRAM.                                                  */
} NRF_CC_RNG_SRAM_Type;



/* =========================================================================================================================== */
/* ================                                          VMC_NS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Volatile Memory controller 0 (VMC_NS)
  */

typedef struct {
  __IM  uint32_t  RESERVED[384];
  __IOM VMC_RAM_Type RAM[8];
} NRF_VMC_Type;


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define NRF_CACHEDATA_S_BASE        0x00F00000UL
#define NRF_CACHEINFO_S_BASE        0x00F08000UL
#define NRF_FICR_S_BASE             0x00FF0000UL
#define NRF_UICR_S_BASE             0x00FF8000UL
#define NRF_CTI_S_BASE              0xE0042000UL
#define NRF_TAD_S_BASE              0xE0080000UL
#define NRF_DCNF_NS_BASE            0x40000000UL
#define NRF_FPU_NS_BASE             0x40000000UL
#define NRF_DCNF_S_BASE             0x50000000UL
#define NRF_FPU_S_BASE              0x50000000UL
#define NRF_CACHE_S_BASE            0x50001000UL
#define NRF_SPU_S_BASE              0x50003000UL
#define NRF_OSCILLATORS_NS_BASE     0x40004000UL
#define NRF_REGULATORS_NS_BASE      0x40004000UL
#define NRF_OSCILLATORS_S_BASE      0x50004000UL
#define NRF_REGULATORS_S_BASE       0x50004000UL
#define NRF_CLOCK_NS_BASE           0x40005000UL
#define NRF_POWER_NS_BASE           0x40005000UL
#define NRF_RESET_NS_BASE           0x40005000UL
#define NRF_CLOCK_S_BASE            0x50005000UL
#define NRF_POWER_S_BASE            0x50005000UL
#define NRF_RESET_S_BASE            0x50005000UL
#define NRF_CTRLAP_NS_BASE          0x40006000UL
#define NRF_CTRLAP_S_BASE           0x50006000UL
#define NRF_SPIM0_NS_BASE           0x40008000UL
#define NRF_SPIS0_NS_BASE           0x40008000UL
#define NRF_TWIM0_NS_BASE           0x40008000UL
#define NRF_TWIS0_NS_BASE           0x40008000UL
#define NRF_UARTE0_NS_BASE          0x40008000UL
#define NRF_SPIM0_S_BASE            0x50008000UL
#define NRF_SPIS0_S_BASE            0x50008000UL
#define NRF_TWIM0_S_BASE            0x50008000UL
#define NRF_TWIS0_S_BASE            0x50008000UL
#define NRF_UARTE0_S_BASE           0x50008000UL
#define NRF_SPIM1_NS_BASE           0x40009000UL
#define NRF_SPIS1_NS_BASE           0x40009000UL
#define NRF_TWIM1_NS_BASE           0x40009000UL
#define NRF_TWIS1_NS_BASE           0x40009000UL
#define NRF_UARTE1_NS_BASE          0x40009000UL
#define NRF_SPIM1_S_BASE            0x50009000UL
#define NRF_SPIS1_S_BASE            0x50009000UL
#define NRF_TWIM1_S_BASE            0x50009000UL
#define NRF_TWIS1_S_BASE            0x50009000UL
#define NRF_UARTE1_S_BASE           0x50009000UL
#define NRF_SPIM4_NS_BASE           0x4000A000UL
#define NRF_SPIM4_S_BASE            0x5000A000UL
#define NRF_SPIM2_NS_BASE           0x4000B000UL
#define NRF_SPIS2_NS_BASE           0x4000B000UL
#define NRF_TWIM2_NS_BASE           0x4000B000UL
#define NRF_TWIS2_NS_BASE           0x4000B000UL
#define NRF_UARTE2_NS_BASE          0x4000B000UL
#define NRF_SPIM2_S_BASE            0x5000B000UL
#define NRF_SPIS2_S_BASE            0x5000B000UL
#define NRF_TWIM2_S_BASE            0x5000B000UL
#define NRF_TWIS2_S_BASE            0x5000B000UL
#define NRF_UARTE2_S_BASE           0x5000B000UL
#define NRF_SPIM3_NS_BASE           0x4000C000UL
#define NRF_SPIS3_NS_BASE           0x4000C000UL
#define NRF_TWIM3_NS_BASE           0x4000C000UL
#define NRF_TWIS3_NS_BASE           0x4000C000UL
#define NRF_UARTE3_NS_BASE          0x4000C000UL
#define NRF_SPIM3_S_BASE            0x5000C000UL
#define NRF_SPIS3_S_BASE            0x5000C000UL
#define NRF_TWIM3_S_BASE            0x5000C000UL
#define NRF_TWIS3_S_BASE            0x5000C000UL
#define NRF_UARTE3_S_BASE           0x5000C000UL
#define NRF_GPIOTE0_S_BASE          0x5000D000UL
#define NRF_SAADC_NS_BASE           0x4000E000UL
#define NRF_SAADC_S_BASE            0x5000E000UL
#define NRF_TIMER0_NS_BASE          0x4000F000UL
#define NRF_TIMER0_S_BASE           0x5000F000UL
#define NRF_TIMER1_NS_BASE          0x40010000UL
#define NRF_TIMER1_S_BASE           0x50010000UL
#define NRF_TIMER2_NS_BASE          0x40011000UL
#define NRF_TIMER2_S_BASE           0x50011000UL
#define NRF_RTC0_NS_BASE            0x40014000UL
#define NRF_RTC0_S_BASE             0x50014000UL
#define NRF_RTC1_NS_BASE            0x40015000UL
#define NRF_RTC1_S_BASE             0x50015000UL
#define NRF_DPPIC_NS_BASE           0x40017000UL
#define NRF_DPPIC_S_BASE            0x50017000UL
#define NRF_WDT0_NS_BASE            0x40018000UL
#define NRF_WDT0_S_BASE             0x50018000UL
#define NRF_WDT1_NS_BASE            0x40019000UL
#define NRF_WDT1_S_BASE             0x50019000UL
#define NRF_COMP_NS_BASE            0x4001A000UL
#define NRF_LPCOMP_NS_BASE          0x4001A000UL
#define NRF_COMP_S_BASE             0x5001A000UL
#define NRF_LPCOMP_S_BASE           0x5001A000UL
#define NRF_EGU0_NS_BASE            0x4001B000UL
#define NRF_EGU0_S_BASE             0x5001B000UL
#define NRF_EGU1_NS_BASE            0x4001C000UL
#define NRF_EGU1_S_BASE             0x5001C000UL
#define NRF_EGU2_NS_BASE            0x4001D000UL
#define NRF_EGU2_S_BASE             0x5001D000UL
#define NRF_EGU3_NS_BASE            0x4001E000UL
#define NRF_EGU3_S_BASE             0x5001E000UL
#define NRF_EGU4_NS_BASE            0x4001F000UL
#define NRF_EGU4_S_BASE             0x5001F000UL
#define NRF_EGU5_NS_BASE            0x40020000UL
#define NRF_EGU5_S_BASE             0x50020000UL
#define NRF_PWM0_NS_BASE            0x40021000UL
#define NRF_PWM0_S_BASE             0x50021000UL
#define NRF_PWM1_NS_BASE            0x40022000UL
#define NRF_PWM1_S_BASE             0x50022000UL
#define NRF_PWM2_NS_BASE            0x40023000UL
#define NRF_PWM2_S_BASE             0x50023000UL
#define NRF_PWM3_NS_BASE            0x40024000UL
#define NRF_PWM3_S_BASE             0x50024000UL
#define NRF_PDM0_NS_BASE            0x40026000UL
#define NRF_PDM0_S_BASE             0x50026000UL
#define NRF_I2S0_NS_BASE            0x40028000UL
#define NRF_I2S0_S_BASE             0x50028000UL
#define NRF_IPC_NS_BASE             0x4002A000UL
#define NRF_IPC_S_BASE              0x5002A000UL
#define NRF_QSPI_NS_BASE            0x4002B000UL
#define NRF_QSPI_S_BASE             0x5002B000UL
#define NRF_NFCT_NS_BASE            0x4002D000UL
#define NRF_NFCT_S_BASE             0x5002D000UL
#define NRF_GPIOTE1_NS_BASE         0x4002F000UL
#define NRF_MUTEX_NS_BASE           0x40030000UL
#define NRF_MUTEX_S_BASE            0x50030000UL
#define NRF_QDEC0_NS_BASE           0x40033000UL
#define NRF_QDEC0_S_BASE            0x50033000UL
#define NRF_QDEC1_NS_BASE           0x40034000UL
#define NRF_QDEC1_S_BASE            0x50034000UL
#define NRF_USBD_NS_BASE            0x40036000UL
#define NRF_USBD_S_BASE             0x50036000UL
#define NRF_USBREGULATOR_NS_BASE    0x40037000UL
#define NRF_USBREGULATOR_S_BASE     0x50037000UL
#define NRF_KMU_NS_BASE             0x40039000UL
#define NRF_NVMC_NS_BASE            0x40039000UL
#define NRF_KMU_S_BASE              0x50039000UL
#define NRF_NVMC_S_BASE             0x50039000UL
#define NRF_P0_NS_BASE              0x40842500UL
#define NRF_P1_NS_BASE              0x40842800UL
#define NRF_P0_S_BASE               0x50842500UL
#define NRF_P1_S_BASE               0x50842800UL
#define NRF_CRYPTOCELL_S_BASE       0x50844000UL
#define NRF_CC_AES_S_BASE           0x50845000UL
#define NRF_CC_AHB_S_BASE           0x50845000UL
#define NRF_CC_AO_S_BASE            0x50845000UL
#define NRF_CC_CHACHA_S_BASE        0x50845000UL
#define NRF_CC_CTL_S_BASE           0x50845000UL
#define NRF_CC_DIN_S_BASE           0x50845000UL
#define NRF_CC_DOUT_S_BASE          0x50845000UL
#define NRF_CC_GHASH_S_BASE         0x50845000UL
#define NRF_CC_HASH_S_BASE          0x50845000UL
#define NRF_CC_HOST_RGF_S_BASE      0x50845000UL
#define NRF_CC_MISC_S_BASE          0x50845000UL
#define NRF_CC_PKA_S_BASE           0x50845000UL
#define NRF_CC_RNG_S_BASE           0x50845000UL
#define NRF_CC_RNG_SRAM_S_BASE      0x50845000UL
#define NRF_VMC_NS_BASE             0x40081000UL
#define NRF_VMC_S_BASE              0x50081000UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define NRF_CACHEDATA_S             ((NRF_CACHEDATA_Type*)     NRF_CACHEDATA_S_BASE)
#define NRF_CACHEINFO_S             ((NRF_CACHEINFO_Type*)     NRF_CACHEINFO_S_BASE)
#define NRF_FICR_S                  ((NRF_FICR_Type*)          NRF_FICR_S_BASE)
#define NRF_UICR_S                  ((NRF_UICR_Type*)          NRF_UICR_S_BASE)
#define NRF_CTI_S                   ((NRF_CTI_Type*)           NRF_CTI_S_BASE)
#define NRF_TAD_S                   ((NRF_TAD_Type*)           NRF_TAD_S_BASE)
#define NRF_DCNF_NS                 ((NRF_DCNF_Type*)          NRF_DCNF_NS_BASE)
#define NRF_FPU_NS                  ((NRF_FPU_Type*)           NRF_FPU_NS_BASE)
#define NRF_DCNF_S                  ((NRF_DCNF_Type*)          NRF_DCNF_S_BASE)
#define NRF_FPU_S                   ((NRF_FPU_Type*)           NRF_FPU_S_BASE)
#define NRF_CACHE_S                 ((NRF_CACHE_Type*)         NRF_CACHE_S_BASE)
#define NRF_SPU_S                   ((NRF_SPU_Type*)           NRF_SPU_S_BASE)
#define NRF_OSCILLATORS_NS          ((NRF_OSCILLATORS_Type*)   NRF_OSCILLATORS_NS_BASE)
#define NRF_REGULATORS_NS           ((NRF_REGULATORS_Type*)    NRF_REGULATORS_NS_BASE)
#define NRF_OSCILLATORS_S           ((NRF_OSCILLATORS_Type*)   NRF_OSCILLATORS_S_BASE)
#define NRF_REGULATORS_S            ((NRF_REGULATORS_Type*)    NRF_REGULATORS_S_BASE)
#define NRF_CLOCK_NS                ((NRF_CLOCK_Type*)         NRF_CLOCK_NS_BASE)
#define NRF_POWER_NS                ((NRF_POWER_Type*)         NRF_POWER_NS_BASE)
#define NRF_RESET_NS                ((NRF_RESET_Type*)         NRF_RESET_NS_BASE)
#define NRF_CLOCK_S                 ((NRF_CLOCK_Type*)         NRF_CLOCK_S_BASE)
#define NRF_POWER_S                 ((NRF_POWER_Type*)         NRF_POWER_S_BASE)
#define NRF_RESET_S                 ((NRF_RESET_Type*)         NRF_RESET_S_BASE)
#define NRF_CTRLAP_NS               ((NRF_CTRLAPPERI_Type*)    NRF_CTRLAP_NS_BASE)
#define NRF_CTRLAP_S                ((NRF_CTRLAPPERI_Type*)    NRF_CTRLAP_S_BASE)
#define NRF_SPIM0_NS                ((NRF_SPIM_Type*)          NRF_SPIM0_NS_BASE)
#define NRF_SPIS0_NS                ((NRF_SPIS_Type*)          NRF_SPIS0_NS_BASE)
#define NRF_TWIM0_NS                ((NRF_TWIM_Type*)          NRF_TWIM0_NS_BASE)
#define NRF_TWIS0_NS                ((NRF_TWIS_Type*)          NRF_TWIS0_NS_BASE)
#define NRF_UARTE0_NS               ((NRF_UARTE_Type*)         NRF_UARTE0_NS_BASE)
#define NRF_SPIM0_S                 ((NRF_SPIM_Type*)          NRF_SPIM0_S_BASE)
#define NRF_SPIS0_S                 ((NRF_SPIS_Type*)          NRF_SPIS0_S_BASE)
#define NRF_TWIM0_S                 ((NRF_TWIM_Type*)          NRF_TWIM0_S_BASE)
#define NRF_TWIS0_S                 ((NRF_TWIS_Type*)          NRF_TWIS0_S_BASE)
#define NRF_UARTE0_S                ((NRF_UARTE_Type*)         NRF_UARTE0_S_BASE)
#define NRF_SPIM1_NS                ((NRF_SPIM_Type*)          NRF_SPIM1_NS_BASE)
#define NRF_SPIS1_NS                ((NRF_SPIS_Type*)          NRF_SPIS1_NS_BASE)
#define NRF_TWIM1_NS                ((NRF_TWIM_Type*)          NRF_TWIM1_NS_BASE)
#define NRF_TWIS1_NS                ((NRF_TWIS_Type*)          NRF_TWIS1_NS_BASE)
#define NRF_UARTE1_NS               ((NRF_UARTE_Type*)         NRF_UARTE1_NS_BASE)
#define NRF_SPIM1_S                 ((NRF_SPIM_Type*)          NRF_SPIM1_S_BASE)
#define NRF_SPIS1_S                 ((NRF_SPIS_Type*)          NRF_SPIS1_S_BASE)
#define NRF_TWIM1_S                 ((NRF_TWIM_Type*)          NRF_TWIM1_S_BASE)
#define NRF_TWIS1_S                 ((NRF_TWIS_Type*)          NRF_TWIS1_S_BASE)
#define NRF_UARTE1_S                ((NRF_UARTE_Type*)         NRF_UARTE1_S_BASE)
#define NRF_SPIM4_NS                ((NRF_SPIM_Type*)          NRF_SPIM4_NS_BASE)
#define NRF_SPIM4_S                 ((NRF_SPIM_Type*)          NRF_SPIM4_S_BASE)
#define NRF_SPIM2_NS                ((NRF_SPIM_Type*)          NRF_SPIM2_NS_BASE)
#define NRF_SPIS2_NS                ((NRF_SPIS_Type*)          NRF_SPIS2_NS_BASE)
#define NRF_TWIM2_NS                ((NRF_TWIM_Type*)          NRF_TWIM2_NS_BASE)
#define NRF_TWIS2_NS                ((NRF_TWIS_Type*)          NRF_TWIS2_NS_BASE)
#define NRF_UARTE2_NS               ((NRF_UARTE_Type*)         NRF_UARTE2_NS_BASE)
#define NRF_SPIM2_S                 ((NRF_SPIM_Type*)          NRF_SPIM2_S_BASE)
#define NRF_SPIS2_S                 ((NRF_SPIS_Type*)          NRF_SPIS2_S_BASE)
#define NRF_TWIM2_S                 ((NRF_TWIM_Type*)          NRF_TWIM2_S_BASE)
#define NRF_TWIS2_S                 ((NRF_TWIS_Type*)          NRF_TWIS2_S_BASE)
#define NRF_UARTE2_S                ((NRF_UARTE_Type*)         NRF_UARTE2_S_BASE)
#define NRF_SPIM3_NS                ((NRF_SPIM_Type*)          NRF_SPIM3_NS_BASE)
#define NRF_SPIS3_NS                ((NRF_SPIS_Type*)          NRF_SPIS3_NS_BASE)
#define NRF_TWIM3_NS                ((NRF_TWIM_Type*)          NRF_TWIM3_NS_BASE)
#define NRF_TWIS3_NS                ((NRF_TWIS_Type*)          NRF_TWIS3_NS_BASE)
#define NRF_UARTE3_NS               ((NRF_UARTE_Type*)         NRF_UARTE3_NS_BASE)
#define NRF_SPIM3_S                 ((NRF_SPIM_Type*)          NRF_SPIM3_S_BASE)
#define NRF_SPIS3_S                 ((NRF_SPIS_Type*)          NRF_SPIS3_S_BASE)
#define NRF_TWIM3_S                 ((NRF_TWIM_Type*)          NRF_TWIM3_S_BASE)
#define NRF_TWIS3_S                 ((NRF_TWIS_Type*)          NRF_TWIS3_S_BASE)
#define NRF_UARTE3_S                ((NRF_UARTE_Type*)         NRF_UARTE3_S_BASE)
#define NRF_GPIOTE0_S               ((NRF_GPIOTE_Type*)        NRF_GPIOTE0_S_BASE)
#define NRF_SAADC_NS                ((NRF_SAADC_Type*)         NRF_SAADC_NS_BASE)
#define NRF_SAADC_S                 ((NRF_SAADC_Type*)         NRF_SAADC_S_BASE)
#define NRF_TIMER0_NS               ((NRF_TIMER_Type*)         NRF_TIMER0_NS_BASE)
#define NRF_TIMER0_S                ((NRF_TIMER_Type*)         NRF_TIMER0_S_BASE)
#define NRF_TIMER1_NS               ((NRF_TIMER_Type*)         NRF_TIMER1_NS_BASE)
#define NRF_TIMER1_S                ((NRF_TIMER_Type*)         NRF_TIMER1_S_BASE)
#define NRF_TIMER2_NS               ((NRF_TIMER_Type*)         NRF_TIMER2_NS_BASE)
#define NRF_TIMER2_S                ((NRF_TIMER_Type*)         NRF_TIMER2_S_BASE)
#define NRF_RTC0_NS                 ((NRF_RTC_Type*)           NRF_RTC0_NS_BASE)
#define NRF_RTC0_S                  ((NRF_RTC_Type*)           NRF_RTC0_S_BASE)
#define NRF_RTC1_NS                 ((NRF_RTC_Type*)           NRF_RTC1_NS_BASE)
#define NRF_RTC1_S                  ((NRF_RTC_Type*)           NRF_RTC1_S_BASE)
#define NRF_DPPIC_NS                ((NRF_DPPIC_Type*)         NRF_DPPIC_NS_BASE)
#define NRF_DPPIC_S                 ((NRF_DPPIC_Type*)         NRF_DPPIC_S_BASE)
#define NRF_WDT0_NS                 ((NRF_WDT_Type*)           NRF_WDT0_NS_BASE)
#define NRF_WDT0_S                  ((NRF_WDT_Type*)           NRF_WDT0_S_BASE)
#define NRF_WDT1_NS                 ((NRF_WDT_Type*)           NRF_WDT1_NS_BASE)
#define NRF_WDT1_S                  ((NRF_WDT_Type*)           NRF_WDT1_S_BASE)
#define NRF_COMP_NS                 ((NRF_COMP_Type*)          NRF_COMP_NS_BASE)
#define NRF_LPCOMP_NS               ((NRF_LPCOMP_Type*)        NRF_LPCOMP_NS_BASE)
#define NRF_COMP_S                  ((NRF_COMP_Type*)          NRF_COMP_S_BASE)
#define NRF_LPCOMP_S                ((NRF_LPCOMP_Type*)        NRF_LPCOMP_S_BASE)
#define NRF_EGU0_NS                 ((NRF_EGU_Type*)           NRF_EGU0_NS_BASE)
#define NRF_EGU0_S                  ((NRF_EGU_Type*)           NRF_EGU0_S_BASE)
#define NRF_EGU1_NS                 ((NRF_EGU_Type*)           NRF_EGU1_NS_BASE)
#define NRF_EGU1_S                  ((NRF_EGU_Type*)           NRF_EGU1_S_BASE)
#define NRF_EGU2_NS                 ((NRF_EGU_Type*)           NRF_EGU2_NS_BASE)
#define NRF_EGU2_S                  ((NRF_EGU_Type*)           NRF_EGU2_S_BASE)
#define NRF_EGU3_NS                 ((NRF_EGU_Type*)           NRF_EGU3_NS_BASE)
#define NRF_EGU3_S                  ((NRF_EGU_Type*)           NRF_EGU3_S_BASE)
#define NRF_EGU4_NS                 ((NRF_EGU_Type*)           NRF_EGU4_NS_BASE)
#define NRF_EGU4_S                  ((NRF_EGU_Type*)           NRF_EGU4_S_BASE)
#define NRF_EGU5_NS                 ((NRF_EGU_Type*)           NRF_EGU5_NS_BASE)
#define NRF_EGU5_S                  ((NRF_EGU_Type*)           NRF_EGU5_S_BASE)
#define NRF_PWM0_NS                 ((NRF_PWM_Type*)           NRF_PWM0_NS_BASE)
#define NRF_PWM0_S                  ((NRF_PWM_Type*)           NRF_PWM0_S_BASE)
#define NRF_PWM1_NS                 ((NRF_PWM_Type*)           NRF_PWM1_NS_BASE)
#define NRF_PWM1_S                  ((NRF_PWM_Type*)           NRF_PWM1_S_BASE)
#define NRF_PWM2_NS                 ((NRF_PWM_Type*)           NRF_PWM2_NS_BASE)
#define NRF_PWM2_S                  ((NRF_PWM_Type*)           NRF_PWM2_S_BASE)
#define NRF_PWM3_NS                 ((NRF_PWM_Type*)           NRF_PWM3_NS_BASE)
#define NRF_PWM3_S                  ((NRF_PWM_Type*)           NRF_PWM3_S_BASE)
#define NRF_PDM0_NS                 ((NRF_PDM_Type*)           NRF_PDM0_NS_BASE)
#define NRF_PDM0_S                  ((NRF_PDM_Type*)           NRF_PDM0_S_BASE)
#define NRF_I2S0_NS                 ((NRF_I2S_Type*)           NRF_I2S0_NS_BASE)
#define NRF_I2S0_S                  ((NRF_I2S_Type*)           NRF_I2S0_S_BASE)
#define NRF_IPC_NS                  ((NRF_IPC_Type*)           NRF_IPC_NS_BASE)
#define NRF_IPC_S                   ((NRF_IPC_Type*)           NRF_IPC_S_BASE)
#define NRF_QSPI_NS                 ((NRF_QSPI_Type*)          NRF_QSPI_NS_BASE)
#define NRF_QSPI_S                  ((NRF_QSPI_Type*)          NRF_QSPI_S_BASE)
#define NRF_NFCT_NS                 ((NRF_NFCT_Type*)          NRF_NFCT_NS_BASE)
#define NRF_NFCT_S                  ((NRF_NFCT_Type*)          NRF_NFCT_S_BASE)
#define NRF_GPIOTE1_NS              ((NRF_GPIOTE_Type*)        NRF_GPIOTE1_NS_BASE)
#define NRF_MUTEX_NS                ((NRF_MUTEX_Type*)         NRF_MUTEX_NS_BASE)
#define NRF_MUTEX_S                 ((NRF_MUTEX_Type*)         NRF_MUTEX_S_BASE)
#define NRF_QDEC0_NS                ((NRF_QDEC_Type*)          NRF_QDEC0_NS_BASE)
#define NRF_QDEC0_S                 ((NRF_QDEC_Type*)          NRF_QDEC0_S_BASE)
#define NRF_QDEC1_NS                ((NRF_QDEC_Type*)          NRF_QDEC1_NS_BASE)
#define NRF_QDEC1_S                 ((NRF_QDEC_Type*)          NRF_QDEC1_S_BASE)
#define NRF_USBD_NS                 ((NRF_USBD_Type*)          NRF_USBD_NS_BASE)
#define NRF_USBD_S                  ((NRF_USBD_Type*)          NRF_USBD_S_BASE)
#define NRF_USBREGULATOR_NS         ((NRF_USBREG_Type*)        NRF_USBREGULATOR_NS_BASE)
#define NRF_USBREGULATOR_S          ((NRF_USBREG_Type*)        NRF_USBREGULATOR_S_BASE)
#define NRF_KMU_NS                  ((NRF_KMU_Type*)           NRF_KMU_NS_BASE)
#define NRF_NVMC_NS                 ((NRF_NVMC_Type*)          NRF_NVMC_NS_BASE)
#define NRF_KMU_S                   ((NRF_KMU_Type*)           NRF_KMU_S_BASE)
#define NRF_NVMC_S                  ((NRF_NVMC_Type*)          NRF_NVMC_S_BASE)
#define NRF_P0_NS                   ((NRF_GPIO_Type*)          NRF_P0_NS_BASE)
#define NRF_P1_NS                   ((NRF_GPIO_Type*)          NRF_P1_NS_BASE)
#define NRF_P0_S                    ((NRF_GPIO_Type*)          NRF_P0_S_BASE)
#define NRF_P1_S                    ((NRF_GPIO_Type*)          NRF_P1_S_BASE)
#define NRF_CRYPTOCELL_S            ((NRF_CRYPTOCELL_Type*)    NRF_CRYPTOCELL_S_BASE)
#define NRF_CC_AES_S                ((NRF_CC_AES_Type*)        NRF_CC_AES_S_BASE)
#define NRF_CC_AHB_S                ((NRF_CC_AHB_Type*)        NRF_CC_AHB_S_BASE)
#define NRF_CC_AO_S                 ((NRF_CC_AO_Type*)         NRF_CC_AO_S_BASE)
#define NRF_CC_CHACHA_S             ((NRF_CC_CHACHA_Type*)     NRF_CC_CHACHA_S_BASE)
#define NRF_CC_CTL_S                ((NRF_CC_CTL_Type*)        NRF_CC_CTL_S_BASE)
#define NRF_CC_DIN_S                ((NRF_CC_DIN_Type*)        NRF_CC_DIN_S_BASE)
#define NRF_CC_DOUT_S               ((NRF_CC_DOUT_Type*)       NRF_CC_DOUT_S_BASE)
#define NRF_CC_GHASH_S              ((NRF_CC_GHASH_Type*)      NRF_CC_GHASH_S_BASE)
#define NRF_CC_HASH_S               ((NRF_CC_HASH_Type*)       NRF_CC_HASH_S_BASE)
#define NRF_CC_HOST_RGF_S           ((NRF_CC_HOST_RGF_Type*)   NRF_CC_HOST_RGF_S_BASE)
#define NRF_CC_MISC_S               ((NRF_CC_MISC_Type*)       NRF_CC_MISC_S_BASE)
#define NRF_CC_PKA_S                ((NRF_CC_PKA_Type*)        NRF_CC_PKA_S_BASE)
#define NRF_CC_RNG_S                ((NRF_CC_RNG_Type*)        NRF_CC_RNG_S_BASE)
#define NRF_CC_RNG_SRAM_S           ((NRF_CC_RNG_SRAM_Type*)   NRF_CC_RNG_SRAM_S_BASE)
#define NRF_VMC_NS                  ((NRF_VMC_Type*)           NRF_VMC_NS_BASE)
#define NRF_VMC_S                   ((NRF_VMC_Type*)           NRF_VMC_S_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


#ifdef __cplusplus
}
#endif

#endif /* NRF5340_APPLICATION_H */


/** @} */ /* End of group nrf5340_application */

/** @} */ /* End of group Nordic Semiconductor */
