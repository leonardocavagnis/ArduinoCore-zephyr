/*
Copyright (c) 2010 - 2025, Nordic Semiconductor ASA All rights reserved.

SPDX-License-Identifier: BSD-3-Clause

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

3. Neither the name of Nordic Semiconductor ASA nor the names of its
   contributors may be used to endorse or promote products derived from this
   software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY, AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
 *
 * @file     nrf52840.h
 * @brief    CMSIS HeaderFile
 * @version  1
 * @date     12. February 2025
 * @note     Generated by SVDConv V3.3.35 on Wednesday, 12.02.2025 14:52:28
 *           from File 'nrf52840.svd',
 *           last modified on Wednesday, 12.02.2025 13:51:19
 */



/** @addtogroup Nordic Semiconductor
  * @{
  */


/** @addtogroup nrf52840
  * @{
  */


#ifndef NRF52840_H
#define NRF52840_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M4 Specific Interrupt Numbers  ======================================== */
  Reset_IRQn                = -15,
  NonMaskableInt_IRQn       = -14,
  HardFault_IRQn            = -13,
  MemoryManagement_IRQn     = -12,              /*!< -12  Memory Management, MPU mismatch, including Access Violation
                                                     and No Match                                                              */
  BusFault_IRQn             = -11,              /*!< -11  Bus Fault, Pre-Fetch-, Memory Access Fault, other address/memory
                                                     related Fault                                                             */
  UsageFault_IRQn           = -10,
  SVCall_IRQn               =  -5,
  DebugMonitor_IRQn         =  -4,
  PendSV_IRQn               =  -2,
  SysTick_IRQn              =  -1,
/* ==========================================  nrf52840 Specific Interrupt Numbers  ========================================== */
  CLOCK_POWER_IRQn          =   0,
  RADIO_IRQn                =   1,
  UART0_UARTE0_IRQn         =   2,
  SPI0_SPIM0_SPIS0_TWI0_TWIM0_TWIS0_IRQn=   3,
  SPI1_SPIM1_SPIS1_TWI1_TWIM1_TWIS1_IRQn=   4,
  NFCT_IRQn                 =   5,
  GPIOTE_IRQn               =   6,
  SAADC_IRQn                =   7,
  TIMER0_IRQn               =   8,
  TIMER1_IRQn               =   9,
  TIMER2_IRQn               =  10,
  RTC0_IRQn                 =  11,
  TEMP_IRQn                 =  12,
  RNG_IRQn                  =  13,
  ECB_IRQn                  =  14,
  AAR_CCM_IRQn              =  15,
  WDT_IRQn                  =  16,
  RTC1_IRQn                 =  17,
  QDEC_IRQn                 =  18,
  COMP_LPCOMP_IRQn          =  19,
  EGU0_SWI0_IRQn            =  20,
  EGU1_SWI1_IRQn            =  21,
  EGU2_SWI2_IRQn            =  22,
  EGU3_SWI3_IRQn            =  23,
  EGU4_SWI4_IRQn            =  24,
  EGU5_SWI5_IRQn            =  25,
  TIMER3_IRQn               =  26,
  TIMER4_IRQn               =  27,
  PWM0_IRQn                 =  28,
  PDM_IRQn                  =  29,
  MWU_IRQn                  =  32,
  PWM1_IRQn                 =  33,
  PWM2_IRQn                 =  34,
  SPI2_SPIM2_SPIS2_IRQn     =  35,
  RTC2_IRQn                 =  36,
  I2S_IRQn                  =  37,
  FPU_IRQn                  =  38,
  USBD_IRQn                 =  39,
  UARTE1_IRQn               =  40,
  QSPI_IRQn                 =  41,
  CRYPTOCELL_IRQn           =  42,
  PWM3_IRQn                 =  45,
  SPIM3_IRQn                =  47
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ===========================  Configuration of the ARM Cortex-M4 Processor and Core Peripherals  =========================== */
#define __CM4_REV                 0x0001U
#define __INTERRUPTS_MAX                   112
#define __DSP_PRESENT                  1
#define __VTOR_PRESENT                 1
#define __NVIC_PRIO_BITS               3
#define __Vendor_SysTickConfig         0
#define __MPU_PRESENT                  1
#define __FPU_PRESENT                  1
#define __SAUREGION_PRESENT            0


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm4.h"
#include "system_nrf52840.h"

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* =========================================================================================================================== */
/* ================                              Device Specific Cluster Section                              ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_clusters
  * @{
  */


/**
  * @brief FICR_INFO [INFO] (Device info)
  */
typedef struct {
  __IM  uint32_t  PART;
  __IM  uint32_t  VARIANT;                      /*!< (@ 0x00000004) Build code, last two letters of Package Variant
                                                                    and first two characters of Build Code,
                                                                    encoded in ASCII.                                          */
  __IM  uint32_t  PACKAGE;
  __IM  uint32_t  RAM;
  __IM  uint32_t  FLASH;
} FICR_INFO_Type;


/**
  * @brief FICR_TEMP [TEMP] (Registers storing factory TEMP module linearization coefficients)
  */
typedef struct {
  __IM  uint32_t  A0;
  __IM  uint32_t  A1;
  __IM  uint32_t  A2;
  __IM  uint32_t  A3;
  __IM  uint32_t  A4;
  __IM  uint32_t  A5;
  __IM  uint32_t  B0;
  __IM  uint32_t  B1;
  __IM  uint32_t  B2;
  __IM  uint32_t  B3;
  __IM  uint32_t  B4;
  __IM  uint32_t  B5;
  __IM  uint32_t  T0;
  __IM  uint32_t  T1;
  __IM  uint32_t  T2;
  __IM  uint32_t  T3;
  __IM  uint32_t  T4;
} FICR_TEMP_Type;


/**
  * @brief FICR_NFC [NFC] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  TAGHEADER0;                   /*!< (@ 0x00000000) Default header for NFC tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST, and NFCID1_LAST.                          */
  __IM  uint32_t  TAGHEADER1;                   /*!< (@ 0x00000004) Default header for NFC tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST, and NFCID1_LAST.                          */
  __IM  uint32_t  TAGHEADER2;                   /*!< (@ 0x00000008) Default header for NFC tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST, and NFCID1_LAST.                          */
  __IM  uint32_t  TAGHEADER3;                   /*!< (@ 0x0000000C) Default header for NFC tag. Software can read
                                                                    these values to populate NFCID1_3RD_LAST,
                                                                    NFCID1_2ND_LAST, and NFCID1_LAST.                          */
} FICR_NFC_Type;


/**
  * @brief FICR_TRNG90B [TRNG90B] (NIST800-90B RNG calibration data)
  */
typedef struct {
  __IM  uint32_t  BYTES;
  __IM  uint32_t  RCCUTOFF;
  __IM  uint32_t  APCUTOFF;
  __IM  uint32_t  STARTUP;
  __IM  uint32_t  ROSC1;
  __IM  uint32_t  ROSC2;
  __IM  uint32_t  ROSC3;
  __IM  uint32_t  ROSC4;
} FICR_TRNG90B_Type;


/**
  * @brief POWER_RAM [RAM] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  POWER;
  __OM  uint32_t  POWERSET;
  __OM  uint32_t  POWERCLR;                     /*!< (@ 0x00000008) Description cluster: RAMn power control clear
                                                                    register                                                   */
  __IM  uint32_t  RESERVED;
} POWER_RAM_Type;


/**
  * @brief UART_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RTS;
  __IOM uint32_t  TXD;
  __IOM uint32_t  CTS;
  __IOM uint32_t  RXD;
} UART_PSEL_Type;


/**
  * @brief UARTE_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RTS;
  __IOM uint32_t  TXD;
  __IOM uint32_t  CTS;
  __IOM uint32_t  RXD;
} UARTE_PSEL_Type;


/**
  * @brief UARTE_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
} UARTE_RXD_Type;


/**
  * @brief UARTE_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
} UARTE_TXD_Type;


/**
  * @brief SPI_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;
  __IOM uint32_t  MOSI;
  __IOM uint32_t  MISO;
} SPI_PSEL_Type;


/**
  * @brief SPIM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;
  __IOM uint32_t  MOSI;
  __IOM uint32_t  MISO;
  __IOM uint32_t  CSN;
} SPIM_PSEL_Type;


/**
  * @brief SPIM_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} SPIM_RXD_Type;


/**
  * @brief SPIM_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} SPIM_TXD_Type;


/**
  * @brief SPIM_IFTIMING [IFTIMING] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RXDELAY;
  __IOM uint32_t  CSNDUR;                       /*!< (@ 0x00000004) Minimum duration between edge of CSN and edge
                                                                    of SCK at the start and the end of a transaction,
                                                                    and minimum duration CSN will stay high
                                                                    between transactions if END-START shortcut
                                                                    is used                                                    */
} SPIM_IFTIMING_Type;


/**
  * @brief SPIS_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;
  __IOM uint32_t  MISO;
  __IOM uint32_t  MOSI;
  __IOM uint32_t  CSN;
} SPIS_PSEL_Type;


/**
  * @brief SPIS_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} SPIS_RXD_Type;


/**
  * @brief SPIS_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} SPIS_TXD_Type;


/**
  * @brief TWI_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;
  __IOM uint32_t  SDA;
} TWI_PSEL_Type;


/**
  * @brief TWIM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;
  __IOM uint32_t  SDA;
} TWIM_PSEL_Type;


/**
  * @brief TWIM_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} TWIM_RXD_Type;


/**
  * @brief TWIM_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} TWIM_TXD_Type;


/**
  * @brief TWIS_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCL;
  __IOM uint32_t  SDA;
} TWIS_PSEL_Type;


/**
  * @brief TWIS_RXD [RXD] (RXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} TWIS_RXD_Type;


/**
  * @brief TWIS_TXD [TXD] (TXD EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
  __IOM uint32_t  LIST;
} TWIS_TXD_Type;


/**
  * @brief NFCT_FRAMESTATUS [FRAMESTATUS] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  RX;
} NFCT_FRAMESTATUS_Type;


/**
  * @brief NFCT_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  FRAMECONFIG;
  __IOM uint32_t  AMOUNT;
} NFCT_TXD_Type;


/**
  * @brief NFCT_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  FRAMECONFIG;
  __IM  uint32_t  AMOUNT;
} NFCT_RXD_Type;


/**
  * @brief SAADC_EVENTS_CH [EVENTS_CH] (Peripheral events.)
  */
typedef struct {
  __IOM uint32_t  LIMITH;                       /*!< (@ 0x00000000) Description cluster: Last result is equal or
                                                                    above CH[n].LIMIT.HIGH                                     */
  __IOM uint32_t  LIMITL;                       /*!< (@ 0x00000004) Description cluster: Last result is equal or
                                                                    below CH[n].LIMIT.LOW                                      */
} SAADC_EVENTS_CH_Type;


/**
  * @brief SAADC_CH [CH] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PSELP;                        /*!< (@ 0x00000000) Description cluster: Input positive pin selection
                                                                    for CH[n]                                                  */
  __IOM uint32_t  PSELN;                        /*!< (@ 0x00000004) Description cluster: Input negative pin selection
                                                                    for CH[n]                                                  */
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000008) Description cluster: Input configuration for
                                                                    CH[n]                                                      */
  __IOM uint32_t  LIMIT;                        /*!< (@ 0x0000000C) Description cluster: High/low limits for event
                                                                    monitoring of a channel                                    */
} SAADC_CH_Type;


/**
  * @brief SAADC_RESULT [RESULT] (RESULT EasyDMA channel)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Maximum number of 16-bit samples to be written
                                                                    to output RAM buffer                                       */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Number of 16-bit samples written to output RAM
                                                                    buffer since the previous START task                       */
} SAADC_RESULT_Type;


/**
  * @brief QDEC_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  LED;
  __IOM uint32_t  A;
  __IOM uint32_t  B;
} QDEC_PSEL_Type;


/**
  * @brief PWM_SEQ [SEQ] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) Description cluster: Beginning address in RAM
                                                                    of this sequence                                           */
  __IOM uint32_t  CNT;                          /*!< (@ 0x00000004) Description cluster: Number of values (duty cycles)
                                                                    in this sequence                                           */
  __IOM uint32_t  REFRESH;                      /*!< (@ 0x00000008) Description cluster: Number of additional PWM
                                                                    periods between samples loaded into compare
                                                                    register                                                   */
  __IOM uint32_t  ENDDELAY;
  __IM  uint32_t  RESERVED[4];
} PWM_SEQ_Type;


/**
  * @brief PWM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  OUT[4];                       /*!< (@ 0x00000000) Description collection: Output pin select for
                                                                    PWM channel n                                              */
} PWM_PSEL_Type;


/**
  * @brief PDM_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  CLK;
  __IOM uint32_t  DIN;
} PDM_PSEL_Type;


/**
  * @brief PDM_SAMPLE [SAMPLE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;                          /*!< (@ 0x00000000) RAM address pointer to write samples to with
                                                                    EasyDMA                                                    */
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Number of samples to allocate memory for in EasyDMA
                                                                    mode                                                       */
} PDM_SAMPLE_Type;


/**
  * @brief ACL_ACL [ACL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  ADDR;                         /*!< (@ 0x00000000) Description cluster: Start address of region
                                                                    to protect. The start address must be word-aligned.        */
  __IOM uint32_t  SIZE;                         /*!< (@ 0x00000004) Description cluster: Size of region to protect
                                                                    counting from address ACL[n].ADDR. Writing
                                                                    a '0' has no effect.                                       */
  __IOM uint32_t  PERM;                         /*!< (@ 0x00000008) Description cluster: Access permissions for region
                                                                    n as defined by start address ACL[n].ADDR
                                                                    and size ACL[n].SIZE                                       */
  __IM  uint32_t  RESERVED;
} ACL_ACL_Type;


/**
  * @brief PPI_TASKS_CHG [TASKS_CHG] (Channel group tasks)
  */
typedef struct {
  __OM  uint32_t  EN;
  __OM  uint32_t  DIS;
} PPI_TASKS_CHG_Type;


/**
  * @brief PPI_CH [CH] (PPI Channel)
  */
typedef struct {
  __IOM uint32_t  EEP;
  __IOM uint32_t  TEP;
} PPI_CH_Type;


/**
  * @brief PPI_FORK [FORK] (Fork)
  */
typedef struct {
  __IOM uint32_t  TEP;
} PPI_FORK_Type;


/**
  * @brief MWU_EVENTS_REGION [EVENTS_REGION] (Peripheral events.)
  */
typedef struct {
  __IOM uint32_t  WA;                           /*!< (@ 0x00000000) Description cluster: Write access to region n
                                                                    detected                                                   */
  __IOM uint32_t  RA;                           /*!< (@ 0x00000004) Description cluster: Read access to region n
                                                                    detected                                                   */
} MWU_EVENTS_REGION_Type;


/**
  * @brief MWU_EVENTS_PREGION [EVENTS_PREGION] (Peripheral events.)
  */
typedef struct {
  __IOM uint32_t  WA;                           /*!< (@ 0x00000000) Description cluster: Write access to peripheral
                                                                    region n detected                                          */
  __IOM uint32_t  RA;                           /*!< (@ 0x00000004) Description cluster: Read access to peripheral
                                                                    region n detected                                          */
} MWU_EVENTS_PREGION_Type;


/**
  * @brief MWU_PERREGION [PERREGION] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SUBSTATWA;                    /*!< (@ 0x00000000) Description cluster: Source of event/interrupt
                                                                    in region n, write access detected while
                                                                    corresponding subregion was enabled for
                                                                    watching                                                   */
  __IOM uint32_t  SUBSTATRA;                    /*!< (@ 0x00000004) Description cluster: Source of event/interrupt
                                                                    in region n, read access detected while
                                                                    corresponding subregion was enabled for
                                                                    watching                                                   */
} MWU_PERREGION_Type;


/**
  * @brief MWU_REGION [REGION] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  START;                        /*!< (@ 0x00000000) Description cluster: Start address for region
                                                                    n                                                          */
  __IOM uint32_t  END;
  __IM  uint32_t  RESERVED[2];
} MWU_REGION_Type;


/**
  * @brief MWU_PREGION [PREGION] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  START;
  __IM  uint32_t  END;
  __IOM uint32_t  SUBS;
  __IM  uint32_t  RESERVED;
} MWU_PREGION_Type;


/**
  * @brief I2S_CONFIG [CONFIG] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MODE;
  __IOM uint32_t  RXEN;
  __IOM uint32_t  TXEN;
  __IOM uint32_t  MCKEN;
  __IOM uint32_t  MCKFREQ;
  __IOM uint32_t  RATIO;
  __IOM uint32_t  SWIDTH;
  __IOM uint32_t  ALIGN;
  __IOM uint32_t  FORMAT;
  __IOM uint32_t  CHANNELS;
} I2S_CONFIG_Type;


/**
  * @brief I2S_RXD [RXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
} I2S_RXD_Type;


/**
  * @brief I2S_TXD [TXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
} I2S_TXD_Type;


/**
  * @brief I2S_RXTXD [RXTXD] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MAXCNT;
} I2S_RXTXD_Type;


/**
  * @brief I2S_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  MCK;
  __IOM uint32_t  SCK;
  __IOM uint32_t  LRCK;
  __IOM uint32_t  SDIN;
  __IOM uint32_t  SDOUT;
} I2S_PSEL_Type;


/**
  * @brief USBD_HALTED [HALTED] (Unspecified)
  */
typedef struct {
  __IM  uint32_t  EPIN[8];                      /*!< (@ 0x00000000) Description collection: IN endpoint halted status.
                                                                    Can be used as is as response to a GetStatus()
                                                                    request to endpoint.                                       */
  __IM  uint32_t  RESERVED;
  __IM  uint32_t  EPOUT[8];                     /*!< (@ 0x00000024) Description collection: OUT endpoint halted status.
                                                                    Can be used as is as response to a GetStatus()
                                                                    request to endpoint.                                       */
} USBD_HALTED_Type;


/**
  * @brief USBD_SIZE [SIZE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  EPOUT[8];                     /*!< (@ 0x00000000) Description collection: Number of bytes received
                                                                    last in the data stage of this OUT endpoint                */
  __IM  uint32_t  ISOOUT;                       /*!< (@ 0x00000020) Number of bytes received last on this ISO OUT
                                                                    data endpoint                                              */
} USBD_SIZE_Type;


/**
  * @brief USBD_EPIN [EPIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Description cluster: Maximum number of bytes
                                                                    to transfer                                                */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Description cluster: Number of bytes transferred
                                                                    in the last transaction                                    */
  __IM  uint32_t  RESERVED[2];
} USBD_EPIN_Type;


/**
  * @brief USBD_ISOIN [ISOIN] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
} USBD_ISOIN_Type;


/**
  * @brief USBD_EPOUT [EPOUT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;                       /*!< (@ 0x00000004) Description cluster: Maximum number of bytes
                                                                    to transfer                                                */
  __IM  uint32_t  AMOUNT;                       /*!< (@ 0x00000008) Description cluster: Number of bytes transferred
                                                                    in the last transaction                                    */
  __IM  uint32_t  RESERVED[2];
} USBD_EPOUT_Type;


/**
  * @brief USBD_ISOOUT [ISOOUT] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  MAXCNT;
  __IM  uint32_t  AMOUNT;
} USBD_ISOOUT_Type;


/**
  * @brief QSPI_READ [READ] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SRC;
  __IOM uint32_t  DST;
  __IOM uint32_t  CNT;
} QSPI_READ_Type;


/**
  * @brief QSPI_WRITE [WRITE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  DST;
  __IOM uint32_t  SRC;
  __IOM uint32_t  CNT;
} QSPI_WRITE_Type;


/**
  * @brief QSPI_ERASE [ERASE] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  PTR;
  __IOM uint32_t  LEN;
} QSPI_ERASE_Type;


/**
  * @brief QSPI_PSEL [PSEL] (Unspecified)
  */
typedef struct {
  __IOM uint32_t  SCK;
  __IOM uint32_t  CSN;
  __IM  uint32_t  RESERVED;
  __IOM uint32_t  IO0;
  __IOM uint32_t  IO1;
  __IOM uint32_t  IO2;
  __IOM uint32_t  IO3;
} QSPI_PSEL_Type;


/** @} */ /* End of group Device_Peripheral_clusters */


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                           FICR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Factory information configuration registers (FICR)
  */

typedef struct {
  __IM  uint32_t  RESERVED[4];
  __IM  uint32_t  CODEPAGESIZE;
  __IM  uint32_t  CODESIZE;
  __IM  uint32_t  RESERVED1[18];
  __IM  uint32_t  DEVICEID[2];
  __IM  uint32_t  RESERVED2[6];
  __IM  uint32_t  ER[4];                        /*!< (@ 0x00000080) Description collection: Encryption root, word
                                                                    n                                                          */
  __IM  uint32_t  IR[4];
  __IM  uint32_t  DEVICEADDRTYPE;
  __IM  uint32_t  DEVICEADDR[2];
  __IM  uint32_t  RESERVED3[21];
  __IM  FICR_INFO_Type INFO;
  __IM  uint32_t  RESERVED4[143];
  __IM  uint32_t  PRODTEST[3];                  /*!< (@ 0x00000350) Description collection: Production test signature
                                                                    n                                                          */
  __IM  uint32_t  RESERVED5[42];
  __IM  FICR_TEMP_Type TEMP;                    /*!< (@ 0x00000404) Registers storing factory TEMP module linearization
                                                                    coefficients                                               */
  __IM  uint32_t  RESERVED6[2];
  __IOM FICR_NFC_Type NFC;
  __IM  uint32_t  RESERVED7[488];
  __IOM FICR_TRNG90B_Type TRNG90B;
} NRF_FICR_Type;



/* =========================================================================================================================== */
/* ================                                           UICR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief User information configuration registers (UICR)
  */

typedef struct {
  __IM  uint32_t  RESERVED[5];
  __IOM uint32_t  NRFFW[13];                    /*!< (@ 0x00000014) Description collection: Reserved for Nordic firmware
                                                                    design                                                     */
  __IM  uint32_t  RESERVED1[2];
  __IOM uint32_t  NRFHW[12];                    /*!< (@ 0x00000050) Description collection: Reserved for Nordic hardware
                                                                    design                                                     */
  __IOM uint32_t  CUSTOMER[32];
  __IM  uint32_t  RESERVED2[64];
  __IOM uint32_t  PSELRESET[2];                 /*!< (@ 0x00000200) Description collection: Mapping of the nRESET
                                                                    function (see POWER chapter for details)                   */
  __IOM uint32_t  APPROTECT;
  __IOM uint32_t  NFCPINS;                      /*!< (@ 0x0000020C) Setting of pins dedicated to NFC functionality:
                                                                    NFC antenna or GPIO                                        */
  __IOM uint32_t  DEBUGCTRL;
  __IM  uint32_t  RESERVED3[60];
  __IOM uint32_t  REGOUT0;                      /*!< (@ 0x00000304) Output voltage from REG0 regulator stage. The
                                                                    maximum output voltage from this stage is
                                                                    given as VDDH - V_VDDH-VDD.                                */
} NRF_UICR_Type;



/* =========================================================================================================================== */
/* ================                                         APPROTECT                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief Access Port Protection (APPROTECT)
  */

typedef struct {
  __IM  uint32_t  RESERVED[340];
  __IOM uint32_t  FORCEPROTECT;                 /*!< (@ 0x00000550) Software force enable APPROTECT mechanism until
                                                                    next reset.                                                */
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  DISABLE;
} NRF_APPROTECT_Type;



/* =========================================================================================================================== */
/* ================                                           CLOCK                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Clock control (CLOCK)
  */

typedef struct {
  __OM  uint32_t  TASKS_HFCLKSTART;
  __OM  uint32_t  TASKS_HFCLKSTOP;
  __OM  uint32_t  TASKS_LFCLKSTART;
  __OM  uint32_t  TASKS_LFCLKSTOP;
  __OM  uint32_t  TASKS_CAL;
  __OM  uint32_t  TASKS_CTSTART;
  __OM  uint32_t  TASKS_CTSTOP;
  __IM  uint32_t  RESERVED[57];
  __IOM uint32_t  EVENTS_HFCLKSTARTED;
  __IOM uint32_t  EVENTS_LFCLKSTARTED;
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  EVENTS_DONE;
  __IOM uint32_t  EVENTS_CTTO;
  __IM  uint32_t  RESERVED2[5];
  __IOM uint32_t  EVENTS_CTSTARTED;             /*!< (@ 0x00000128) Calibration timer has been started and is ready
                                                                    to process new tasks                                       */
  __IOM uint32_t  EVENTS_CTSTOPPED;             /*!< (@ 0x0000012C) Calibration timer has been stopped and is ready
                                                                    to process new tasks                                       */
  __IM  uint32_t  RESERVED3[117];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED4[63];
  __IM  uint32_t  HFCLKRUN;                     /*!< (@ 0x00000408) Status indicating that HFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  HFCLKSTAT;
  __IM  uint32_t  RESERVED5;
  __IM  uint32_t  LFCLKRUN;                     /*!< (@ 0x00000414) Status indicating that LFCLKSTART task has been
                                                                    triggered                                                  */
  __IM  uint32_t  LFCLKSTAT;
  __IM  uint32_t  LFCLKSRCCOPY;                 /*!< (@ 0x0000041C) Copy of LFCLKSRC register, set when LFCLKSTART
                                                                    task was triggered                                         */
  __IM  uint32_t  RESERVED6[62];
  __IOM uint32_t  LFCLKSRC;
  __IM  uint32_t  RESERVED7[3];
  __IOM uint32_t  HFXODEBOUNCE;                 /*!< (@ 0x00000528) HFXO debounce time. The HFXO is started by triggering
                                                                    the TASKS_HFCLKSTART task.                                 */
  __IM  uint32_t  RESERVED8[3];
  __IOM uint32_t  CTIV;
  __IM  uint32_t  RESERVED9[8];
  __IOM uint32_t  TRACECONFIG;
  __IM  uint32_t  RESERVED10[21];
  __IOM uint32_t  LFRCMODE;
} NRF_CLOCK_Type;



/* =========================================================================================================================== */
/* ================                                           POWER                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Power control (POWER)
  */

typedef struct {
  __IM  uint32_t  RESERVED[30];
  __OM  uint32_t  TASKS_CONSTLAT;
  __OM  uint32_t  TASKS_LOWPWR;
  __IM  uint32_t  RESERVED1[34];
  __IOM uint32_t  EVENTS_POFWARN;
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  EVENTS_SLEEPENTER;
  __IOM uint32_t  EVENTS_SLEEPEXIT;
  __IOM uint32_t  EVENTS_USBDETECTED;
  __IOM uint32_t  EVENTS_USBREMOVED;
  __IOM uint32_t  EVENTS_USBPWRRDY;
  __IM  uint32_t  RESERVED3[119];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED4[61];
  __IOM uint32_t  RESETREAS;
  __IM  uint32_t  RESERVED5[9];
  __IM  uint32_t  RAMSTATUS;
  __IM  uint32_t  RESERVED6[3];
  __IM  uint32_t  USBREGSTATUS;
  __IM  uint32_t  RESERVED7[49];
  __OM  uint32_t  SYSTEMOFF;
  __IM  uint32_t  RESERVED8[3];
  __IOM uint32_t  POFCON;
  __IM  uint32_t  RESERVED9[2];
  __IOM uint32_t  GPREGRET;
  __IOM uint32_t  GPREGRET2;
  __IM  uint32_t  RESERVED10[21];
  __IOM uint32_t  DCDCEN;
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  DCDCEN0;
  __IM  uint32_t  RESERVED12[47];
  __IM  uint32_t  MAINREGSTATUS;
  __IM  uint32_t  RESERVED13[175];
  __IOM POWER_RAM_Type RAM[9];
} NRF_POWER_Type;



/* =========================================================================================================================== */
/* ================                                            P0                                             ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Port 0 (P0)
  */

typedef struct {
  __IM  uint32_t  RESERVED[321];
  __IOM uint32_t  OUT;
  __IOM uint32_t  OUTSET;
  __IOM uint32_t  OUTCLR;
  __IM  uint32_t  IN;
  __IOM uint32_t  DIR;
  __IOM uint32_t  DIRSET;
  __IOM uint32_t  DIRCLR;
  __IOM uint32_t  LATCH;                        /*!< (@ 0x00000520) Latch register indicating what GPIO pins that
                                                                    have met the criteria set in the PIN_CNF[n].SENSE
                                                                    registers                                                  */
  __IOM uint32_t  DETECTMODE;                   /*!< (@ 0x00000524) Select between default DETECT signal behavior
                                                                    and LDETECT mode                                           */
  __IM  uint32_t  RESERVED1[118];
  __IOM uint32_t  PIN_CNF[32];                  /*!< (@ 0x00000700) Description collection: Configuration of GPIO
                                                                    pins                                                       */
} NRF_GPIO_Type;



/* =========================================================================================================================== */
/* ================                                           RADIO                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief 2.4 GHz radio (RADIO)
  */

typedef struct {
  __OM  uint32_t  TASKS_TXEN;
  __OM  uint32_t  TASKS_RXEN;
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_DISABLE;
  __OM  uint32_t  TASKS_RSSISTART;              /*!< (@ 0x00000014) Start the RSSI and take one single sample of
                                                                    the receive signal strength                                */
  __OM  uint32_t  TASKS_RSSISTOP;
  __OM  uint32_t  TASKS_BCSTART;
  __OM  uint32_t  TASKS_BCSTOP;
  __OM  uint32_t  TASKS_EDSTART;                /*!< (@ 0x00000024) Start the energy detect measurement used in IEEE
                                                                    802.15.4 mode                                              */
  __OM  uint32_t  TASKS_EDSTOP;
  __OM  uint32_t  TASKS_CCASTART;               /*!< (@ 0x0000002C) Start the clear channel assessment used in IEEE
                                                                    802.15.4 mode                                              */
  __OM  uint32_t  TASKS_CCASTOP;
  __IM  uint32_t  RESERVED[51];
  __IOM uint32_t  EVENTS_READY;
  __IOM uint32_t  EVENTS_ADDRESS;
  __IOM uint32_t  EVENTS_PAYLOAD;
  __IOM uint32_t  EVENTS_END;
  __IOM uint32_t  EVENTS_DISABLED;
  __IOM uint32_t  EVENTS_DEVMATCH;              /*!< (@ 0x00000114) A device address match occurred on the last received
                                                                    packet                                                     */
  __IOM uint32_t  EVENTS_DEVMISS;               /*!< (@ 0x00000118) No device address match occurred on the last
                                                                    received packet                                            */
  __IOM uint32_t  EVENTS_RSSIEND;
  __IM  uint32_t  RESERVED1[2];
  __IOM uint32_t  EVENTS_BCMATCH;
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  EVENTS_CRCOK;
  __IOM uint32_t  EVENTS_CRCERROR;
  __IOM uint32_t  EVENTS_FRAMESTART;
  __IOM uint32_t  EVENTS_EDEND;                 /*!< (@ 0x0000013C) Sampling of energy detection complete. A new
                                                                    ED sample is ready for readout from the
                                                                    RADIO.EDSAMPLE register.                                   */
  __IOM uint32_t  EVENTS_EDSTOPPED;
  __IOM uint32_t  EVENTS_CCAIDLE;
  __IOM uint32_t  EVENTS_CCABUSY;
  __IOM uint32_t  EVENTS_CCASTOPPED;
  __IOM uint32_t  EVENTS_RATEBOOST;             /*!< (@ 0x00000150) Ble_LR CI field received, receive mode is changed
                                                                    from Ble_LR125Kbit to Ble_LR500Kbit.                       */
  __IOM uint32_t  EVENTS_TXREADY;               /*!< (@ 0x00000154) RADIO has ramped up and is ready to be started
                                                                    TX path                                                    */
  __IOM uint32_t  EVENTS_RXREADY;               /*!< (@ 0x00000158) RADIO has ramped up and is ready to be started
                                                                    RX path                                                    */
  __IOM uint32_t  EVENTS_MHRMATCH;
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_SYNC;
  __IOM uint32_t  EVENTS_PHYEND;                /*!< (@ 0x0000016C) Generated in Ble_LR125Kbit, Ble_LR500Kbit and
                                                                    Ieee802154_250Kbit modes when last bit is
                                                                    sent on air.                                               */
  __IM  uint32_t  RESERVED4[36];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED5[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED6[61];
  __IM  uint32_t  CRCSTATUS;
  __IM  uint32_t  RESERVED7;
  __IM  uint32_t  RXMATCH;
  __IM  uint32_t  RXCRC;
  __IM  uint32_t  DAI;
  __IM  uint32_t  PDUSTAT;
  __IM  uint32_t  RESERVED8[59];
  __IOM uint32_t  PACKETPTR;
  __IOM uint32_t  FREQUENCY;
  __IOM uint32_t  TXPOWER;
  __IOM uint32_t  MODE;
  __IOM uint32_t  PCNF0;
  __IOM uint32_t  PCNF1;
  __IOM uint32_t  BASE0;
  __IOM uint32_t  BASE1;
  __IOM uint32_t  PREFIX0;
  __IOM uint32_t  PREFIX1;
  __IOM uint32_t  TXADDRESS;
  __IOM uint32_t  RXADDRESSES;
  __IOM uint32_t  CRCCNF;
  __IOM uint32_t  CRCPOLY;
  __IOM uint32_t  CRCINIT;
  __IM  uint32_t  RESERVED9;
  __IOM uint32_t  TIFS;
  __IM  uint32_t  RSSISAMPLE;
  __IM  uint32_t  RESERVED10;
  __IM  uint32_t  STATE;
  __IOM uint32_t  DATAWHITEIV;
  __IM  uint32_t  RESERVED11[2];
  __IOM uint32_t  BCC;
  __IM  uint32_t  RESERVED12[39];
  __IOM uint32_t  DAB[8];                       /*!< (@ 0x00000600) Description collection: Device address base segment
                                                                    n                                                          */
  __IOM uint32_t  DAP[8];                       /*!< (@ 0x00000620) Description collection: Device address prefix
                                                                    n                                                          */
  __IOM uint32_t  DACNF;
  __IOM uint32_t  MHRMATCHCONF;
  __IOM uint32_t  MHRMATCHMAS;
  __IM  uint32_t  RESERVED13;
  __IOM uint32_t  MODECNF0;
  __IM  uint32_t  RESERVED14[3];
  __IOM uint32_t  SFD;
  __IOM uint32_t  EDCNT;
  __IOM uint32_t  EDSAMPLE;
  __IOM uint32_t  CCACTRL;
  __IM  uint32_t  RESERVED15[611];
  __IOM uint32_t  POWER;
} NRF_RADIO_Type;



/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal Asynchronous Receiver/Transmitter (UART0)
  */

typedef struct {
  __OM  uint32_t  TASKS_STARTRX;
  __OM  uint32_t  TASKS_STOPRX;
  __OM  uint32_t  TASKS_STARTTX;
  __OM  uint32_t  TASKS_STOPTX;
  __IM  uint32_t  RESERVED[3];
  __OM  uint32_t  TASKS_SUSPEND;
  __IM  uint32_t  RESERVED1[56];
  __IOM uint32_t  EVENTS_CTS;
  __IOM uint32_t  EVENTS_NCTS;
  __IOM uint32_t  EVENTS_RXDRDY;
  __IM  uint32_t  RESERVED2[4];
  __IOM uint32_t  EVENTS_TXDRDY;
  __IM  uint32_t  RESERVED3;
  __IOM uint32_t  EVENTS_ERROR;
  __IM  uint32_t  RESERVED4[7];
  __IOM uint32_t  EVENTS_RXTO;
  __IM  uint32_t  RESERVED5[46];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED6[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED7[93];
  __IOM uint32_t  ERRORSRC;
  __IM  uint32_t  RESERVED8[31];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED9;
  __IOM UART_PSEL_Type PSEL;
  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register. Register is cleared on read and
                                                                    the double buffered byte will be moved to
                                                                    RXD if it exists.                                          */
  __OM  uint32_t  TXD;
  __IM  uint32_t  RESERVED10;
  __IOM uint32_t  BAUDRATE;                     /*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
                                                                    selected.                                                  */
  __IM  uint32_t  RESERVED11[17];
  __IOM uint32_t  CONFIG;
} NRF_UART_Type;



/* =========================================================================================================================== */
/* ================                                          UARTE0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART with EasyDMA 0 (UARTE0)
  */

typedef struct {
  __OM  uint32_t  TASKS_STARTRX;
  __OM  uint32_t  TASKS_STOPRX;
  __OM  uint32_t  TASKS_STARTTX;
  __OM  uint32_t  TASKS_STOPTX;
  __IM  uint32_t  RESERVED[7];
  __OM  uint32_t  TASKS_FLUSHRX;
  __IM  uint32_t  RESERVED1[52];
  __IOM uint32_t  EVENTS_CTS;
  __IOM uint32_t  EVENTS_NCTS;
  __IOM uint32_t  EVENTS_RXDRDY;                /*!< (@ 0x00000108) Data received in RXD (but potentially not yet
                                                                    transferred to Data RAM)                                   */
  __IM  uint32_t  RESERVED2;
  __IOM uint32_t  EVENTS_ENDRX;
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_TXDRDY;
  __IOM uint32_t  EVENTS_ENDTX;
  __IOM uint32_t  EVENTS_ERROR;
  __IM  uint32_t  RESERVED4[7];
  __IOM uint32_t  EVENTS_RXTO;
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  EVENTS_RXSTARTED;
  __IOM uint32_t  EVENTS_TXSTARTED;
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  EVENTS_TXSTOPPED;
  __IM  uint32_t  RESERVED7[41];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED8[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED9[93];
  __IOM uint32_t  ERRORSRC;                     /*!< (@ 0x00000480) Error source This register is read/write one
                                                                    to clear.                                                  */
  __IM  uint32_t  RESERVED10[31];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED11;
  __IOM UARTE_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED12[3];
  __IOM uint32_t  BAUDRATE;                     /*!< (@ 0x00000524) Baud rate. Accuracy depends on the HFCLK source
                                                                    selected.                                                  */
  __IM  uint32_t  RESERVED13[3];
  __IOM UARTE_RXD_Type RXD;
  __IM  uint32_t  RESERVED14;
  __IOM UARTE_TXD_Type TXD;
  __IM  uint32_t  RESERVED15[7];
  __IOM uint32_t  CONFIG;
} NRF_UARTE_Type;



/* =========================================================================================================================== */
/* ================                                           SPI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial Peripheral Interface 0 (SPI0)
  */

typedef struct {
  __IM  uint32_t  RESERVED[66];
  __IOM uint32_t  EVENTS_READY;
  __IM  uint32_t  RESERVED1[126];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED2[125];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED3;
  __IOM SPI_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED4;
  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register. Register is cleared on read and
                                                                    the buffer pointer will be modified if read.               */
  __IOM uint32_t  TXD;
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED6[11];
  __IOM uint32_t  CONFIG;
} NRF_SPI_Type;



/* =========================================================================================================================== */
/* ================                                           SPIM0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Serial Peripheral Interface Master with EasyDMA 0 (SPIM0)
  */

typedef struct {
  __IM  uint32_t  RESERVED[4];
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;
  __OM  uint32_t  TASKS_RESUME;
  __IM  uint32_t  RESERVED2[56];
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_ENDRX;
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  EVENTS_END;
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  EVENTS_ENDTX;
  __IM  uint32_t  RESERVED6[10];
  __IOM uint32_t  EVENTS_STARTED;
  __IM  uint32_t  RESERVED7[44];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED8[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED9[61];
  __IOM uint32_t  STALLSTAT;                    /*!< (@ 0x00000400) Stall status for EasyDMA RAM accesses. The fields
                                                                    in this register are set to STALL by hardware
                                                                    whenever a stall occurs and can be cleared
                                                                    (set to NOSTALL) by the CPU.                               */
  __IM  uint32_t  RESERVED10[63];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED11;
  __IOM SPIM_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED12[3];
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) SPI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED13[3];
  __IOM SPIM_RXD_Type RXD;
  __IOM SPIM_TXD_Type TXD;
  __IOM uint32_t  CONFIG;
  __IM  uint32_t  RESERVED14[2];
  __IOM SPIM_IFTIMING_Type IFTIMING;
  __IOM uint32_t  CSNPOL;
  __IOM uint32_t  PSELDCX;
  __IOM uint32_t  DCXCNT;
  __IM  uint32_t  RESERVED15[19];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Byte transmitted after TXD.MAXCNT bytes have
                                                                    been transmitted in the case when RXD.MAXCNT
                                                                    is greater than TXD.MAXCNT                                 */
} NRF_SPIM_Type;



/* =========================================================================================================================== */
/* ================                                           SPIS0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI Slave 0 (SPIS0)
  */

typedef struct {
  __IM  uint32_t  RESERVED[9];
  __OM  uint32_t  TASKS_ACQUIRE;
  __OM  uint32_t  TASKS_RELEASE;                /*!< (@ 0x00000028) Release SPI semaphore, enabling the SPI slave
                                                                    to acquire it                                              */
  __IM  uint32_t  RESERVED1[54];
  __IOM uint32_t  EVENTS_END;
  __IM  uint32_t  RESERVED2[2];
  __IOM uint32_t  EVENTS_ENDRX;
  __IM  uint32_t  RESERVED3[5];
  __IOM uint32_t  EVENTS_ACQUIRED;
  __IM  uint32_t  RESERVED4[53];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED5[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED6[61];
  __IM  uint32_t  SEMSTAT;
  __IM  uint32_t  RESERVED7[15];
  __IOM uint32_t  STATUS;
  __IM  uint32_t  RESERVED8[47];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED9;
  __IOM SPIS_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED10[7];
  __IOM SPIS_RXD_Type RXD;
  __IOM SPIS_TXD_Type TXD;
  __IOM uint32_t  CONFIG;
  __IM  uint32_t  RESERVED11;
  __IOM uint32_t  DEF;                          /*!< (@ 0x0000055C) Default character. Character clocked out in case
                                                                    of an ignored transaction.                                 */
  __IM  uint32_t  RESERVED12[24];
  __IOM uint32_t  ORC;
} NRF_SPIS_Type;



/* =========================================================================================================================== */
/* ================                                           TWI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Interface 0 (TWI0)
  */

typedef struct {
  __OM  uint32_t  TASKS_STARTRX;
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTTX;
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  TASKS_SUSPEND;
  __OM  uint32_t  TASKS_RESUME;
  __IM  uint32_t  RESERVED3[56];
  __IOM uint32_t  EVENTS_STOPPED;
  __IOM uint32_t  EVENTS_RXDREADY;
  __IM  uint32_t  RESERVED4[4];
  __IOM uint32_t  EVENTS_TXDSENT;
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  EVENTS_ERROR;
  __IM  uint32_t  RESERVED6[4];
  __IOM uint32_t  EVENTS_BB;                    /*!< (@ 0x00000138) TWI byte boundary, generated before each byte
                                                                    that is sent or received                                   */
  __IM  uint32_t  RESERVED7[3];
  __IOM uint32_t  EVENTS_SUSPENDED;
  __IM  uint32_t  RESERVED8[45];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED9[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED10[110];
  __IOM uint32_t  ERRORSRC;
  __IM  uint32_t  RESERVED11[14];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED12;
  __IOM TWI_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED13[2];
  __IM  uint32_t  RXD;                          /*!< (@ 0x00000518) RXD register. Register is cleared on read and
                                                                    the buffer pointer will be modified if read.               */
  __IOM uint32_t  TXD;
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED15[24];
  __IOM uint32_t  ADDRESS;
} NRF_TWI_Type;



/* =========================================================================================================================== */
/* ================                                           TWIM0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Master Interface with EasyDMA 0 (TWIM0)
  */

typedef struct {
  __OM  uint32_t  TASKS_STARTRX;
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTTX;
  __IM  uint32_t  RESERVED1[2];
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000014) Stop TWI transaction. Must be issued while the
                                                                    TWI master is not suspended.                               */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  TASKS_SUSPEND;
  __OM  uint32_t  TASKS_RESUME;
  __IM  uint32_t  RESERVED3[56];
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED4[7];
  __IOM uint32_t  EVENTS_ERROR;
  __IM  uint32_t  RESERVED5[8];
  __IOM uint32_t  EVENTS_SUSPENDED;             /*!< (@ 0x00000148) SUSPEND task has been issued, TWI traffic is
                                                                    now suspended.                                             */
  __IOM uint32_t  EVENTS_RXSTARTED;
  __IOM uint32_t  EVENTS_TXSTARTED;
  __IM  uint32_t  RESERVED6[2];
  __IOM uint32_t  EVENTS_LASTRX;
  __IOM uint32_t  EVENTS_LASTTX;                /*!< (@ 0x00000160) Byte boundary, starting to transmit the last
                                                                    byte                                                       */
  __IM  uint32_t  RESERVED7[39];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED8[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED9[110];
  __IOM uint32_t  ERRORSRC;
  __IM  uint32_t  RESERVED10[14];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED11;
  __IOM TWIM_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED12[5];
  __IOM uint32_t  FREQUENCY;                    /*!< (@ 0x00000524) TWI frequency. Accuracy depends on the HFCLK
                                                                    source selected.                                           */
  __IM  uint32_t  RESERVED13[3];
  __IOM TWIM_RXD_Type RXD;
  __IOM TWIM_TXD_Type TXD;
  __IM  uint32_t  RESERVED14[13];
  __IOM uint32_t  ADDRESS;
} NRF_TWIM_Type;



/* =========================================================================================================================== */
/* ================                                           TWIS0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief I2C compatible Two-Wire Slave Interface with EasyDMA 0 (TWIS0)
  */

typedef struct {
  __IM  uint32_t  RESERVED[5];
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_SUSPEND;
  __OM  uint32_t  TASKS_RESUME;
  __IM  uint32_t  RESERVED2[3];
  __OM  uint32_t  TASKS_PREPARERX;
  __OM  uint32_t  TASKS_PREPARETX;
  __IM  uint32_t  RESERVED3[51];
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED4[7];
  __IOM uint32_t  EVENTS_ERROR;
  __IM  uint32_t  RESERVED5[9];
  __IOM uint32_t  EVENTS_RXSTARTED;
  __IOM uint32_t  EVENTS_TXSTARTED;
  __IM  uint32_t  RESERVED6[4];
  __IOM uint32_t  EVENTS_WRITE;
  __IOM uint32_t  EVENTS_READ;
  __IM  uint32_t  RESERVED7[37];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED8[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED9[113];
  __IOM uint32_t  ERRORSRC;
  __IM  uint32_t  MATCH;                        /*!< (@ 0x000004D4) Status register indicating which address had
                                                                    a match                                                    */
  __IM  uint32_t  RESERVED10[10];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED11;
  __IOM TWIS_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED12[9];
  __IOM TWIS_RXD_Type RXD;
  __IOM TWIS_TXD_Type TXD;
  __IM  uint32_t  RESERVED13[13];
  __IOM uint32_t  ADDRESS[2];
  __IM  uint32_t  RESERVED14;
  __IOM uint32_t  CONFIG;                       /*!< (@ 0x00000594) Configuration register for the address match
                                                                    mechanism                                                  */
  __IM  uint32_t  RESERVED15[10];
  __IOM uint32_t  ORC;                          /*!< (@ 0x000005C0) Over-read character. Character sent out in case
                                                                    of an over-read of the transmit buffer.                    */
} NRF_TWIS_Type;



/* =========================================================================================================================== */
/* ================                                           NFCT                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief NFC-A compatible radio (NFCT)
  */

typedef struct {
  __OM  uint32_t  TASKS_ACTIVATE;               /*!< (@ 0x00000000) Activate NFCT peripheral for incoming and outgoing
                                                                    frames, change state to activated                          */
  __OM  uint32_t  TASKS_DISABLE;
  __OM  uint32_t  TASKS_SENSE;                  /*!< (@ 0x00000008) Enable NFC sense field mode, change state to
                                                                    sense mode                                                 */
  __OM  uint32_t  TASKS_STARTTX;                /*!< (@ 0x0000000C) Start transmission of an outgoing frame, change
                                                                    state to transmit                                          */
  __IM  uint32_t  RESERVED[3];
  __OM  uint32_t  TASKS_ENABLERXDATA;
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  TASKS_GOIDLE;
  __OM  uint32_t  TASKS_GOSLEEP;
  __IM  uint32_t  RESERVED2[53];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) The NFCT peripheral is ready to receive and send
                                                                    frames                                                     */
  __IOM uint32_t  EVENTS_FIELDDETECTED;
  __IOM uint32_t  EVENTS_FIELDLOST;
  __IOM uint32_t  EVENTS_TXFRAMESTART;          /*!< (@ 0x0000010C) Marks the start of the first symbol of a transmitted
                                                                    frame                                                      */
  __IOM uint32_t  EVENTS_TXFRAMEEND;            /*!< (@ 0x00000110) Marks the end of the last transmitted on-air
                                                                    symbol of a frame                                          */
  __IOM uint32_t  EVENTS_RXFRAMESTART;          /*!< (@ 0x00000114) Marks the end of the first symbol of a received
                                                                    frame                                                      */
  __IOM uint32_t  EVENTS_RXFRAMEEND;            /*!< (@ 0x00000118) Received data has been checked (CRC, parity)
                                                                    and transferred to RAM, and EasyDMA has
                                                                    ended accessing the RX buffer                              */
  __IOM uint32_t  EVENTS_ERROR;                 /*!< (@ 0x0000011C) NFC error reported. The ERRORSTATUS register
                                                                    contains details on the source of the error.               */
  __IM  uint32_t  RESERVED3[2];
  __IOM uint32_t  EVENTS_RXERROR;               /*!< (@ 0x00000128) NFC RX frame error reported. The FRAMESTATUS.RX
                                                                    register contains details on the source
                                                                    of the error.                                              */
  __IOM uint32_t  EVENTS_ENDRX;                 /*!< (@ 0x0000012C) RX buffer (as defined by PACKETPTR and MAXLEN)
                                                                    in Data RAM full.                                          */
  __IOM uint32_t  EVENTS_ENDTX;                 /*!< (@ 0x00000130) Transmission of data in RAM has ended, and EasyDMA
                                                                    has ended accessing the TX buffer                          */
  __IM  uint32_t  RESERVED4;
  __IOM uint32_t  EVENTS_AUTOCOLRESSTARTED;
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  EVENTS_COLLISION;
  __IOM uint32_t  EVENTS_SELECTED;
  __IOM uint32_t  EVENTS_STARTED;
  __IM  uint32_t  RESERVED6[43];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED7[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED8[62];
  __IOM uint32_t  ERRORSTATUS;
  __IM  uint32_t  RESERVED9;
  __IOM NFCT_FRAMESTATUS_Type FRAMESTATUS;
  __IM  uint32_t  NFCTAGSTATE;
  __IM  uint32_t  RESERVED10[3];
  __IM  uint32_t  SLEEPSTATE;
  __IM  uint32_t  RESERVED11[6];
  __IM  uint32_t  FIELDPRESENT;
  __IM  uint32_t  RESERVED12[49];
  __IOM uint32_t  FRAMEDELAYMIN;
  __IOM uint32_t  FRAMEDELAYMAX;
  __IOM uint32_t  FRAMEDELAYMODE;
  __IOM uint32_t  PACKETPTR;                    /*!< (@ 0x00000510) Packet pointer for TXD and RXD data storage in
                                                                    Data RAM                                                   */
  __IOM uint32_t  MAXLEN;                       /*!< (@ 0x00000514) Size of the RAM buffer allocated to TXD and RXD
                                                                    data storage each                                          */
  __IOM NFCT_TXD_Type TXD;
  __IOM NFCT_RXD_Type RXD;
  __IM  uint32_t  RESERVED13[26];
  __IOM uint32_t  NFCID1_LAST;
  __IOM uint32_t  NFCID1_2ND_LAST;
  __IOM uint32_t  NFCID1_3RD_LAST;
  __IOM uint32_t  AUTOCOLRESCONFIG;             /*!< (@ 0x0000059C) Controls the auto collision resolution function.
                                                                    This setting must be done before the NFCT
                                                                    peripheral is activated.                                   */
  __IOM uint32_t  SENSRES;
  __IOM uint32_t  SELRES;
} NRF_NFCT_Type;



/* =========================================================================================================================== */
/* ================                                          GPIOTE                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief GPIO Tasks and Events (GPIOTE)
  */

typedef struct {
  __OM  uint32_t  TASKS_OUT[8];                 /*!< (@ 0x00000000) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is configured in CONFIG[n].POLARITY.                       */
  __IM  uint32_t  RESERVED[4];
  __OM  uint32_t  TASKS_SET[8];                 /*!< (@ 0x00000030) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is to set it high.                                         */
  __IM  uint32_t  RESERVED1[4];
  __OM  uint32_t  TASKS_CLR[8];                 /*!< (@ 0x00000060) Description collection: Task for writing to pin
                                                                    specified in CONFIG[n].PSEL. Action on pin
                                                                    is to set it low.                                          */
  __IM  uint32_t  RESERVED2[32];
  __IOM uint32_t  EVENTS_IN[8];                 /*!< (@ 0x00000100) Description collection: Event generated from
                                                                    pin specified in CONFIG[n].PSEL                            */
  __IM  uint32_t  RESERVED3[23];
  __IOM uint32_t  EVENTS_PORT;                  /*!< (@ 0x0000017C) Event generated from multiple input GPIO pins
                                                                    with SENSE mechanism enabled                               */
  __IM  uint32_t  RESERVED4[97];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED5[129];
  __IOM uint32_t  CONFIG[8];                    /*!< (@ 0x00000510) Description collection: Configuration for OUT[n],
                                                                    SET[n], and CLR[n] tasks and IN[n] event                   */
} NRF_GPIOTE_Type;



/* =========================================================================================================================== */
/* ================                                           SAADC                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Successive approximation register (SAR) analog-to-digital converter (SAADC)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts the SAADC and prepares the result buffer
                                                                    in RAM                                                     */
  __OM  uint32_t  TASKS_SAMPLE;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_CALIBRATEOFFSET;
  __IM  uint32_t  RESERVED[60];
  __IOM uint32_t  EVENTS_STARTED;
  __IOM uint32_t  EVENTS_END;
  __IOM uint32_t  EVENTS_DONE;                  /*!< (@ 0x00000108) A conversion task has been completed. Depending
                                                                    on the configuration, multiple conversions
                                                                    might be needed for a result to be transferred
                                                                    to RAM.                                                    */
  __IOM uint32_t  EVENTS_RESULTDONE;
  __IOM uint32_t  EVENTS_CALIBRATEDONE;
  __IOM uint32_t  EVENTS_STOPPED;
  __IOM SAADC_EVENTS_CH_Type EVENTS_CH[8];
  __IM  uint32_t  RESERVED1[106];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED2[61];
  __IM  uint32_t  STATUS;
  __IM  uint32_t  RESERVED3[63];
  __IOM uint32_t  ENABLE;
  __IM  uint32_t  RESERVED4[3];
  __IOM SAADC_CH_Type CH[8];
  __IM  uint32_t  RESERVED5[24];
  __IOM uint32_t  RESOLUTION;
  __IOM uint32_t  OVERSAMPLE;                   /*!< (@ 0x000005F4) Oversampling configuration. The RESOLUTION is
                                                                    applied before averaging, thus for high
                                                                    OVERSAMPLE a higher RESOLUTION should be
                                                                    used.                                                      */
  __IOM uint32_t  SAMPLERATE;
  __IM  uint32_t  RESERVED6[12];
  __IOM SAADC_RESULT_Type RESULT;
} NRF_SAADC_Type;



/* =========================================================================================================================== */
/* ================                                          TIMER0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Timer/Counter 0 (TIMER0)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_COUNT;
  __OM  uint32_t  TASKS_CLEAR;
  __OM  uint32_t  TASKS_SHUTDOWN;
  __IM  uint32_t  RESERVED[11];
  __OM  uint32_t  TASKS_CAPTURE[6];             /*!< (@ 0x00000040) Description collection: Capture Timer value to
                                                                    CC[n] register                                             */
  __IM  uint32_t  RESERVED1[58];
  __IOM uint32_t  EVENTS_COMPARE[6];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED2[42];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED3[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED4[126];
  __IOM uint32_t  MODE;
  __IOM uint32_t  BITMODE;
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  PRESCALER;
  __IM  uint32_t  RESERVED6[11];
  __IOM uint32_t  CC[6];                        /*!< (@ 0x00000540) Description collection: Capture/Compare register
                                                                    n                                                          */
} NRF_TIMER_Type;



/* =========================================================================================================================== */
/* ================                                           RTC0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Real time counter 0 (RTC0)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_CLEAR;
  __OM  uint32_t  TASKS_TRIGOVRFLW;
  __IM  uint32_t  RESERVED[60];
  __IOM uint32_t  EVENTS_TICK;
  __IOM uint32_t  EVENTS_OVRFLW;
  __IM  uint32_t  RESERVED1[14];
  __IOM uint32_t  EVENTS_COMPARE[4];            /*!< (@ 0x00000140) Description collection: Compare event on CC[n]
                                                                    match                                                      */
  __IM  uint32_t  RESERVED2[109];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED3[13];
  __IOM uint32_t  EVTEN;
  __IOM uint32_t  EVTENSET;
  __IOM uint32_t  EVTENCLR;
  __IM  uint32_t  RESERVED4[110];
  __IM  uint32_t  COUNTER;
  __IOM uint32_t  PRESCALER;                    /*!< (@ 0x00000508) 12 bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).
                                                                    Must be written when RTC is stopped.                       */
  __IM  uint32_t  RESERVED5[13];
  __IOM uint32_t  CC[4];
} NRF_RTC_Type;



/* =========================================================================================================================== */
/* ================                                           TEMP                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Temperature Sensor (TEMP)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_DATARDY;
  __IM  uint32_t  RESERVED1[128];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED2[127];
  __IM  int32_t   TEMP;
  __IM  uint32_t  RESERVED3[5];
  __IOM uint32_t  A0;
  __IOM uint32_t  A1;
  __IOM uint32_t  A2;
  __IOM uint32_t  A3;
  __IOM uint32_t  A4;
  __IOM uint32_t  A5;
  __IM  uint32_t  RESERVED4[2];
  __IOM uint32_t  B0;
  __IOM uint32_t  B1;
  __IOM uint32_t  B2;
  __IOM uint32_t  B3;
  __IOM uint32_t  B4;
  __IOM uint32_t  B5;
  __IM  uint32_t  RESERVED5[2];
  __IOM uint32_t  T0;
  __IOM uint32_t  T1;
  __IOM uint32_t  T2;
  __IOM uint32_t  T3;
  __IOM uint32_t  T4;
} NRF_TEMP_Type;



/* =========================================================================================================================== */
/* ================                                            RNG                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Random Number Generator (RNG)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_VALRDY;                /*!< (@ 0x00000100) Event being generated for every new random number
                                                                    written to the VALUE register                              */
  __IM  uint32_t  RESERVED1[63];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED2[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED3[126];
  __IOM uint32_t  CONFIG;
  __IM  uint32_t  VALUE;
} NRF_RNG_Type;



/* =========================================================================================================================== */
/* ================                                            ECB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AES ECB Mode Encryption (ECB)
  */

typedef struct {
  __OM  uint32_t  TASKS_STARTECB;
  __OM  uint32_t  TASKS_STOPECB;
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_ENDECB;
  __IOM uint32_t  EVENTS_ERRORECB;              /*!< (@ 0x00000104) ECB block encrypt aborted because of a STOPECB
                                                                    task or due to an error                                    */
  __IM  uint32_t  RESERVED1[127];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED2[126];
  __IOM uint32_t  ECBDATAPTR;
} NRF_ECB_Type;



/* =========================================================================================================================== */
/* ================                                            AAR                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Accelerated Address Resolver (AAR)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Start resolving addresses based on IRKs specified
                                                                    in the IRK data structure                                  */
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED1[61];
  __IOM uint32_t  EVENTS_END;
  __IOM uint32_t  EVENTS_RESOLVED;
  __IOM uint32_t  EVENTS_NOTRESOLVED;
  __IM  uint32_t  RESERVED2[126];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  STATUS;
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  NIRK;
  __IOM uint32_t  IRKPTR;
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  ADDRPTR;
  __IOM uint32_t  SCRATCHPTR;
} NRF_AAR_Type;



/* =========================================================================================================================== */
/* ================                                            CCM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief AES CCM mode encryption (CCM)
  */

typedef struct {
  __OM  uint32_t  TASKS_KSGEN;                  /*!< (@ 0x00000000) Start generation of keystream. This operation
                                                                    will stop by itself when completed.                        */
  __OM  uint32_t  TASKS_CRYPT;                  /*!< (@ 0x00000004) Start encryption/decryption. This operation will
                                                                    stop by itself when completed.                             */
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_RATEOVERRIDE;           /*!< (@ 0x0000000C) Override DATARATE setting in MODE register with
                                                                    the contents of the RATEOVERRIDE register
                                                                    for any ongoing encryption/decryption                      */
  __IM  uint32_t  RESERVED[60];
  __IOM uint32_t  EVENTS_ENDKSGEN;
  __IOM uint32_t  EVENTS_ENDCRYPT;
  __IOM uint32_t  EVENTS_ERROR;
  __IM  uint32_t  RESERVED1[61];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED2[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  MICSTATUS;
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  MODE;
  __IOM uint32_t  CNFPTR;                       /*!< (@ 0x00000508) Pointer to data structure holding the AES key
                                                                    and the NONCE vector                                       */
  __IOM uint32_t  INPTR;
  __IOM uint32_t  OUTPTR;
  __IOM uint32_t  SCRATCHPTR;
  __IOM uint32_t  MAXPACKETSIZE;                /*!< (@ 0x00000518) Length of keystream generated when MODE.LENGTH
                                                                    = Extended                                                 */
  __IOM uint32_t  RATEOVERRIDE;
} NRF_CCM_Type;



/* =========================================================================================================================== */
/* ================                                            WDT                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Watchdog Timer (WDT)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __IM  uint32_t  RESERVED[63];
  __IOM uint32_t  EVENTS_TIMEOUT;
  __IM  uint32_t  RESERVED1[128];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED2[61];
  __IM  uint32_t  RUNSTATUS;
  __IM  uint32_t  REQSTATUS;
  __IM  uint32_t  RESERVED3[63];
  __IOM uint32_t  CRV;
  __IOM uint32_t  RREN;
  __IOM uint32_t  CONFIG;
  __IM  uint32_t  RESERVED4[60];
  __OM  uint32_t  RR[8];
} NRF_WDT_Type;



/* =========================================================================================================================== */
/* ================                                           QDEC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Quadrature Decoder (QDEC)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_READCLRACC;
  __OM  uint32_t  TASKS_RDCLRACC;
  __OM  uint32_t  TASKS_RDCLRDBL;
  __IM  uint32_t  RESERVED[59];
  __IOM uint32_t  EVENTS_SAMPLERDY;             /*!< (@ 0x00000100) Event being generated for every new sample value
                                                                    written to the SAMPLE register                             */
  __IOM uint32_t  EVENTS_REPORTRDY;
  __IOM uint32_t  EVENTS_ACCOF;
  __IOM uint32_t  EVENTS_DBLRDY;
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED1[59];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED2[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED3[125];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  LEDPOL;
  __IOM uint32_t  SAMPLEPER;
  __IM  int32_t   SAMPLE;
  __IOM uint32_t  REPORTPER;                    /*!< (@ 0x00000510) Number of samples to be taken before REPORTRDY
                                                                    and DBLRDY events can be generated                         */
  __IM  int32_t   ACC;
  __IM  int32_t   ACCREAD;                      /*!< (@ 0x00000518) Snapshot of the ACC register, updated by the
                                                                    READCLRACC or RDCLRACC task                                */
  __IOM QDEC_PSEL_Type PSEL;
  __IOM uint32_t  DBFEN;
  __IM  uint32_t  RESERVED4[5];
  __IOM uint32_t  LEDPRE;
  __IM  uint32_t  ACCDBL;                       /*!< (@ 0x00000544) Register accumulating the number of detected
                                                                    double transitions                                         */
  __IM  uint32_t  ACCDBLREAD;                   /*!< (@ 0x00000548) Snapshot of the ACCDBL, updated by the READCLRACC
                                                                    or RDCLRDBL task                                           */
} NRF_QDEC_Type;



/* =========================================================================================================================== */
/* ================                                           COMP                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Comparator (COMP)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_SAMPLE;
  __IM  uint32_t  RESERVED[61];
  __IOM uint32_t  EVENTS_READY;
  __IOM uint32_t  EVENTS_DOWN;
  __IOM uint32_t  EVENTS_UP;
  __IOM uint32_t  EVENTS_CROSS;
  __IM  uint32_t  RESERVED1[60];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED2[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  RESULT;
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  PSEL;
  __IOM uint32_t  REFSEL;
  __IOM uint32_t  EXTREFSEL;
  __IM  uint32_t  RESERVED5[8];
  __IOM uint32_t  TH;
  __IOM uint32_t  MODE;
  __IOM uint32_t  HYST;
} NRF_COMP_Type;



/* =========================================================================================================================== */
/* ================                                          LPCOMP                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Low-power comparator (LPCOMP)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __OM  uint32_t  TASKS_SAMPLE;
  __IM  uint32_t  RESERVED[61];
  __IOM uint32_t  EVENTS_READY;
  __IOM uint32_t  EVENTS_DOWN;
  __IOM uint32_t  EVENTS_UP;
  __IOM uint32_t  EVENTS_CROSS;
  __IM  uint32_t  RESERVED1[60];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED2[64];
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED3[61];
  __IM  uint32_t  RESULT;
  __IM  uint32_t  RESERVED4[63];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  PSEL;
  __IOM uint32_t  REFSEL;
  __IOM uint32_t  EXTREFSEL;
  __IM  uint32_t  RESERVED5[4];
  __IOM uint32_t  ANADETECT;
  __IM  uint32_t  RESERVED6[5];
  __IOM uint32_t  HYST;
} NRF_LPCOMP_Type;



/* =========================================================================================================================== */
/* ================                                           EGU0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Event generator unit 0 (EGU0)
  */

typedef struct {
  __OM  uint32_t  TASKS_TRIGGER[16];            /*!< (@ 0x00000000) Description collection: Trigger n for triggering
                                                                    the corresponding TRIGGERED[n] event                       */
  __IM  uint32_t  RESERVED[48];
  __IOM uint32_t  EVENTS_TRIGGERED[16];         /*!< (@ 0x00000100) Description collection: Event number n generated
                                                                    by triggering the corresponding TRIGGER[n]
                                                                    task                                                       */
  __IM  uint32_t  RESERVED1[112];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
} NRF_EGU_Type;



/* =========================================================================================================================== */
/* ================                                           SWI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Software interrupt 0 (SWI0)
  */

typedef struct {
  __IM  uint32_t  UNUSED;
} NRF_SWI_Type;



/* =========================================================================================================================== */
/* ================                                           PWM0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse width modulation unit 0 (PWM0)
  */

typedef struct {
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops PWM pulse generation on all channels at
                                                                    the end of current PWM period, and stops
                                                                    sequence playback                                          */
  __OM  uint32_t  TASKS_SEQSTART[2];            /*!< (@ 0x00000008) Description collection: Loads the first PWM value
                                                                    on all enabled channels from sequence n,
                                                                    and starts playing that sequence at the
                                                                    rate defined in SEQ[n]REFRESH and/or DECODER.MODE.
                                                                    Causes PWM generation to start if not running.             */
  __OM  uint32_t  TASKS_NEXTSTEP;               /*!< (@ 0x00000010) Steps by one value in the current sequence on
                                                                    all enabled channels if DECODER.MODE=NextStep.
                                                                    Does not cause PWM generation to start if
                                                                    not running.                                               */
  __IM  uint32_t  RESERVED1[60];
  __IOM uint32_t  EVENTS_STOPPED;               /*!< (@ 0x00000104) Response to STOP task, emitted when PWM pulses
                                                                    are no longer generated                                    */
  __IOM uint32_t  EVENTS_SEQSTARTED[2];         /*!< (@ 0x00000108) Description collection: First PWM period started
                                                                    on sequence n                                              */
  __IOM uint32_t  EVENTS_SEQEND[2];             /*!< (@ 0x00000110) Description collection: Emitted at end of every
                                                                    sequence n, when last value from RAM has
                                                                    been applied to wave counter                               */
  __IOM uint32_t  EVENTS_PWMPERIODEND;
  __IOM uint32_t  EVENTS_LOOPSDONE;             /*!< (@ 0x0000011C) Concatenated sequences have been played the amount
                                                                    of times defined in LOOP.CNT                               */
  __IM  uint32_t  RESERVED2[56];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED3[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED4[125];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  MODE;
  __IOM uint32_t  COUNTERTOP;                   /*!< (@ 0x00000508) Value up to which the pulse generator counter
                                                                    counts                                                     */
  __IOM uint32_t  PRESCALER;
  __IOM uint32_t  DECODER;
  __IOM uint32_t  LOOP;
  __IM  uint32_t  RESERVED5[2];
  __IOM PWM_SEQ_Type SEQ[2];
  __IOM PWM_PSEL_Type PSEL;
} NRF_PWM_Type;



/* =========================================================================================================================== */
/* ================                                            PDM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Pulse Density Modulation (Digital Microphone) Interface (PDM)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;
  __OM  uint32_t  TASKS_STOP;
  __IM  uint32_t  RESERVED[62];
  __IOM uint32_t  EVENTS_STARTED;
  __IOM uint32_t  EVENTS_STOPPED;
  __IOM uint32_t  EVENTS_END;                   /*!< (@ 0x00000108) The PDM has written the last sample specified
                                                                    by SAMPLE.MAXCNT (or the last sample after
                                                                    a STOP task has been received) to Data RAM                 */
  __IM  uint32_t  RESERVED1[125];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED2[125];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  PDMCLKCTRL;
  __IOM uint32_t  MODE;                         /*!< (@ 0x00000508) Defines the routing of the connected PDM microphones'
                                                                    signals                                                    */
  __IM  uint32_t  RESERVED3[3];
  __IOM uint32_t  GAINL;
  __IOM uint32_t  GAINR;
  __IOM uint32_t  RATIO;                        /*!< (@ 0x00000520) Selects the ratio between PDM_CLK and output
                                                                    sample rate. Change PDMCLKCTRL accordingly.                */
  __IM  uint32_t  RESERVED4[7];
  __IOM PDM_PSEL_Type PSEL;
  __IM  uint32_t  RESERVED5[6];
  __IOM PDM_SAMPLE_Type SAMPLE;
} NRF_PDM_Type;



/* =========================================================================================================================== */
/* ================                                            ACL                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Access control lists (ACL)
  */

typedef struct {
  __IM  uint32_t  RESERVED[512];
  __IOM ACL_ACL_Type ACL[8];
} NRF_ACL_Type;



/* =========================================================================================================================== */
/* ================                                           NVMC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Non Volatile Memory Controller (NVMC)
  */

typedef struct {
  __IM  uint32_t  RESERVED[256];
  __IM  uint32_t  READY;
  __IM  uint32_t  RESERVED1;
  __IM  uint32_t  READYNEXT;
  __IM  uint32_t  RESERVED2[62];
  __IOM uint32_t  CONFIG;
  __OM  uint32_t  ERASEPAGE;
  __OM  uint32_t  ERASEALL;
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  ERASEUICR;                    /*!< (@ 0x00000514) Register for erasing user information configuration
                                                                    registers                                                  */
  __OM  uint32_t  ERASEPAGEPARTIAL;             /*!< (@ 0x00000518) Register for partial erase of a page in code
                                                                    area                                                       */
  __IOM uint32_t  ERASEPAGEPARTIALCFG;
  __IM  uint32_t  RESERVED4[8];
  __IOM uint32_t  ICACHECNF;
  __IM  uint32_t  RESERVED5;
  __IOM uint32_t  IHIT;
  __IOM uint32_t  IMISS;
} NRF_NVMC_Type;



/* =========================================================================================================================== */
/* ================                                            PPI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Programmable Peripheral Interconnect (PPI)
  */

typedef struct {
  __OM  PPI_TASKS_CHG_Type TASKS_CHG[6];
  __IM  uint32_t  RESERVED[308];
  __IOM uint32_t  CHEN;
  __IOM uint32_t  CHENSET;
  __IOM uint32_t  CHENCLR;
  __IM  uint32_t  RESERVED1;
  __IOM PPI_CH_Type CH[20];
  __IM  uint32_t  RESERVED2[148];
  __IOM uint32_t  CHG[6];
  __IM  uint32_t  RESERVED3[62];
  __IOM PPI_FORK_Type FORK[32];
} NRF_PPI_Type;



/* =========================================================================================================================== */
/* ================                                            MWU                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Memory Watch Unit (MWU)
  */

typedef struct {
  __IM  uint32_t  RESERVED[64];
  __IOM MWU_EVENTS_REGION_Type EVENTS_REGION[4];
  __IM  uint32_t  RESERVED1[16];
  __IOM MWU_EVENTS_PREGION_Type EVENTS_PREGION[2];
  __IM  uint32_t  RESERVED2[100];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED3[5];
  __IOM uint32_t  NMIEN;
  __IOM uint32_t  NMIENSET;
  __IOM uint32_t  NMIENCLR;
  __IM  uint32_t  RESERVED4[53];
  __IOM MWU_PERREGION_Type PERREGION[2];
  __IM  uint32_t  RESERVED5[64];
  __IOM uint32_t  REGIONEN;
  __IOM uint32_t  REGIONENSET;
  __IOM uint32_t  REGIONENCLR;
  __IM  uint32_t  RESERVED6[57];
  __IOM MWU_REGION_Type REGION[4];
  __IM  uint32_t  RESERVED7[32];
  __IOM MWU_PREGION_Type PREGION[2];
} NRF_MWU_Type;



/* =========================================================================================================================== */
/* ================                                            I2S                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Inter-IC Sound (I2S)
  */

typedef struct {
  __OM  uint32_t  TASKS_START;                  /*!< (@ 0x00000000) Starts continuous I2S transfer. Also starts MCK
                                                                    generator when this is enabled.                            */
  __OM  uint32_t  TASKS_STOP;                   /*!< (@ 0x00000004) Stops I2S transfer. Also stops MCK generator.
                                                                    Triggering this task will cause the STOPPED
                                                                    event to be generated.                                     */
  __IM  uint32_t  RESERVED[63];
  __IOM uint32_t  EVENTS_RXPTRUPD;              /*!< (@ 0x00000104) The RXD.PTR register has been copied to internal
                                                                    double-buffers. When the I2S module is started
                                                                    and RX is enabled, this event will be generated
                                                                    for every RXTXD.MAXCNT words that are received
                                                                    on the SDIN pin.                                           */
  __IOM uint32_t  EVENTS_STOPPED;
  __IM  uint32_t  RESERVED1[2];
  __IOM uint32_t  EVENTS_TXPTRUPD;              /*!< (@ 0x00000114) The TDX.PTR register has been copied to internal
                                                                    double-buffers. When the I2S module is started
                                                                    and TX is enabled, this event will be generated
                                                                    for every RXTXD.MAXCNT words that are sent
                                                                    on the SDOUT pin.                                          */
  __IM  uint32_t  RESERVED2[122];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED3[125];
  __IOM uint32_t  ENABLE;
  __IOM I2S_CONFIG_Type CONFIG;
  __IM  uint32_t  RESERVED4[3];
  __IOM I2S_RXD_Type RXD;
  __IM  uint32_t  RESERVED5;
  __IOM I2S_TXD_Type TXD;
  __IM  uint32_t  RESERVED6[3];
  __IOM I2S_RXTXD_Type RXTXD;
  __IM  uint32_t  RESERVED7[3];
  __IOM I2S_PSEL_Type PSEL;
} NRF_I2S_Type;



/* =========================================================================================================================== */
/* ================                                            FPU                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief FPU (FPU)
  */

typedef struct {
  __IM  uint32_t  UNUSED;
} NRF_FPU_Type;



/* =========================================================================================================================== */
/* ================                                           USBD                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Universal serial bus device (USBD)
  */

typedef struct {
  __IM  uint32_t  RESERVED;
  __OM  uint32_t  TASKS_STARTEPIN[8];           /*!< (@ 0x00000004) Description collection: Captures the EPIN[n].PTR
                                                                    and EPIN[n].MAXCNT registers values, and
                                                                    enables endpoint IN n to respond to traffic
                                                                    from host                                                  */
  __OM  uint32_t  TASKS_STARTISOIN;             /*!< (@ 0x00000024) Captures the ISOIN.PTR and ISOIN.MAXCNT registers
                                                                    values, and enables sending data on ISO
                                                                    endpoint                                                   */
  __OM  uint32_t  TASKS_STARTEPOUT[8];          /*!< (@ 0x00000028) Description collection: Captures the EPOUT[n].PTR
                                                                    and EPOUT[n].MAXCNT registers values, and
                                                                    enables endpoint n to respond to traffic
                                                                    from host                                                  */
  __OM  uint32_t  TASKS_STARTISOOUT;            /*!< (@ 0x00000048) Captures the ISOOUT.PTR and ISOOUT.MAXCNT registers
                                                                    values, and enables receiving of data on
                                                                    ISO endpoint                                               */
  __OM  uint32_t  TASKS_EP0RCVOUT;
  __OM  uint32_t  TASKS_EP0STATUS;
  __OM  uint32_t  TASKS_EP0STALL;               /*!< (@ 0x00000054) Stalls data and status stage on control endpoint
                                                                    0                                                          */
  __OM  uint32_t  TASKS_DPDMDRIVE;              /*!< (@ 0x00000058) Forces D+ and D- lines into the state defined
                                                                    in the DPDMVALUE register                                  */
  __OM  uint32_t  TASKS_DPDMNODRIVE;            /*!< (@ 0x0000005C) Stops forcing D+ and D- lines into any state
                                                                    (USB engine takes control)                                 */
  __IM  uint32_t  RESERVED1[40];
  __IOM uint32_t  EVENTS_USBRESET;              /*!< (@ 0x00000100) Signals that a USB reset condition has been detected
                                                                    on USB lines                                               */
  __IOM uint32_t  EVENTS_STARTED;               /*!< (@ 0x00000104) Confirms that the EPIN[n].PTR and EPIN[n].MAXCNT,
                                                                    or EPOUT[n].PTR and EPOUT[n].MAXCNT registers
                                                                    have been captured on all endpoints reported
                                                                    in the EPSTATUS register                                   */
  __IOM uint32_t  EVENTS_ENDEPIN[8];            /*!< (@ 0x00000108) Description collection: The whole EPIN[n] buffer
                                                                    has been consumed. The buffer can be accessed
                                                                    safely by software.                                        */
  __IOM uint32_t  EVENTS_EP0DATADONE;           /*!< (@ 0x00000128) An acknowledged data transfer has taken place
                                                                    on the control endpoint                                    */
  __IOM uint32_t  EVENTS_ENDISOIN;              /*!< (@ 0x0000012C) The whole ISOIN buffer has been consumed. The
                                                                    buffer can be accessed safely by software.                 */
  __IOM uint32_t  EVENTS_ENDEPOUT[8];           /*!< (@ 0x00000130) Description collection: The whole EPOUT[n] buffer
                                                                    has been consumed. The buffer can be accessed
                                                                    safely by software.                                        */
  __IOM uint32_t  EVENTS_ENDISOOUT;             /*!< (@ 0x00000150) The whole ISOOUT buffer has been consumed. The
                                                                    buffer can be accessed safely by software.                 */
  __IOM uint32_t  EVENTS_SOF;                   /*!< (@ 0x00000154) Signals that a SOF (start of frame) condition
                                                                    has been detected on USB lines                             */
  __IOM uint32_t  EVENTS_USBEVENT;              /*!< (@ 0x00000158) An event or an error not covered by specific
                                                                    events has occurred. Check EVENTCAUSE register
                                                                    to find the cause.                                         */
  __IOM uint32_t  EVENTS_EP0SETUP;              /*!< (@ 0x0000015C) A valid SETUP token has been received (and acknowledged)
                                                                    on the control endpoint                                    */
  __IOM uint32_t  EVENTS_EPDATA;                /*!< (@ 0x00000160) A data transfer has occurred on a data endpoint,
                                                                    indicated by the EPDATASTATUS register                     */
  __IM  uint32_t  RESERVED2[39];
  __IOM uint32_t  SHORTS;
  __IM  uint32_t  RESERVED3[63];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED4[61];
  __IOM uint32_t  EVENTCAUSE;
  __IM  uint32_t  RESERVED5[7];
  __IOM USBD_HALTED_Type HALTED;
  __IM  uint32_t  RESERVED6;
  __IOM uint32_t  EPSTATUS;                     /*!< (@ 0x00000468) Provides information on which endpoint's EasyDMA
                                                                    registers have been captured                               */
  __IOM uint32_t  EPDATASTATUS;                 /*!< (@ 0x0000046C) Provides information on which endpoint(s) an
                                                                    acknowledged data transfer has occurred
                                                                    (EPDATA event)                                             */
  __IM  uint32_t  USBADDR;
  __IM  uint32_t  RESERVED7[3];
  __IM  uint32_t  BMREQUESTTYPE;
  __IM  uint32_t  BREQUEST;
  __IM  uint32_t  WVALUEL;
  __IM  uint32_t  WVALUEH;
  __IM  uint32_t  WINDEXL;
  __IM  uint32_t  WINDEXH;
  __IM  uint32_t  WLENGTHL;
  __IM  uint32_t  WLENGTHH;
  __IOM USBD_SIZE_Type SIZE;
  __IM  uint32_t  RESERVED8[15];
  __IOM uint32_t  ENABLE;
  __IOM uint32_t  USBPULLUP;
  __IOM uint32_t  DPDMVALUE;                    /*!< (@ 0x00000508) State D+ and D- lines will be forced into by
                                                                    the DPDMDRIVE task. The DPDMNODRIVE task
                                                                    reverts the control of the lines to MAC
                                                                    IP (no forcing).                                           */
  __IOM uint32_t  DTOGGLE;
  __IOM uint32_t  EPINEN;
  __IOM uint32_t  EPOUTEN;
  __OM  uint32_t  EPSTALL;
  __IOM uint32_t  ISOSPLIT;
  __IM  uint32_t  FRAMECNTR;                    /*!< (@ 0x00000520) Returns the current value of the start of frame
                                                                    counter                                                    */
  __IM  uint32_t  RESERVED9[2];
  __IOM uint32_t  LOWPOWER;                     /*!< (@ 0x0000052C) Controls USBD peripheral low power mode during
                                                                    USB suspend                                                */
  __IOM uint32_t  ISOINCONFIG;                  /*!< (@ 0x00000530) Controls the response of the ISO IN endpoint
                                                                    to an IN token when no data is ready to
                                                                    be sent                                                    */
  __IM  uint32_t  RESERVED10[51];
  __IOM USBD_EPIN_Type EPIN[8];
  __IOM USBD_ISOIN_Type ISOIN;
  __IM  uint32_t  RESERVED11[21];
  __IOM USBD_EPOUT_Type EPOUT[8];
  __IOM USBD_ISOOUT_Type ISOOUT;
} NRF_USBD_Type;



/* =========================================================================================================================== */
/* ================                                           QSPI                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief External flash interface (QSPI)
  */

typedef struct {
  __OM  uint32_t  TASKS_ACTIVATE;
  __OM  uint32_t  TASKS_READSTART;              /*!< (@ 0x00000004) Start transfer from external flash memory to
                                                                    internal RAM                                               */
  __OM  uint32_t  TASKS_WRITESTART;             /*!< (@ 0x00000008) Start transfer from internal RAM to external
                                                                    flash memory                                               */
  __OM  uint32_t  TASKS_ERASESTART;
  __OM  uint32_t  TASKS_DEACTIVATE;
  __IM  uint32_t  RESERVED[59];
  __IOM uint32_t  EVENTS_READY;                 /*!< (@ 0x00000100) QSPI peripheral is ready. This event will be
                                                                    generated as a response to any QSPI task.                  */
  __IM  uint32_t  RESERVED1[127];
  __IOM uint32_t  INTEN;
  __IOM uint32_t  INTENSET;
  __IOM uint32_t  INTENCLR;
  __IM  uint32_t  RESERVED2[125];
  __IOM uint32_t  ENABLE;                       /*!< (@ 0x00000500) Enable QSPI peripheral and acquire the pins selected
                                                                    in PSELn registers                                         */
  __IOM QSPI_READ_Type READ;
  __IOM QSPI_WRITE_Type WRITE;
  __IOM QSPI_ERASE_Type ERASE;
  __IOM QSPI_PSEL_Type PSEL;
  __IOM uint32_t  XIPOFFSET;                    /*!< (@ 0x00000540) Address offset into the external memory for Execute
                                                                    in Place operation.                                        */
  __IOM uint32_t  IFCONFIG0;
  __IM  uint32_t  RESERVED3[46];
  __IOM uint32_t  IFCONFIG1;
  __IM  uint32_t  STATUS;
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  DPMDUR;                       /*!< (@ 0x00000614) Set the duration required to enter/exit deep
                                                                    power-down mode (DPM).                                     */
  __IM  uint32_t  RESERVED5[3];
  __IOM uint32_t  ADDRCONF;
  __IM  uint32_t  RESERVED6[3];
  __IOM uint32_t  CINSTRCONF;
  __IOM uint32_t  CINSTRDAT0;
  __IOM uint32_t  CINSTRDAT1;
  __IOM uint32_t  IFTIMING;
} NRF_QSPI_Type;



/* =========================================================================================================================== */
/* ================                                        CRYPTOCELL                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL register interface (CRYPTOCELL)
  */

typedef struct {
  __IM  uint32_t  RESERVED[320];
  __IOM uint32_t  ENABLE;
} NRF_CRYPTOCELL_Type;



/* =========================================================================================================================== */
/* ================                                          CC_AES                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL AES engine (CC_AES)
  */

typedef struct {
  __IM  uint32_t  RESERVED[256];
  __OM  uint32_t  AES_KEY_0[8];                 /*!< (@ 0x00000400) Description collection: AES key value to use.
                                                                    The initial AES_KEY_0[0] register holds
                                                                    the least significant bits [31:0] of the
                                                                    key value.                                                 */
  __IM  uint32_t  RESERVED1[8];
  __IOM uint32_t  AES_IV_0[4];                  /*!< (@ 0x00000440) Description collection: AES Initialization Vector
                                                                    (IV) to use. The initial AES_IV_0[0] register
                                                                    holds the least significant bits [31:0]
                                                                    of the IV.                                                 */
  __IM  uint32_t  RESERVED2[4];
  __IOM uint32_t  AES_CTR[4];                   /*!< (@ 0x00000460) Description collection: AES counter (CTR) to
                                                                    use. The initial AES_CTR[0] register holds
                                                                    the least significant bits [31:0] of the
                                                                    CTR.                                                       */
  __IM  uint32_t  AES_BUSY;
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  AES_SK;                       /*!< (@ 0x00000478) Writing to this address trigger sampling of the
                                                                    HW key to the AES_KEY_0 register                           */
  __OM  uint32_t  AES_CMAC_INIT;                /*!< (@ 0x0000047C) Writing to this address triggers the AES engine
                                                                    to generate K1 and K2 for AES-CMAC operations.             */
  __IM  uint32_t  RESERVED4[15];
  __IOM uint32_t  AES_REMAINING_BYTES;          /*!< (@ 0x000004BC) This register should be set with the amount of
                                                                    remaining bytes until the end of the current
                                                                    AES operation.                                             */
  __IOM uint32_t  AES_CONTROL;
  __IM  uint32_t  RESERVED5;
  __IM  uint32_t  AES_HW_FLAGS;                 /*!< (@ 0x000004C8) Hardware configuration of the AES engine. Reset
                                                                    value holds the supported features.                        */
  __IM  uint32_t  RESERVED6[3];
  __IOM uint32_t  AES_CTR_NO_INCREMENT;         /*!< (@ 0x000004D8) This register enables the AES CTR no increment
                                                                    mode in which the counter mode is not incremented
                                                                    between two blocks                                         */
  __IM  uint32_t  RESERVED7[6];
  __OM  uint32_t  AES_SW_RESET;
  __IM  uint32_t  RESERVED8[11];
  __OM  uint32_t  AES_CMAC_SIZE0_KICK;          /*!< (@ 0x00000524) Writing to this address triggers the AES engine
                                                                    to perform a CMAC operation with size 0.
                                                                    The CMAC result can be read from the AES_IV_0
                                                                    register.                                                  */
} NRF_CC_AES_Type;



/* =========================================================================================================================== */
/* ================                                         CC_CHACHA                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL CHACHA engine (CC_CHACHA)
  */

typedef struct {
  __IM  uint32_t  RESERVED[224];
  __IOM uint32_t  CHACHA_CONTROL;
  __IM  uint32_t  CHACHA_VERSION;
  __OM  uint32_t  CHACHA_KEY[8];                /*!< (@ 0x00000388) Description collection: CHACHA key value to use.
                                                                    The initial CHACHA_KEY[0] register holds
                                                                    the least significant bits [31:0] of the
                                                                    key value.                                                 */
  __IOM uint32_t  CHACHA_IV[2];                 /*!< (@ 0x000003A8) Description collection: CHACHA Initialization
                                                                    Vector (IV) to use. The IV is also known
                                                                    as the nonce.                                              */
  __IM  uint32_t  CHACHA_BUSY;
  __IM  uint32_t  CHACHA_HW_FLAGS;              /*!< (@ 0x000003B4) Hardware configuration of the CHACHA engine.
                                                                    Reset value holds the supported features.                  */
  __IOM uint32_t  CHACHA_BLOCK_CNT_LSB;         /*!< (@ 0x000003B8) Store the LSB value of the block counter, in
                                                                    order to support suspend/resume of operation               */
  __IOM uint32_t  CHACHA_BLOCK_CNT_MSB;         /*!< (@ 0x000003BC) Store the MSB value of the block counter, in
                                                                    order to support suspend/resume of operation               */
  __OM  uint32_t  CHACHA_SW_RESET;
  __IM  uint32_t  CHACHA_POLY1305_KEY[8];       /*!< (@ 0x000003C4) Description collection: The auto-generated key
                                                                    to use in Poly1305 MAC calculation. The
                                                                    initial CHACHA_POLY1305_KEY[0] register
                                                                    holds the least significant bits [31:0]
                                                                    of the key value.                                          */
  __IOM uint32_t  CHACHA_ENDIANNESS;
  __IM  uint32_t  CHACHA_DEBUG;
} NRF_CC_CHACHA_Type;



/* =========================================================================================================================== */
/* ================                                          CC_CTL                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL CTL interface (CC_CTL)
  */

typedef struct {
  __IM  uint32_t  RESERVED[576];
  __OM  uint32_t  CRYPTO_CTL;
  __IM  uint32_t  RESERVED1[3];
  __IM  uint32_t  CRYPTO_BUSY;                  /*!< (@ 0x00000910) Status register for cryptographic cores engine
                                                                    activity.                                                  */
  __IM  uint32_t  RESERVED2[2];
  __IM  uint32_t  HASH_BUSY;
  __IM  uint32_t  RESERVED3[4];
  __IOM uint32_t  CONTEXT_ID;
} NRF_CC_CTL_Type;



/* =========================================================================================================================== */
/* ================                                          CC_DIN                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL Data IN interface (CC_DIN)
  */

typedef struct {
  __IM  uint32_t  RESERVED[768];
  __OM  uint32_t  DIN_BUFFER;                   /*!< (@ 0x00000C00) Used by CPU to write data directly to the DIN
                                                                    buffer, which is then sent to the cryptographic
                                                                    engines for processing.                                    */
  __IM  uint32_t  RESERVED1[7];
  __IM  uint32_t  DIN_DMA_MEM_BUSY;             /*!< (@ 0x00000C20) Status register for DIN DMA engine activity when
                                                                    accessing memory.                                          */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  SRC_MEM_ADDR;
  __OM  uint32_t  SRC_MEM_SIZE;                 /*!< (@ 0x00000C2C) The number of bytes to be read from memory. Writing
                                                                    to this register triggers the DMA operation.               */
  __IOM uint32_t  SRC_SRAM_ADDR;
  __OM  uint32_t  SRC_SRAM_SIZE;                /*!< (@ 0x00000C34) The number of bytes to be read from RNG SRAM.
                                                                    Writing to this register triggers the DMA
                                                                    operation.                                                 */
  __IM  uint32_t  DIN_DMA_SRAM_BUSY;            /*!< (@ 0x00000C38) Status register for DIN DMA engine activity when
                                                                    accessing RNG SRAM.                                        */
  __IOM uint32_t  DIN_DMA_SRAM_ENDIANNESS;      /*!< (@ 0x00000C3C) Configure the endianness of DIN DMA transactions
                                                                    towards RNG SRAM.                                          */
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  DIN_SW_RESET;
  __OM  uint32_t  DIN_CPU_DATA;                 /*!< (@ 0x00000C48) Specifies the number of bytes the CPU will write
                                                                    to the DIN_BUFFER, ensuring the cryptographic
                                                                    engine processes the correct amount of data.               */
  __OM  uint32_t  DIN_WRITE_ALIGN;              /*!< (@ 0x00000C4C) Indicates that the next CPU write to the DIN_BUFFER
                                                                    is the last in the sequence. This is needed
                                                                    only when the data size is NOT modulo 4
                                                                    (e.g. HASH padding).                                       */
  __IM  uint32_t  DIN_FIFO_EMPTY;               /*!< (@ 0x00000C50) Register indicating if DIN FIFO is empty and
                                                                    if more data can be accepted.                              */
  __IM  uint32_t  RESERVED4;
  __OM  uint32_t  DIN_FIFO_RESET;               /*!< (@ 0x00000C58) Reset the DIN FIFO, effectively clearing the
                                                                    FIFO for new data.                                         */
} NRF_CC_DIN_Type;



/* =========================================================================================================================== */
/* ================                                          CC_DOUT                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL Data OUT interface (CC_DOUT)
  */

typedef struct {
  __IM  uint32_t  RESERVED[768];
  __IM  uint32_t  DOUT_BUFFER;                  /*!< (@ 0x00000C00) Cryptographic results directly accessible by
                                                                    the CPU.                                                   */
  __IM  uint32_t  RESERVED1[71];
  __IM  uint32_t  DOUT_DMA_MEM_BUSY;            /*!< (@ 0x00000D20) Status register for DOUT DMA engine activity
                                                                    when accessing memory.                                     */
  __IM  uint32_t  RESERVED2;
  __OM  uint32_t  DST_MEM_ADDR;
  __OM  uint32_t  DST_MEM_SIZE;
  __IOM uint32_t  DST_SRAM_ADDR;
  __OM  uint32_t  DST_SRAM_SIZE;
  __IM  uint32_t  DOUT_DMA_SRAM_BUSY;           /*!< (@ 0x00000D38) Status register for DOUT DMA engine activity
                                                                    when accessing RNG SRAM.                                   */
  __IOM uint32_t  DOUT_DMA_SRAM_ENDIANNESS;     /*!< (@ 0x00000D3C) Configure the endianness of DOUT DMA transactions
                                                                    towards RNG SRAM.                                          */
  __IM  uint32_t  RESERVED3;
  __OM  uint32_t  DOUT_READ_ALIGN;              /*!< (@ 0x00000D44) Indication that the next CPU read from the DOUT_BUFFER
                                                                    is the last in the sequence. This is needed
                                                                    only when the data size is NOT modulo 4
                                                                    (e.g. HASH padding).                                       */
  __IM  uint32_t  RESERVED4[2];
  __IM  uint32_t  DOUT_FIFO_EMPTY;              /*!< (@ 0x00000D50) Register indicating if DOUT FIFO is empty or
                                                                    if more data will come.                                    */
  __IM  uint32_t  RESERVED5;
  __OM  uint32_t  DOUT_SW_RESET;
} NRF_CC_DOUT_Type;



/* =========================================================================================================================== */
/* ================                                          CC_HASH                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL HASH engine (CC_HASH)
  */

typedef struct {
  __IM  uint32_t  RESERVED[400];
  __IOM uint32_t  HASH_H[8];                    /*!< (@ 0x00000640) Description collection: HASH_H value registers.
                                                                    The initial HASH_H[0] register holds the
                                                                    least significant bits [31:0] of the value.                */
  __IM  uint32_t  RESERVED1[9];
  __OM  uint32_t  HASH_PAD_AUTO;                /*!< (@ 0x00000684) Configure the HASH engine to automatically pad
                                                                    data at the end of the DMA transfer to complete
                                                                    the digest operation.                                      */
  __IM  uint32_t  RESERVED2[3];
  __OM  uint32_t  HASH_INIT_STATE;
  __IM  uint32_t  RESERVED3[70];
  __IM  uint32_t  HASH_VERSION;
  __IM  uint32_t  RESERVED4[3];
  __IOM uint32_t  HASH_CONTROL;
  __IOM uint32_t  HASH_PAD;                     /*!< (@ 0x000007C4) Enable the hardware padding feature of the HASH
                                                                    engine.                                                    */
  __IOM uint32_t  HASH_PAD_FORCE;               /*!< (@ 0x000007C8) Force the hardware padding operation to trigger
                                                                    if the input data length is zero bytes.                    */
  __IOM uint32_t  HASH_CUR_LEN_0;               /*!< (@ 0x000007CC) Bits [31:0] of the number of bytes that have
                                                                    been digested so far.                                      */
  __IOM uint32_t  HASH_CUR_LEN_1;               /*!< (@ 0x000007D0) Bits [63:32] of the number of bytes that have
                                                                    been digested so far.                                      */
  __IM  uint32_t  RESERVED5[2];
  __IM  uint32_t  HASH_HW_FLAGS;                /*!< (@ 0x000007DC) Hardware configuration of the HASH engine. Reset
                                                                    value holds the supported features.                        */
  __IM  uint32_t  RESERVED6;
  __OM  uint32_t  HASH_SW_RESET;
  __IOM uint32_t  HASH_ENDIANNESS;              /*!< (@ 0x000007E8) Configure the endianness of HASH data and padding
                                                                    generation.                                                */
} NRF_CC_HASH_Type;



/* =========================================================================================================================== */
/* ================                                        CC_HOST_RGF                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL HOST register interface (CC_HOST_RGF)
  */

typedef struct {
  __IM  uint32_t  RESERVED[640];
  __IM  uint32_t  IRR;                          /*!< (@ 0x00000A00) Interrupt request register. Each bit of this
                                                                    register holds the interrupt status of a
                                                                    single interrupt source. If corresponding
                                                                    IMR bit is unmasked, an interrupt is generated.            */
  __IOM uint32_t  IMR;                          /*!< (@ 0x00000A04) Interrupt mask register. Each bit of this register
                                                                    holds the mask of a single interrupt source.               */
  __OM  uint32_t  ICR;                          /*!< (@ 0x00000A08) Interrupt clear register. Writing a 1 bit into
                                                                    a field in this register will clear the
                                                                    corresponding bit in IRR.                                  */
  __IOM uint32_t  ENDIANNESS;                   /*!< (@ 0x00000A0C) This register defines the endianness of the Host-accessible
                                                                    registers, and can only be written once.                   */
  __IM  uint32_t  RESERVED1[5];
  __IM  uint32_t  HOST_SIGNATURE;               /*!< (@ 0x00000A24) This register holds the CRYPTOCELL subsystem
                                                                    signature. See reset value.                                */
  __IM  uint32_t  HOST_BOOT;                    /*!< (@ 0x00000A28) Hardware configuration of the CRYPTOCELL subsystem.
                                                                    Reset value holds the supported features.                  */
  __IM  uint32_t  RESERVED2[3];
  __IOM uint32_t  HOST_CRYPTOKEY_SEL;
  __IM  uint32_t  RESERVED3[4];
  __IOM uint32_t  HOST_IOT_KPRTL_LOCK;          /*!< (@ 0x00000A4C) This write-once register is the K_PRTL lock register.
                                                                    When this register is set, K_PRTL cannot
                                                                    be used and a zeroed key will be used instead.
                                                                    The value of this register is saved in the
                                                                    CRYPTOCELL AO power domain.                                */
  __IOM uint32_t  HOST_IOT_KDR0;                /*!< (@ 0x00000A50) This register holds bits 31:0 of K_DR. The value
                                                                    of this register is saved in the CRYPTOCELL
                                                                    AO power domain. Reading from this address
                                                                    returns the K_DR valid status indicating
                                                                    if K_DR is successfully retained.                          */
  __OM  uint32_t  HOST_IOT_KDR1;                /*!< (@ 0x00000A54) This register holds bits 63:32 of K_DR. The value
                                                                    of this register is saved in the CRYPTOCELL
                                                                    AO power domain.                                           */
  __OM  uint32_t  HOST_IOT_KDR2;                /*!< (@ 0x00000A58) This register holds bits 95:64 of K_DR. The value
                                                                    of this register is saved in the CRYPTOCELL
                                                                    AO power domain.                                           */
  __OM  uint32_t  HOST_IOT_KDR3;                /*!< (@ 0x00000A5C) This register holds bits 127:96 of K_DR. The
                                                                    value of this register is saved in the CRYPTOCELL
                                                                    AO power domain.                                           */
  __IOM uint32_t  HOST_IOT_LCS;                 /*!< (@ 0x00000A60) Controls life-cycle state (LCS) for CRYPTOCELL
                                                                    subsystem                                                  */
} NRF_CC_HOST_RGF_Type;



/* =========================================================================================================================== */
/* ================                                          CC_MISC                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL MISC interface (CC_MISC)
  */

typedef struct {
  __IM  uint32_t  RESERVED[516];
  __OM  uint32_t  AES_CLK;
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  HASH_CLK;
  __OM  uint32_t  PKA_CLK;
  __OM  uint32_t  DMA_CLK;
  __IM  uint32_t  CLK_STATUS;
  __IM  uint32_t  RESERVED2[12];
  __OM  uint32_t  CHACHA_CLK;
} NRF_CC_MISC_Type;



/* =========================================================================================================================== */
/* ================                                          CC_PKA                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL PKA engine (CC_PKA)
  */

typedef struct {
  __IOM uint32_t  MEMORY_MAP[32];               /*!< (@ 0x00000000) Description collection: Register for mapping
                                                                    the virtual register R[n] to a physical
                                                                    address in the PKA SRAM.                                   */
  __IOM uint32_t  OPCODE;                       /*!< (@ 0x00000080) Operation code to be executed by the PKA engine.
                                                                    Writing to this register triggers the PKA
                                                                    operation.                                                 */
  __IOM uint32_t  N_NP_T0_T1_ADDR;              /*!< (@ 0x00000084) This register defines the N, Np, T0, and T1 virtual
                                                                    register index.                                            */
  __IM  uint32_t  PKA_STATUS;
  __OM  uint32_t  PKA_SW_RESET;
  __IOM uint32_t  PKA_L[8];                     /*!< (@ 0x00000090) Description collection: This register holds the
                                                                    operands bit size.                                         */
  __IM  uint32_t  PKA_PIPE;                     /*!< (@ 0x000000B0) Status register indicating if the PKA pipeline
                                                                    is ready to receive a new OPCODE.                          */
  __IM  uint32_t  PKA_DONE;                     /*!< (@ 0x000000B4) Status register indicating if the PKA operation
                                                                    has been completed.                                        */
  __IM  uint32_t  RESERVED[3];
  __IM  uint32_t  PKA_VERSION;                  /*!< (@ 0x000000C4) PKA engine HW version. Reset value holds the
                                                                    version.                                                   */
  __IM  uint32_t  RESERVED1[3];
  __OM  uint32_t  PKA_SRAM_WADDR;               /*!< (@ 0x000000D4) Start address in PKA SRAM for subsequent write
                                                                    transactions.                                              */
  __OM  uint32_t  PKA_SRAM_WDATA;               /*!< (@ 0x000000D8) Write data to PKA SRAM. Writing to this register
                                                                    triggers a DMA transaction writing data
                                                                    into PKA SRAM. The DMA address offset is
                                                                    automatically incremented during write.                    */
  __IM  uint32_t  PKA_SRAM_RDATA;               /*!< (@ 0x000000DC) Read data from PKA SRAM. Reading from this register
                                                                    triggers a DMA transaction read data from
                                                                    PKA SRAM. The DMA address offset is automatically
                                                                    incremented during read.                                   */
  __OM  uint32_t  PKA_SRAM_WCLEAR;
  __OM  uint32_t  PKA_SRAM_RADDR;               /*!< (@ 0x000000E4) Start address in PKA SRAM for subsequent read
                                                                    transactions.                                              */
} NRF_CC_PKA_Type;



/* =========================================================================================================================== */
/* ================                                          CC_RNG                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL RNG engine (CC_RNG)
  */

typedef struct {
  __IM  uint32_t  RESERVED[64];
  __IOM uint32_t  RNG_IMR;                      /*!< (@ 0x00000100) Interrupt mask register. Each bit of this register
                                                                    holds the mask of a single interrupt source.               */
  __IM  uint32_t  RNG_ISR;                      /*!< (@ 0x00000104) Interrupt status register. Each bit of this register
                                                                    holds the interrupt status of a single interrupt
                                                                    source. If corresponding RNG_IMR bit is
                                                                    unmasked, an interrupt is generated.                       */
  __OM  uint32_t  RNG_ICR;                      /*!< (@ 0x00000108) Interrupt clear register. Writing a 1 bit into
                                                                    a field in this register will clear the
                                                                    corresponding bit in RNG_ISR.                              */
  __IOM uint32_t  TRNG_CONFIG;
  __IM  uint32_t  TRNG_VALID;                   /*!< (@ 0x00000110) This register indicates if TRNG entropy collection
                                                                    is valid.                                                  */
  __IM  uint32_t  EHR_DATA[6];                  /*!< (@ 0x00000114) Description collection: The entropy holding registers
                                                                    (EHR) hold 192-bits random data collected
                                                                    by the TRNG. The initial EHR_DATA[0] register
                                                                    holds the least significant bits [31:0]
                                                                    of the random data value.                                  */
  __IOM uint32_t  NOISE_SOURCE;                 /*!< (@ 0x0000012C) This register controls the ring oscillator circuit
                                                                    used as a noise source.                                    */
  __IOM uint32_t  SAMPLE_CNT;                   /*!< (@ 0x00000130) Sample count defining the number of CPU clock
                                                                    cycles between two consecutive noise source
                                                                    samples.                                                   */
  __IOM uint32_t  AUTOCORR_STATISTIC;           /*!< (@ 0x00000134) Statistics counter for autocorrelation test activations.
                                                                    Statistics collection is stopped if one
                                                                    of the counters reach its limit of all ones.               */
  __IOM uint32_t  TRNG_DEBUG;                   /*!< (@ 0x00000138) Debug register for the TRNG. This register is
                                                                    used to bypass TRNG tests in hardware.                     */
  __IM  uint32_t  RESERVED1;
  __OM  uint32_t  RNG_SW_RESET;
  __IM  uint32_t  RESERVED2[29];
  __IM  uint32_t  RNG_BUSY;
  __OM  uint32_t  TRNG_RESET;                   /*!< (@ 0x000001BC) Reset the TRNG, including internal counter of
                                                                    collected bits and registers EHR_DATA and
                                                                    TRNG_VALID.                                                */
  __IM  uint32_t  RNG_HW_FLAGS;                 /*!< (@ 0x000001C0) Hardware configuration of RNG engine. Reset value
                                                                    holds the supported features.                              */
  __OM  uint32_t  RNG_CLK;
  __IOM uint32_t  RNG_DMA;                      /*!< (@ 0x000001C8) Writing to this register enables the RNG DMA
                                                                    engine.                                                    */
  __IOM uint32_t  RNG_DMA_ROSC_LEN;             /*!< (@ 0x000001CC) This register defines which ring oscillator length
                                                                    configuration should be used when using
                                                                    the RNG DMA engine.                                        */
  __IOM uint32_t  RNG_DMA_SRAM_ADDR;            /*!< (@ 0x000001D0) This register defines the start address in TRNG
                                                                    SRAM for the TRNG data to be collected by
                                                                    the RNG DMA engine.                                        */
  __IOM uint32_t  RNG_DMA_SAMPLES_NUM;          /*!< (@ 0x000001D4) This register defines the number of 192-bits
                                                                    samples that the RNG DMA engine collects
                                                                    per run.                                                   */
  __IOM uint32_t  RNG_WATCHDOG_VAL;             /*!< (@ 0x000001D8) This register defines the maximum number of CPU
                                                                    clock cycles per TRNG collection of 192-bits
                                                                    samples. If the number of cycles for a collection
                                                                    exceeds this threshold the WATCHDOG interrupt
                                                                    is triggered.                                              */
  __IM  uint32_t  RNG_DMA_BUSY;
} NRF_CC_RNG_Type;



/* =========================================================================================================================== */
/* ================                                        CC_RNG_SRAM                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief CRYPTOCELL RNG SRAM interface (CC_RNG_SRAM)
  */

typedef struct {
  __IM  uint32_t  RESERVED[960];
  __IOM uint32_t  SRAM_DATA;
  __OM  uint32_t  SRAM_ADDR;                    /*!< (@ 0x00000F04) First address given to RNG SRAM DMA for read/write
                                                                    transactions from/to RNG SRAM.                             */
  __IM  uint32_t  SRAM_DATA_READY;              /*!< (@ 0x00000F08) RNG SRAM DMA engine is ready to read/write from/to
                                                                    RNG SRAM.                                                  */
} NRF_CC_RNG_SRAM_Type;


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define NRF_FICR_BASE               0x10000000UL
#define NRF_UICR_BASE               0x10001000UL
#define NRF_APPROTECT_BASE          0x40000000UL
#define NRF_CLOCK_BASE              0x40000000UL
#define NRF_POWER_BASE              0x40000000UL
#define NRF_P0_BASE                 0x50000000UL
#define NRF_P1_BASE                 0x50000300UL
#define NRF_RADIO_BASE              0x40001000UL
#define NRF_UART0_BASE              0x40002000UL
#define NRF_UARTE0_BASE             0x40002000UL
#define NRF_SPI0_BASE               0x40003000UL
#define NRF_SPIM0_BASE              0x40003000UL
#define NRF_SPIS0_BASE              0x40003000UL
#define NRF_TWI0_BASE               0x40003000UL
#define NRF_TWIM0_BASE              0x40003000UL
#define NRF_TWIS0_BASE              0x40003000UL
#define NRF_SPI1_BASE               0x40004000UL
#define NRF_SPIM1_BASE              0x40004000UL
#define NRF_SPIS1_BASE              0x40004000UL
#define NRF_TWI1_BASE               0x40004000UL
#define NRF_TWIM1_BASE              0x40004000UL
#define NRF_TWIS1_BASE              0x40004000UL
#define NRF_NFCT_BASE               0x40005000UL
#define NRF_GPIOTE_BASE             0x40006000UL
#define NRF_SAADC_BASE              0x40007000UL
#define NRF_TIMER0_BASE             0x40008000UL
#define NRF_TIMER1_BASE             0x40009000UL
#define NRF_TIMER2_BASE             0x4000A000UL
#define NRF_RTC0_BASE               0x4000B000UL
#define NRF_TEMP_BASE               0x4000C000UL
#define NRF_RNG_BASE                0x4000D000UL
#define NRF_ECB_BASE                0x4000E000UL
#define NRF_AAR_BASE                0x4000F000UL
#define NRF_CCM_BASE                0x4000F000UL
#define NRF_WDT_BASE                0x40010000UL
#define NRF_RTC1_BASE               0x40011000UL
#define NRF_QDEC_BASE               0x40012000UL
#define NRF_COMP_BASE               0x40013000UL
#define NRF_LPCOMP_BASE             0x40013000UL
#define NRF_EGU0_BASE               0x40014000UL
#define NRF_SWI0_BASE               0x40014000UL
#define NRF_EGU1_BASE               0x40015000UL
#define NRF_SWI1_BASE               0x40015000UL
#define NRF_EGU2_BASE               0x40016000UL
#define NRF_SWI2_BASE               0x40016000UL
#define NRF_EGU3_BASE               0x40017000UL
#define NRF_SWI3_BASE               0x40017000UL
#define NRF_EGU4_BASE               0x40018000UL
#define NRF_SWI4_BASE               0x40018000UL
#define NRF_EGU5_BASE               0x40019000UL
#define NRF_SWI5_BASE               0x40019000UL
#define NRF_TIMER3_BASE             0x4001A000UL
#define NRF_TIMER4_BASE             0x4001B000UL
#define NRF_PWM0_BASE               0x4001C000UL
#define NRF_PDM_BASE                0x4001D000UL
#define NRF_ACL_BASE                0x4001E000UL
#define NRF_NVMC_BASE               0x4001E000UL
#define NRF_PPI_BASE                0x4001F000UL
#define NRF_MWU_BASE                0x40020000UL
#define NRF_PWM1_BASE               0x40021000UL
#define NRF_PWM2_BASE               0x40022000UL
#define NRF_SPI2_BASE               0x40023000UL
#define NRF_SPIM2_BASE              0x40023000UL
#define NRF_SPIS2_BASE              0x40023000UL
#define NRF_RTC2_BASE               0x40024000UL
#define NRF_I2S_BASE                0x40025000UL
#define NRF_FPU_BASE                0x40026000UL
#define NRF_USBD_BASE               0x40027000UL
#define NRF_UARTE1_BASE             0x40028000UL
#define NRF_QSPI_BASE               0x40029000UL
#define NRF_CRYPTOCELL_BASE         0x5002A000UL
#define NRF_CC_AES_BASE             0x5002B000UL
#define NRF_CC_CHACHA_BASE          0x5002B000UL
#define NRF_CC_CTL_BASE             0x5002B000UL
#define NRF_CC_DIN_BASE             0x5002B000UL
#define NRF_CC_DOUT_BASE            0x5002B000UL
#define NRF_CC_HASH_BASE            0x5002B000UL
#define NRF_CC_HOST_RGF_BASE        0x5002B000UL
#define NRF_CC_MISC_BASE            0x5002B000UL
#define NRF_CC_PKA_BASE             0x5002B000UL
#define NRF_CC_RNG_BASE             0x5002B000UL
#define NRF_CC_RNG_SRAM_BASE        0x5002B000UL
#define NRF_PWM3_BASE               0x4002D000UL
#define NRF_SPIM3_BASE              0x4002F000UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define NRF_FICR                    ((NRF_FICR_Type*)          NRF_FICR_BASE)
#define NRF_UICR                    ((NRF_UICR_Type*)          NRF_UICR_BASE)
#define NRF_APPROTECT               ((NRF_APPROTECT_Type*)     NRF_APPROTECT_BASE)
#define NRF_CLOCK                   ((NRF_CLOCK_Type*)         NRF_CLOCK_BASE)
#define NRF_POWER                   ((NRF_POWER_Type*)         NRF_POWER_BASE)
#define NRF_P0                      ((NRF_GPIO_Type*)          NRF_P0_BASE)
#define NRF_P1                      ((NRF_GPIO_Type*)          NRF_P1_BASE)
#define NRF_RADIO                   ((NRF_RADIO_Type*)         NRF_RADIO_BASE)
#define NRF_UART0                   ((NRF_UART_Type*)          NRF_UART0_BASE)
#define NRF_UARTE0                  ((NRF_UARTE_Type*)         NRF_UARTE0_BASE)
#define NRF_SPI0                    ((NRF_SPI_Type*)           NRF_SPI0_BASE)
#define NRF_SPIM0                   ((NRF_SPIM_Type*)          NRF_SPIM0_BASE)
#define NRF_SPIS0                   ((NRF_SPIS_Type*)          NRF_SPIS0_BASE)
#define NRF_TWI0                    ((NRF_TWI_Type*)           NRF_TWI0_BASE)
#define NRF_TWIM0                   ((NRF_TWIM_Type*)          NRF_TWIM0_BASE)
#define NRF_TWIS0                   ((NRF_TWIS_Type*)          NRF_TWIS0_BASE)
#define NRF_SPI1                    ((NRF_SPI_Type*)           NRF_SPI1_BASE)
#define NRF_SPIM1                   ((NRF_SPIM_Type*)          NRF_SPIM1_BASE)
#define NRF_SPIS1                   ((NRF_SPIS_Type*)          NRF_SPIS1_BASE)
#define NRF_TWI1                    ((NRF_TWI_Type*)           NRF_TWI1_BASE)
#define NRF_TWIM1                   ((NRF_TWIM_Type*)          NRF_TWIM1_BASE)
#define NRF_TWIS1                   ((NRF_TWIS_Type*)          NRF_TWIS1_BASE)
#define NRF_NFCT                    ((NRF_NFCT_Type*)          NRF_NFCT_BASE)
#define NRF_GPIOTE                  ((NRF_GPIOTE_Type*)        NRF_GPIOTE_BASE)
#define NRF_SAADC                   ((NRF_SAADC_Type*)         NRF_SAADC_BASE)
#define NRF_TIMER0                  ((NRF_TIMER_Type*)         NRF_TIMER0_BASE)
#define NRF_TIMER1                  ((NRF_TIMER_Type*)         NRF_TIMER1_BASE)
#define NRF_TIMER2                  ((NRF_TIMER_Type*)         NRF_TIMER2_BASE)
#define NRF_RTC0                    ((NRF_RTC_Type*)           NRF_RTC0_BASE)
#define NRF_TEMP                    ((NRF_TEMP_Type*)          NRF_TEMP_BASE)
#define NRF_RNG                     ((NRF_RNG_Type*)           NRF_RNG_BASE)
#define NRF_ECB                     ((NRF_ECB_Type*)           NRF_ECB_BASE)
#define NRF_AAR                     ((NRF_AAR_Type*)           NRF_AAR_BASE)
#define NRF_CCM                     ((NRF_CCM_Type*)           NRF_CCM_BASE)
#define NRF_WDT                     ((NRF_WDT_Type*)           NRF_WDT_BASE)
#define NRF_RTC1                    ((NRF_RTC_Type*)           NRF_RTC1_BASE)
#define NRF_QDEC                    ((NRF_QDEC_Type*)          NRF_QDEC_BASE)
#define NRF_COMP                    ((NRF_COMP_Type*)          NRF_COMP_BASE)
#define NRF_LPCOMP                  ((NRF_LPCOMP_Type*)        NRF_LPCOMP_BASE)
#define NRF_EGU0                    ((NRF_EGU_Type*)           NRF_EGU0_BASE)
#define NRF_SWI0                    ((NRF_SWI_Type*)           NRF_SWI0_BASE)
#define NRF_EGU1                    ((NRF_EGU_Type*)           NRF_EGU1_BASE)
#define NRF_SWI1                    ((NRF_SWI_Type*)           NRF_SWI1_BASE)
#define NRF_EGU2                    ((NRF_EGU_Type*)           NRF_EGU2_BASE)
#define NRF_SWI2                    ((NRF_SWI_Type*)           NRF_SWI2_BASE)
#define NRF_EGU3                    ((NRF_EGU_Type*)           NRF_EGU3_BASE)
#define NRF_SWI3                    ((NRF_SWI_Type*)           NRF_SWI3_BASE)
#define NRF_EGU4                    ((NRF_EGU_Type*)           NRF_EGU4_BASE)
#define NRF_SWI4                    ((NRF_SWI_Type*)           NRF_SWI4_BASE)
#define NRF_EGU5                    ((NRF_EGU_Type*)           NRF_EGU5_BASE)
#define NRF_SWI5                    ((NRF_SWI_Type*)           NRF_SWI5_BASE)
#define NRF_TIMER3                  ((NRF_TIMER_Type*)         NRF_TIMER3_BASE)
#define NRF_TIMER4                  ((NRF_TIMER_Type*)         NRF_TIMER4_BASE)
#define NRF_PWM0                    ((NRF_PWM_Type*)           NRF_PWM0_BASE)
#define NRF_PDM                     ((NRF_PDM_Type*)           NRF_PDM_BASE)
#define NRF_ACL                     ((NRF_ACL_Type*)           NRF_ACL_BASE)
#define NRF_NVMC                    ((NRF_NVMC_Type*)          NRF_NVMC_BASE)
#define NRF_PPI                     ((NRF_PPI_Type*)           NRF_PPI_BASE)
#define NRF_MWU                     ((NRF_MWU_Type*)           NRF_MWU_BASE)
#define NRF_PWM1                    ((NRF_PWM_Type*)           NRF_PWM1_BASE)
#define NRF_PWM2                    ((NRF_PWM_Type*)           NRF_PWM2_BASE)
#define NRF_SPI2                    ((NRF_SPI_Type*)           NRF_SPI2_BASE)
#define NRF_SPIM2                   ((NRF_SPIM_Type*)          NRF_SPIM2_BASE)
#define NRF_SPIS2                   ((NRF_SPIS_Type*)          NRF_SPIS2_BASE)
#define NRF_RTC2                    ((NRF_RTC_Type*)           NRF_RTC2_BASE)
#define NRF_I2S                     ((NRF_I2S_Type*)           NRF_I2S_BASE)
#define NRF_FPU                     ((NRF_FPU_Type*)           NRF_FPU_BASE)
#define NRF_USBD                    ((NRF_USBD_Type*)          NRF_USBD_BASE)
#define NRF_UARTE1                  ((NRF_UARTE_Type*)         NRF_UARTE1_BASE)
#define NRF_QSPI                    ((NRF_QSPI_Type*)          NRF_QSPI_BASE)
#define NRF_CRYPTOCELL              ((NRF_CRYPTOCELL_Type*)    NRF_CRYPTOCELL_BASE)
#define NRF_CC_AES                  ((NRF_CC_AES_Type*)        NRF_CC_AES_BASE)
#define NRF_CC_CHACHA               ((NRF_CC_CHACHA_Type*)     NRF_CC_CHACHA_BASE)
#define NRF_CC_CTL                  ((NRF_CC_CTL_Type*)        NRF_CC_CTL_BASE)
#define NRF_CC_DIN                  ((NRF_CC_DIN_Type*)        NRF_CC_DIN_BASE)
#define NRF_CC_DOUT                 ((NRF_CC_DOUT_Type*)       NRF_CC_DOUT_BASE)
#define NRF_CC_HASH                 ((NRF_CC_HASH_Type*)       NRF_CC_HASH_BASE)
#define NRF_CC_HOST_RGF             ((NRF_CC_HOST_RGF_Type*)   NRF_CC_HOST_RGF_BASE)
#define NRF_CC_MISC                 ((NRF_CC_MISC_Type*)       NRF_CC_MISC_BASE)
#define NRF_CC_PKA                  ((NRF_CC_PKA_Type*)        NRF_CC_PKA_BASE)
#define NRF_CC_RNG                  ((NRF_CC_RNG_Type*)        NRF_CC_RNG_BASE)
#define NRF_CC_RNG_SRAM             ((NRF_CC_RNG_SRAM_Type*)   NRF_CC_RNG_SRAM_BASE)
#define NRF_PWM3                    ((NRF_PWM_Type*)           NRF_PWM3_BASE)
#define NRF_SPIM3                   ((NRF_SPIM_Type*)          NRF_SPIM3_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


#ifdef __cplusplus
}
#endif

#endif /* NRF52840_H */


/** @} */ /* End of group nrf52840 */

/** @} */ /* End of group Nordic Semiconductor */
